<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
<LINK REL=STYLESHEET TYPE="text/css" HREF="styl.css">
<TITLE>Clipper compiler</TITLE>
</HEAD>
<BODY>
<hr>
  <h3> CREATE TABLE </h3>

<xmp>

Создает базу данных.

CREATE TABLE | DBF <имя БД>
        (<имя поля1> <тип> [(<ширина>
        [, <точность>])
        [, <имя поля2> ... ]])
        | FROM ARRAY <массив>

Каждое новое поле базы данных характеризуется именем, типом, шириной и
точностью. Эти характеристики должны содержаться в самой команде или
браться из массива. Hовая база данных открывается в режиме
индивидульного использования, независимо от значения установки SET
EXCLUSIVE.

CREATE TABLE | DBF <имя БД>
<имя БД> - имя создаваемой базы данных, которое может содержать путь и
являться выражением.

(<имя поля1> <тип> [(<ширина> [, <точность>] [, <имя поля2>...])
<имя поля1> и <имя поля2> - имена полей новой базы данных. Каждое <имя
поля> может представлять собой выражение.

<тип> - буква, означающая тип данных поля. Hекоторые типы данных требуют
обязательного задания <ширины> поля и <точности> (количество символов
после запятой).

FROM ARRAY <массив>
<массив> - имя существующего массива, содержащего значения имени, типа,
ширины и точности для каждого поля базы данных. Значения элементов
массива  могут  быть  определены  при  помощи  функции AFIELDS().

 Примеры:
CREATE TABLE employee (name C(20), addr C(30), city C(30),;
             zip C(5), salary N(8,2), comments M)

CREATE DBF contacts FROM ARRAY ncontact
</xmp>
<hr>
<h3>          INSERT - SQL           </h3>
<xmp>
INSERT добавляет записи в конец базы данных.

INSERT INTO <имя БД>
        [(<имяп1> [, <имяп2>
                [, ...]])]
        VALUES (<выр1> [, <выр2>
                [, ...]])

INSERT INTO <имя БД>
        FROM ARRAY <массив>
        FROM MEMVAR


INSERT добавляет записи в конец существующей базы данных. Hовые записи
включают данные, перечисленные в команде INSERT, данные содержащиеся в
указанном  массиве   или  данные  из   временных переменных.

INSERT INTO <имя БД>
<имя БД>  - имя  базы данных,  в которую  будут добавлены записи.
<имя БД> может содержать путь или являться выражением.

[(<имяf1> [, <имяf2> [, ...]])]
VALUES (<выр1> [, <выр2>[, ...]])
Определяет значения (<выр1>, <выр2>, ... ), которые будут помещены в
запись, добавляемую в базу данных. Если не указаны имена полей, данные
необходимо  размещать  в  соответствии  со структурой базы данных.

Если указаны имена полей <имяп1>, <имяп2>, и т. д., имена полей могут
следовать в произвольном порядке. Каждое <имяп> может являться
выражением.

FROM ARRAY <массив>
<массив> - имя существующего массива, в котором содержатся данные для
добавляемой записи.

FROM MEMVAR
FROM MEMVAR копирует данные из временных переменных в новую запись базы
данных, определенной при помощи <имя БД>. Данные копируются только в те
поля, которые имеют соответствующие временные переменные. Если временные
переменные существуют только для некоторых полей базы данных <имя БД>,
остальные поля  будут пустыми.

Примеры:
INSERT INTO parts (pno, descript,;
onhand, onorder, price, cost) ;
VALUES ('B6722', 'Королевский пудель',;
         2, 6, 27.99, 20.65)

USE  customer
COPY STRUCTURE TO cust2
SCATTER  MEMVAR
INSERT INTO cust2 FROM MEMVAR

</xmp>
<hr>
 <h3>   SELECT - SQL    </h3>
<xmp>
Извлечение данных из базы или баз данных.

SELECT [ALL | DISTINCT]
        [<псевдоним>.]<искомый_элемент>
                [AS <имя_столбца>]
                [, [<псевдоним>.]<искомый_элемент>
                [AS <имя_столбца>] ...]
        FROM <база_данных> [<локальный_псевдоним>]
                [, <база_данных>
                [<локальный_псевдоним>] ...]
        [[INTO <назначение>]
                | [TO FILE <файл>
                [ADDITIVE] | TO PRINTER]]
        [NOCONSOLE]
        [PLAIN]
        [NOWAIT]
        [WHERE <условие_соединения>
                [AND <условие_соединения> ...]
                        [AND | OR
                        <условие_фильтрации>
                        [AND | OR
                        <условие_фильтрации>
        ...]]]
        [GROUP BY <столбец_группировки>
               [, <столбец_группировки> ...]]

        [HAVING <условие_фильтра>]
        [UNION [ALL] <команда SELECT>]
        [ORDER BY <элемент_упорядочения> [ASC | DESC]
                [, <элемент_упорядочения> [ASC | DESC]...]]

SELECT [ALL | DISTINCT]
  [<псевдоним>.]<искомый_элемент> [AS <имя_столбца>]
  [, [<псевдоним>.]<искомый_элемент> [AS <имя_столбца>] ...]
     Каждый <искомый_элемент> может быть:
     -   Полем базы данных, указанной во фразе FROM
     - Константой, указанное значение константы появится в каждом ряду
     результата запроса.
     -   Выражением, которое может включать пользовательскую функцию.

     Для использования с <искомыми_элементами> доступны функции работы с
     полями так, что это поле или выражение,  включающее поле:

     - AVG(<искомый_элемент>) - среднее значение по колонке числовых
     данных.

     - COUNT(<искомый_элемент>) -   число искомых  элементов  в колонке.
       COUNT(*)  определяет число рядов в  выводе запроса.

     - MIN(<искомый_элемент>) - определяет наименьшее значение искомого
     элемента в колонке.

     - MAX(<искомый_элемент>) - определяет наибольшее значение искомого
     элемента в колонке.

     - SUM(<искомый_элемент>) - определяет суммарный итог по колонке
     числовых данных.

     Функции работы с полями не могут быть вложенными.

     По умолчанию выводятся вся ряды результата запроса (опция ALL). Для
     исключения дубликатов рядов указывается ключевое слово DISTINCT. В
     команде  SELECT можно  указывать DISTINCT только однократно.

Hеобязательная фраза AS <имя_столбца> специфицирует заголовок колонки в
выводе результата запроса. Это полезно, когда имеются такие (
<искомые_элементы>), которые являются выражением или содержат функции
работы с полями, и требуется присвоить колонке в результате
соответствующее   имя.   <имя_столбца>   может  быть выражением.

FROM <база_данных> [<локальный_псевдоним>]
  [, <база_данных> [<локальный_псевдоним>] ...]
     Перечисляются все <базы_данных>, которые содержат данные,
     извлекаемые из них при поиске. <Локальный_псевдоним> это временное
     имя для <базы_данных>. Если специфицирован <локальный_псевдоним>,
     то обязательно следует использовать его вместо имени базы данных во
     всей команде SELECT.

INTO <назначение>
     Если специфицирована фраза INTO, то генерируемый результирующий
     вывод не выводится. Если в одном запросе специфицировано как INTO,
     так и TO, то TO игнорируется. Если же фраза INTO не использована то
     результат запроса появится на экране, при этом его можно направить
     на принтер или в файл фразой TO.

        <назначением> может быть:

        - ARRAY <массив> - записывает результаты запроса во временную
переменную <массив>.

        - CURSOR <курсор> - Записывает результаты запроса в так
называемый <курсор>. Если указанный <курсор> является именем открытой
базы данных, то FoxPro закрывает эту базу данных и создает вместо нее
другую. Это будет сделано без предупреждения, если установлено SET
SAFETY OFF. После выполнения команды SELECT временный "курсор" остается
открытым, но он доступен только для чтения. После закрытия "курсора"
последний  удаляется. "Курсоры" располагаются на дисководе SORTWORK.

        - DBF <база_данных> | TABLE <база_данных> - записывает
результаты запроса в <базу_данных>. Если указать уже открытую базу
данных, то FoxPro закроет ее и откроет вновь. Если при этом установлено
SET SAFETY OFF, то предупреждающего сообщения не будет. Если в имени не
указать расширения, то будет присвоено расширение .DBF. После завершения
команды  SELECT  база  данных остается открытой и активной.

[TO FILE <файл> [ADDITIVE]
  | TO PRINTER]]
     Если фраза INTO не указывалась, и использована фраза TO, то с ее
     помощью можно направить результаты выполнения запроса в текстовый
     файл ASCII <файл> или на принтер, в дополнение к выводу на экран.
     Фраза ADDITIVE добавляет вывод к существующему содержанию файла
     <файл>. Если не использована ни фраза TO, ни фраза INTO, результаты
     запроса будут выведены на экран, если только не специфицировано
     NOCONSOLE.

      В результатах выполнения запроса колонки именуются  следующим образом:

        - Если <искомый_элемент> является полем с уникальным именем,
колонке присваивается имя этого поля.

        - Если более одного <искомого_элемента> имеют одно и то же имя,
например, CUST.ZIP и STATE.ZIP, то колонки получат наименования ZIP_A и
ZIP_B. Для <искомого_элемента> с десятью символами в имени имя будет
усечено  для  возможности   добавления  подчеркивания   и символа.

        - Если <искомый_элемент> является выражением, колонка в
результате выполнения запроса получит имя EXP_A. Все другие выражения
получат имена EXP_B, EXP_C, и т.д.

        - Если <искомый элемент> содержит функцию работы с полем, такую,
как, например, COUNT(), то колонка в результатах получит имя COUNT_A.
/* В clip~е все результирующие колонки с вычисляемыми значениями именуются
  EXP_A,EXP_B, ......*/

NOCONSOLE
     Предотвращает вывод результатов запроса на экран. Игнорируется,
     если использована фраза INTO.

PLAIN
     Предотвращает появление наименований колонок в результатах.
     Игнорируется, если использована фраза INTO.

NOWAIT
     Прокручивает результаты выполнения запроса на экране после полного
     его заполнения. При этом не выдается запрос на нажатие какой-либо
     клавиши для продолжения просмотра. Фраза игнорируется при наличии
     фразы INTO.

[WHERE <условие_соединения>
  [AND <условие_соединения> ...]
  [AND | OR <условие_фильтрации>
  [AND | OR <условие_фильтрации>...]]]
     Позволяет включить в результаты запроса только определенные записи.
     <Условие_соединения> специфицируетполя, которые соединяют базы
     данных во фразе FROM. Если в запросе имеется более одной базы
     данных, то необходимо специфицировать условие соединения для каждой
     базы данных после первой.

          ПРЕДУПРЕЖДЕHИЕ
     Если включить в запрос две базы данных и не специфицировать условие
     соединения, то каждая запись из первой базы данных будет
     соединяться с каждой записью из второй базы данных при выполнении
     условия фильтрации.

     Будьте осторожны при соединении баз данных с пустыми полями:
     FoxPro сравнивает и пустые поля на совпадение. Чтобы избежать этого
     используется функция EMPTY().

     Множество условий соединения можно объединить посредством оператора
     AND. <Условия_соединения> могут содержать функции работы с полями и
     иметь следующий формат:

        <поле1> <сравнение> <поле2>

        где <поле1> это  поле из одной  базы данных, а  <поле2> -
        поле из другой базы данных. При этом <сравнение> имеет один из
следующих видов:

        <сравнение>
        ───────────
         =
        < >, !=, #
           = =
           >
          > =
           <
          < =

        Когда для сравнения строк используется оператор =, то его
действие по-разному зависит от установки команды  SET ANSI | SET EXACT.

        <Условие_фильтрации> специфицирует критерий, которому должны
удовлетворять записи, чтобы попасть в результат действия запроса.
Условия фильтрации можно соединять операторами AND и OR. Можно также
использовать оператор NOT для реверса значения логического выражения, а
также использовать EMPTY() для выявления пустых полей.
<Условие_фильтрации>  может  принимать  один из следующих форматов:

        Формат: <поле1> <сравнение> <поле2>
        Пример: customer.cust_id =payments.cust_id

        Формат: <поле> <сравнение> <выражение>
        Пример: payments.amount >= 1000

        Формат: <поле> <сравнение> ALL (<подзапрос>)
        Пример: taxrate < ALL ;
        (SELECT taxrate FROM customer WHERE state = 'MI')

                Посредством ALL задается условие соответствия <поля>
условиям сравнения для ВСЕХ значений, сгенерированных подзапросом, чтобы
записи, где содержатся  эти  поля,  попали  бы  в   результат запроса.

        Формат: <поле> <сравнение> ANY | SOME (<подзапрос>)
        Пример: taxrate < ANY ;
         (SELECT taxrate FROM customer WHERE state = 'MI')

                Посредством ANY или SOME задается условие соответствия
для <поля> по крайней мере одному из значений условий сравнения,
сгенерированных подзапрсом.

        Формат: <поле> [NOT] BETWEEN <начало> AND <конец>
        Пример: customer.taxrate BETWEEN 5.50 AND  6.00

                Проверка на то, что <поле> имеет значение в заданном
диапазоне.

        Формат: [NOT] EXISTS (<подзапрос>)
        Пример: EXISTS ;
                (SELECT * FROM invoice WHERE customer.zip = invoice.zip)

                Проверка на существование по крайней мере одного ряда,
удовлетворяющему условию подзапроса. Посредством EXISTS условие
фильтрации оценивается как "истина", если только результат подзапроса не
является пустым множеством.

        Формат: <поле> [NOT] IN <набор_значений>
        Пример: customer.zip NOT IN ('43411','43506','43667')

                Посредством IN задается условие, что <поле> должно быть
частью заданного набора значений, чтобы соответствующая ему запись
попала в результат работы запроса.

        Формат: <поле> [NOT] IN (<подзапрос>)
        Пример: customer.cust_id IN ;
                (SELECT tranfile.cust_id FROM tranfile WHERE
                tranfile.item='FoxPro')

                В данном случае <поле> должно быть частью набора
значений, возвращенных подзапросом, чтобы соответствующая ему запись
попала  в результат работы запроса.

        Формат: <поле> [NOT] LIKE <высC>
        Пример: customer.state NOT LIKE 'OH'

                Это условие фильтрации проверяет для каждого <поля>, что
оно соответствует заданному <вырC>. В качестве части этого выражения
можно использовать специальные символы % (процент) и _<(подчеркивание)>.
Подчеркивание _ означает подстановку одного любого символа, а процент %
-           произвольную последовательность таких символов.

        Подзапрос является командой SELECT внутри внешней команды SELECT
(запроса) и заключается в скобки. а одном уровне можно иметь множество
подзапросов для фразы WHERE однако вложение подзапросов не допускается.
Подзапросы могут одержать множественные условия соединения.

        В условиях соединения фразы WHERE могут быть использованы
следующие функции: UPPER(), VAL(), DTOC(), PADR(), PADL() и PADC().

[GROUP BY <столбец_группировки>
  [, <столбец группировки> ...]]
     Группирование рядов в запросе базируется на значениях их столбца
     или столбцов. <Столбец_группировки> может быть полем базы данных,
     полем базы данных, которое включено в функцию работы с полями SQL,
     или числовым выражением, указывающим на положение столбца в
     результирующей  таблице (самый левый столбец имеет номер 1).

HAVING <условие_фильтрации>
     Сообщает FoxPro о необходимости включения групп в результаты
     запроса по мере их соответствия <условию_фильтрации>. Это условие
     не может содержать подзапрос.

     HAVING <условие_фильтрации> следует использовать совместно с GROUP
     BY для специфицирования условий, согласно которым группы могут
     включаться в результаты запроса. HAVING может включать столько
     условий фильтрации, сколько требуется, эти условия соединяются
     операторами AND или OR. Можно также использовать и NOT для реверса
     значения логических  выражений.

        HAVING без GROUP BY действует подобно фразе WHERE. Во фразе
HAVING можно использовать локальные псевдонимы и функции работы с
полями.

/*  в clip~е эта команда пока не поддерживается */
[UNION [ALL] <команда SELECT>]
     Выполняет объединение результата одной команды SELECT с результатом
     другой <команды SELECT>. По умолчанию UNION проверяет комбинации
     результатов и устраняет ряды-дубликаты. Для предотвращения этого
     устранения используется фраза ALL.

        Для комбинации нескольких фраз UNION используются скобки.

        Правила выполнения UNION:

        -  Hельзя использовать UNION для комбинации подзапросов.

        - Обе команды SELECT должны выдавать одинаковое количество
столбцов.

        - Каждая колонка в результатах запроса должна иметь такой же тип
данных,  что  и соответствующая колонка в другой <команде SELECT>.

        - Только последняя <команда SELECT> может содержать фразу ORDER
BY, и ORDER BY должна ссылаться на вывод по номеру колонки. Если ORDER
BY включена,  она влияет  на  общий результат.

[ORDER BY <элемент_упорядочения>
  [ASC | DESC][, <элемент_упорядочения>
  [ASC | DESC]...]]
     Сортирует результаты запроса на основании значений данных в колонке
     или колонках. Каждый <элемент_упорядочения> должен соответствовать
     колонке в результате действия запроса и может при этом являться:

        - Полем в базе данных из фразы FROM, которое также является
<искомым_элементом> в  главной фразе SELECT  (но не в подзапросе).

        - Числовым выражением, указывающим на положение столбца в
результирующей таблице. Самый левый столбец имеет номер 1.

        Фраза DESC вызывает упорядочение по убыванию значения
соответствующего <элемента_упорядочения>. Фраза ASC специфицирует
упорядочение   по   возрастанию и принимается по умолчанию.

Примеры:

Вывод всех компаний company в базе данных CUSTOMER (одно поле в одной
базе данных) на экран.

SELECT customer.company ;
        FROM customer

Вывод трех полей из двух баз данных и соединение двух баз данных с
помощью значений поля CUST_ID.

SELECT a.company, b.date, b.amount ;
        FROM customer a, payments b ;
        WHERE a.cust_id = b.cust_id

Вывод  только  данных  с  уникальными  значениями  (без  повторов
рядов).

SELECT DISTINCT a.cust_id, b.date, b.amount ;
        FROM customer a, payments b ;
        WHERE a.cust_id = b.cust_id

Вывод из CUSTOMER нескольких полей в возрастающем порядке по значениям
полей STATE, ZIP и COMPANY.

SELECT state, zip, company, cust_id ;
        FROM customer ;
        ORDER BY state, zip, company

Запись полей из двух баз данных в третью базу данных.

SELECT a.cust_id, a.company, b.po ;
        FROM customer a, invoice b ;
        WHERE a.cust_id = b.cust_id ;
        INTO TABLE c:\cust_po.dbf

Вывод только  тех записей,  у которых  дата inv_date  меньше, чем 10/15/90.

SELECT a.cust_id, a.company, b.po ;
      FROM customer a, invoice b ;
      WHERE (a.cust_id = b.cust_id) AND (b.inv_date < {10/15/90})

Вывод всех фирм company из базы данных CUSTOMER, у которых почтовый
индекс zip соответствует почтовому индексу в базе данных INVOICE.

SELECT company FROM customer a WHERE ;
        EXISTS (SELECT * FROM invoice b WHERE a.zip = b.zip)

Вывод всех записей из базы данных CUSTOMER, имеющих название фирмы,
начинающееся  с  'C',  независимо  от  неизвестной  длины названия.

SELECT * FROM customer a WHERE a.company LIKE 'C%'

Вывод всех записей из базы данных CUSTOMER, у которых краткое название
штата, в котором они расположены, начинается с 'N' в сочетании с одним
любым другим символом.

SELECT * FROM customer a WHERE a.state LIKE 'N_'

Вывод всех записей из базы данных CUSTOMER, у которых значение налога
taxrate меньше, чем любое значение налога в штате Мичиган "MI".

SELECT * FROM customer a WHERE a.taxrate < ANY ;
        (SELECT taxrate from customer WHERE state = "MI")

Вывести названия всех городов из базы данных CUSTOMER в символах
верхнего регистра, колонку в выводе назвать CityList.

SELECT UPPER(city) AS CityList FROM customer

</xmp>
<HR>
<center>&#169 Хныкин Юрий, <A HREF="mailto:uri@itk.ru">uri@itk.ru</A>, 2001
</center>
</BODY>
</HTML>

