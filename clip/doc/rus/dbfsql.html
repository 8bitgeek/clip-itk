<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
<LINK REL=STYLESHEET TYPE="text/css" HREF="styl.css">
<TITLE>Clipper compiler</TITLE>
</HEAD>
<BODY>
	<h4> SQL интерпретатор для обработки DBF </H4>
 <p>
 Данный интерпретатор выполнен в стиле FOXPRO и почти полностью совместим с
 ним (несколько фенечек просто не доделаны), дальнейшее развитие этого
 интерпретатора зависит от его "полезности", т.е. насколько он актуален и нужен
 решать вам - писателям на clip. Надо будет обеспечить полную поддержку
 SQL-XX,  значит  будет  делаться  и  добиваться.  В  данный момент мы
 считаем, что реализованных возможностей вполне достаточно для обеспечения
 "генераторов отчетов" и т.п. альтернативным механизмом доступа к данным.
 <p>
 Чтобы использовать интерпретатор в программе надо подключить foxsql.ch
 и далее использовать команды: <BR>
 create table <BR>
 insert into <BR>
 select from. <BR>
 Подробнее ссылка на
 <a href="sqlfox.html">кусок документации из FOXPRO</a>.
 В данный момент не поддерживается только UNION в команде select from
 и небольшая неточность в именовании результирующих вычисляемых колонок:
 foxpro именует колонки sum(f) как sum_f, clip же именует ВСЕ вычисляемые
 колонки как EXP_A,EXP_B,EXP_C,..... .
 <BR>

<hr>
	<h3> Библиотеки и классы для работы с SQL-серверами </H3>
<pre>
<a href="#tconnect"> Класс TConnect</a>
<a href="#trowset" > Класс TRowset</a>
<hr>
<a href="../clip-postgres/postgres.html"> СУБД Postgres</a>
<a href="../clip-mysql/mysql.html"> СУБД MySQL</a>
<a href="../clip-oracle/oracle.html"> СУБД Oracle</a>
</pre>
<hr>
<a name="tconnect"></a>
<a href="#tconnectov"> Класс TConnect - обзор</a>
<hr>
<b>Методы класса</b>
<pre>
<a href="#connectnew"   ><tt>ConnectNew()       Конструктор TConnect</tt></a>
<a href="#command"      ><tt>Command()          Выполняет оператор SQL</tt></a>
<a href="#testparser"	><tt>TestParser()       Парсер команды (отладочная функция)</tt></a>
<a href="#createrowset" ><tt>CreateRowset()     Создает объект класса TRowset</tt></a>
<a href="#cdestroy"     ><tt>Destroy()          Уничтожает объект</tt></a>
</pre>
<hr>
<a name="tconnectov"></a>
<b>Класс TConnect</b><br>
Представляет объекты - подключения к СУБД.<br>
<hr><br>
 Конструктор TConnect производит подключение (login) к базе данных. С этим
 подключением можно делать две вещи. Во-первых, выполнять операторы SQL,
 ничего не возвращающие (такие как CREATE TABLE, COMMIT). Во-вторых,
 можно создавать объекты - наборы записей, получающиеся при выполнении
 операторов SELECT. О работе с такими объектами - наборами записей, смотрите
 документацию по классу TRowset.
<br> <br>
 По окончании работы с подключением объект TConnect следует уничтожить. При
 этом производится отключение (logout) от базы данных.<br>
<hr>
См. также:
<a href="#trowset" > Класс TRowset</a><br>
<hr>
<a name="connectnew"></a>
<b>ConnectNew()</b><br>
Создает объект класса TConnect.<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	ConnectNew(&lt;rdbmsId&gt;,[&lt;RDBMS specific&gt;,...])
	--> коннект
<br> <br>
<b>Аргументы</b>
<br> <br>
	&lt;rdbmsId&gt; - строка, идентифицирующая СУБД.
<br> <br>
	&lt;RDBMS specific&gt; - параметры для подключения к конкретной СУБД.
<br> <br>
<b>Возвращаемое значение</b>
<br> <br>
	ConnectNew возвращает объект класса TConnect, необходимый для
	дальнейшего взаимодействия с сервером.
<br> <br>
<b>Описание</b>
<br> <br>
	Функция устанавливает соединение с сервером базы данных и создает объект -
	соединение. После окончания работы с сервером объект должен быть уничтожен
	при помощи метода Destroy. В случае возникновения ошибки подключения
	генерируется ошибка.
<br> <br>
	Об особенностях использования ConnectNew для разных СУБД, смотрите
	соответствующие этим СУБД разделы документации.
<br> <br>
<b>Пример</b>
<br> <br>
	В этом примере производится подключение к базе данных <b>mydb</b>
	базы данных Postgres. Остальные специфичные для Postgres параметры
	используются по умолчанию.
<pre><b>
conn := ConnectNew("PG",,,,,"mydb")
</b></pre>
<hr>
<b>См. также:</b>
<a href="#cdestroy">[ TConnect:Destroy() ]</a><br>
<hr>
<a name="command"></a>
<b>Command()</b><br>
Выполняет оператор SQL.<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	Command(&lt;sql&gt;,[&lt;pars&gt;]) --> кол-во записей
<br> <br>
<b>Аргументы</b>
<br> <br>
	&lt;sql&gt; - оператор SQL
<br> <br>
	&lt;pars&gt; - массив параметров SQL
<br> <br>
<b>Возвращаемое значение</b>
<br> <br>
	Command() возвращает кол-во записей, на которые воздействовала команда
	(affected rows).
<br> <br>
<b>Описание</b>
<br> <br>
	Метод Command() используется для выполнения любых операторов SQL,
	понятных серверу базы данных, за исключением SELECT. Для выполнения
	оператора SELECT с получением результатов работы запроса используйте
	метод CreateRowset. Если оператор по какой-то причине
	не может быть выполнен сервером, генерируется ошибка.
<br> <br>
	Необязательный параметр &lt;pars&gt; представляет собой массив
	параметров вида {{&lt;parname&gt;,&lt;parvalue&gt;}[,...]}.
<br> <br>
<b>Примеры</b>
<br> <br>
	В этом примере производится подключение к базе данных <b>mydb</b>
	сервера Postgres и создается таблица <b>mytable</b>.
<pre><b>
conn := PG_ConnectNew(,,,,"mydb")
conn:Command("CREATE TABLE mytable (fname char(20),lname char(20))")
</b> </pre>
	В следующем примере из таблицы <b>mytable</b> удаляются все записи,
	в которых поле <b>fname</b> имеет значение <b>John</b>.
<pre><b>
conn:Command("DELETE FROM mytable WHERE fname=:firstname",
   {{"firstname","John"}})
</b></pre>
<hr>
<b>См. также:</b><a href="#createrowset">[ CreateRowset() ]</a><br>
<hr>
<a name="testparser"></a>
<b>TestParser()</b><br>
Парсер команды (отладочная функция).<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	TestParser(&lt;sql&gt;,[&lt;pars&gt;]) --> SQL
<br> <br>
<b>Аргументы</b>
<br> <br>
	&lt;sql&gt; - оператор SQL
<br> <br>
	&lt;pars&gt; - массив параметров SQL
<br> <br>
<b>Возвращаемое значение</b>
<br> <br>
	TestParser() возвращает отпарсенную команду (SQL-оператор).
<br> <br>
<b>Описание</b>
<br> <br>
	Метод TestParser() используется при отладке программы.
	Полезен для составления SQL операторов с параметрами для серверов,
	не поддерживающих механизм передачи параметров операторам
	(таким как Postgres	и MySQL).<br>
	Возвращаемая строка представляет собой оператор, фактически
	передаваемый серверу.
<br> <br>
	Необязательный параметр &lt;pars&gt; представляет собой массив
	параметров вида {{&lt;parname&gt;,&lt;parvalue&gt;}[,...]}.
<br> <br>
<b>Примеры</b>
<br> <br>
<pre><b>
conn := PG_ConnectNew(,,,,"mydb")
conn:TestParser("SELECT * FROM test WHERE fname=:p1",{{"p1","Вася"}})
</b> </pre>
<hr>
<b>См. также:</b><a href="#createrowset">[ CreateRowset() ]</a><br>
<hr>
<a name="createrowset"></a>
<b>CreateRowset()</b><br>
Выполняет оператор SELECT и создает объект класса TRowset.<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	CreateRowset(&lt;selectSQL&gt;,[&lt;pars&gt;],[&lt;insertSQL&gt;],
	[&lt;deleteSQL&gt;],[&lt;updateSQL&gt;],[&lt;refreshSQL&gt;],
	[&lt;idname&gt;],[&lt;orders&gt;]) --> набор записей
<br> <br>
<b>Аргументы</b>
<br> <br>
	&lt;selectSQL&gt; - оператор SELECT для получения записей
<br> <br>
	&lt;pars&gt; - массив параметров SQL
<br> <br>
	&lt;insertSQL&gt; - оператор INSERT для добавления записи
<br> <br>
	&lt;deleteSQL&gt; - оператор DELETE для удаления записи
<br> <br>
	&lt;updateSQL&gt; - оператор UPDATE для изменения записи
<br> <br>
	&lt;refreshSQL&gt; - оператор SELECT для обновления записи набора
<br> <br>
	&lt;idname&gt; - имя поля - идентификатора записи (только для ODBC)
<br> <br>
	&lt;orders&gt; - массив с описанием локальных индексов (ордеров)
<br> <br>
<b>Возвращаемое значение</b>
<br> <br>
	CreateRowset() возвращает объект класса TRowset.
<br> <br>
<b>Описание</b>
<br> <br>
	CreateRowset() выполняет запрос &lt;selectSQL&gt;, получает
	результирующий набор записей и возвращает объект класса TRowset.
	Операторы &lt;insertSQL&gt;,&lt;deleteSQL&gt;,
	&lt;updateSQL&gt;,&lt;refreshSQL&gt; (если определены) используются
	для отражения в базе данных изменений, производимых с набором записей.
	Смотрите описание класса TRowset.
<br> <br>
	Необязательный параметр &lt;pars&gt; представляет собой массив
	параметров вида {{&lt;parname&gt;,&lt;parvalue&gt;[,&lt;partype&gt;]}[,...]}.
	&lt;partype&gt; требуется только для СУБД Oracle, и представляет собой
	номер типа ORACLE (см. файл oracle.ch).
<br> <br>
	Эти параметры могут использоваться в любых операторах автоматического
	отражения (insertSQL, deleteSQL, updateSQL, refreshSQL) создаваемого
	набора.
<br> <br>
	Параметр &lt;idname&gt; необходимо указывать лишь при использовании ODBC.
<br> <br>
	Необязательный параметр &lt;orders&gt; представляет собой массив вида:
	{{&lt;order_name&gt;,&lt;expr&gt;[,&lt;key_len&gt;]}[,...]}, где<br>
	&lt;order_name&gt; - имя создаваемого ордера (тег);<br>
	&lt;expr&gt; - имя поля, номер поля или блок кода возвращающий
	значение ключа для записи;<br>
	&lt;key_len&gt; - длина ключа (только для символьных ключей).
<br> <br>
	Вместо передачи параметра &lt;orders&gt; можно воспользоваться функцией
	TRowset:CreateOrder(), создающей один ордер для уже существующего набора
	записей.
<br> <br>
	После окончания работы с набором записей объект следует уничтожить при
	помощи метода Destroy().
<br> <br>
<b>Пример</b>
<br> <br>
	В этом примере производится подключение к базе данных mydb
	базы данных Postgres и создается редактируемый объект TRowset
	с записями из таблицы mytable и с локальными индексами (ордерами)
	по всем полям.
<pre><b>
conn := ConnectNew("PG",,,,,"mydb")
rs := conn:CreateRowset("SELECT oid,fname,lname FROM mytable",NIL,;
   "INSERT INTO mytable (%FIELDS) VALUES (%VALUES)",;
   "DELETE FROM mytable WHERE oid=:oid",;
   "UPDATE mytable SET %LIST WHERE oid=:oid",;
   "SELECT oid,fname,lname FROM mytable WHERE oid=:oid",,;
   {{"oid","oid"},{"fname","fname",20},{"lname","lname",20}})
</b></pre>
<hr>
<b>См. также:</b>
<a href="#trowset">[ TRowset ]</a>
<a href="#rsdestroy">[ TRowset:Destroy() ]</a><br>
<a href="#createorder">[ TRowset:CreateOrder() ]</a><br>
<hr>
<a name="cdestroy"></a>
<b>Destroy()</b><br>
Уничтожает объект TConnect.<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	Destroy() --> NIL
<br> <br>
<b>Описание</b>
<br> <br>
	Destroy() уничтожает объект класса TConnect.
<br> <br>
<b>Пример</b>
	В этом примере производится подключение к базе данных <b>mydb</b> базы
	данных Postgres. После выполнения некоторых работ объект TConnect
	уничтожается.
<pre><b>
conn := ConnectNew("PG",,,,,"mydb")
...
conn:Destroy()
</b></pre>
<hr>
<a name="trowset"></a>
<a href="#trowsetov">Класс TRowset - обзор</a>
<hr>
<b>Экспортируемые переменные</b>
<pre>
<a href="#insertsql" ><tt>insertSQL          Оператор SQL для отражения в базе данных</tt></a>
<a href="#deletesql" ><tt>deleteSQL          Оператор SQL для отражения в базе данных</tt></a>
<a href="#updatesql" ><tt>updateSQL          Оператор SQL для отражения в базе данных</tt></a>
<a href="#refreshsql"><tt>refreshSQL         Оператор SQL для обновления текущей записи набора</tt></a>
</pre>
<b>Методы класса</b>
<pre>
<a href="#bof"          ><tt>Bof()           Определяет достижение начала набора записей</tt></a>
<a href="#eof"          ><tt>Eof()           Определяет выход за последнюю запись</tt></a>
<a href="#recno"        ><tt>Recno()         Возвращает номер текущей записи</tt></a>
<a href="#lastrec"      ><tt>Lastrec()       Определяет число записей в наборе записей</tt></a>
<a href="#nfields"      ><tt>NFields()       Определяет число полей в наборе записей</tt></a>
<a href="#fieldno"      ><tt>FieldNo()       Возвращает порядковый номер поля по его имени</tt></a>
<a href="#fieldname"    ><tt>FieldName()     Возвращает имя поля по его порядковому номеру</tt></a>
<a href="#fieldtype"    ><tt>FieldType()     Возвращает тип поля по его порядковому номеру</tt></a>
<a href="#fieldlen"     ><tt>FieldLen()      Возвращает длину поля по его порядковому номеру</tt></a>
<a href="#fieldnullable"><tt>FieldNullable() Определяет, может ли принимать поле значения NULL</tt></a>
<a href="#fieldunsigned"><tt>FieldUnsigned() Определяет, может ли принимать поле отрицательные значения</tt></a>
<a href="#fieldbinary"  ><tt>FieldBinary()   Определяет, является ли поле бинарным</tt></a>
<a href="#getvalue"     ><tt>GetValue()      Возвращает значение поля по его порядковому номеру</tt></a>
<a href="#setvalue"     ><tt>SetValue()      Устанавливает значение поля с указанным порядковым номером</tt></a>
<a href="#append"       ><tt>Append()        Добавляет запись к набору записей</tt></a>
<a href="#delete"       ><tt>Delete()        Удаляет текущую запись</tt></a>
<a href="#read"         ><tt>Read()          Возвращает значения полей текущей записи</tt></a>
<a href="#write"        ><tt>Write()         Устанавливает значения полей текущей записи</tt></a>
<a href="#gotop"        ><tt>GoTop()         Перемещает указатель на первую запись</tt></a>
<a href="#gobottom"     ><tt>GoBottom()      Перемещает указатель на последнюю запись</tt></a>
<a href="#skip"         ><tt>Skip()          Перемещает указатель относительно текущей записи</tt></a>
<a href="#goto"         ><tt>Goto()          Перемещает указатель на запись с заданным номером</tt></a>
<a href="#createorder"  ><tt>CreateOrder()   Создает локальный индекс (ордер)</tt></a>
<a href="#setorder"     ><tt>SetOrder()      Устанавливает/возвращает активный локальный индекс (ордер)</tt></a>
<a href="#seek"         ><tt>Seek()          Быстрый поиск по локальному индексу (ордеру)</tt></a>
<a href="#fieldblock"   ><tt>FieldBlock()    Возвращает блок кода для доступа к полю набора записей</tt></a>
<a href="#browse"       ><tt>Browse()        Просмотр записей в окне</tt></a>
<a href="#rsdestroy"    ><tt>Destroy()       Уничтожает объект</tt></a>
</pre>
<hr>
<a name="trowsetov"></a>
<b>Класс TRowset</b><br>
Представляет объекты - наборы записей.<br>
<hr><br>
 Набор записей - это совокупность записей, выбранных из базы данных
 посредством SQL-оператора SELECT. Хранилищем набора записей является
 оперативная память хоста, на котором работает приложение Клиппера,
 в отличие от таблиц базы данных, хранящихся на сервере. Методы объекта
 TRowset для манипулирования набором записей напрямую не воздействуют на
 таблицы базы данных. Но, как будет показано ниже, существует механизм,
 позволяющий отражать все изменения набора записей в базе данных.
<br> <br>
 Класс TRowset предоставляет интерфейс для навигации по записям, доступа
 к полям текущей записи, удаления, добавления записей.
 Конструктором объекта класса TRowset является метод класса TConnect
 CreateRowset(). То есть для работы с набором записей необходимо вначале
 создать подключение к базе данных.
<br> <br>
 Все изменения набора записей (такие как изменение значений полей, удаление
 и добавление записи) могут автоматически отражаться в базе данных. Для
 этого конструктору TConnect:CreateRowset() помимо оператора SELECT,
 использующегося для выборки необходимых записей из базы данных, необходимо
 передать операторы INSERT, DELETE ... WHERE и UPDATE ... WHERE. В дальнейшем
 эти операторы будут использоваться для автоматического отражения изменений
 в базе данных. Параметры операторов связываются автоматически в соответствии
 с именами полей.
<br> <br>
 Например, оператор для отражения в базе данных добавления новой записи к набору
 может выглядеть следующим образом:
<br> <br>
<b>INSERT INTO mytable (fname,lname) VALUES (:fname,:lname)</b>
<br> <br>
 Здесь, при связывании параметры <b>:fname</b> и <b>:lname</b> примут
 текущие значения соответствующих им полей <b>fname</b> и <b>lname</b>
 текущей записи набора.
<br> <br>
 Оператор для отражения в базе данных изменений текущей записи в наборе может
 выглядеть так:
<br> <br>
<b>UPDATE mytable SET fname=:fname,lname=:lname WHERE ...</b>
<br> <br>
 Здесь, условие <b>WHERE</b> должно идентифицировать конкретную запись базы
 данных, подлежащую изменению (если не будет условия WHERE про'UPDATE'тятся
 все записи таблицы <b>mytable</b>). Каким же образом идентифицировать запись
 базы данных, подлежащую UPDATE'у или DELETE'у? Ответ на этот вопрос зависит
 от используемой базы данных. Обратитесь за ним к соответствующим разделам
 помощи. Рассмотрим далее только самый "правильный" случай, используемый в
 таких базах данных как Postgres и Oracle. Эти базы данных
 для каждой записи таблицы хранят уникальное значение, однозначно
 идентифицирующее зту запись. Обратите внимание, эти значения не имеют ничего
 общего с понятием первичного ключа, для формирования этих уникальных значений
 не нужно писать никаких триггеров, и они не являются собственно полями таблицы
 (в том смысле что их не указывают в операторе CREATE TABLE ... и их нельзя
 получить оператором SELECT * FROM ...). Тем не менее они существуют и
 доступны при явном упоминании их в SELECT'е. В Postgres это поле называется
 <b>oid</b>, в Oracle - <b>rowid</b>.
<br> <br>
 Например, для выбора записей из таблицы <b>mytable</b> базы данных Postgres
 нужно явно перечислить все необходимые поля:
<br> <br>
<b>SELECT oid,fname,lname FROM mytable</b>
<br> <br>
 Теперь набор записей содержит поле <b>oid</b>, позволяющее однозначно
 ссылаться на нужную запись базы данных.
<br> <br>
 Для удобства записи операторов отображения могут использоваться макросы
 <b>%LIST</b>, <b>%FIELDS</b>, <b>%VALUES</b>.
<br> <br>
 Макрос %LIST расширяется в последовательность присваивани	й вида
 <b>fieldname1=:fieldname1, fieldname2=:fieldname2, ...</b>.
<br> <br>
 Макрос %FIELDS расширяется в последовательность имен полей вида
 <b>fieldname1, fieldname2, ...</b>.
<br> <br>
 Макрос %VALUES расширяется в последовательность имен параметров SQL вида
 <b>:fieldname1, :fieldname2, ...</b>.
<br> <br>
 Подробнее об использовании макросов, смотрите описание операторов отображения
 insertSQL, updateSQL.
<br> <br>
 Итак, приведем пример конструктора набора записей из таблицы базы данных
 Postgres:
<pre>
// Производим подключение к базе данных
conn := ConnectNew("PG",,,,,"mydb")
// Создаем объект класса TRowset, представляющий все записи
// таблицы mytable
rs := conn:CreateRowset("SELECT oid,fname,lname FROM mytable",NIL,;
   "INSERT INTO mytable (%FIELDS) VALUES (%VALUES)",;
   "DELETE FROM mytable WHERE oid=:oid",;
   "UPDATE mytable SET %LIST WHERE oid=:oid")
</pre>
 Следующий пример выводит на экран все записи вышеуказанного набора:
<pre>
DO WHILE !rs:Eof()
   data := rs:Read()
   ? data:oid,data:fname,data:lname
   rs:Skip()
ENDDO
</pre>
<hr>
См. также:
<a href="#tconnect" > Класс TConnect</a><br>
<hr>
<a name="insertsql"></a>
<b>insertSQL</b><br>
 Содержит SQL-оператор INSERT, необходимый для отражения изменений набора
 записей в базе данных.<br>
<hr>
 insertSQL инициализируется конструктором TConnect:CreateRowset. Этот оператор
 на языке SQL используется для отражения добавления записи в базе данных.
 Оператор выполняется неявно классом TRowset при выполнении метода Append().
<br> <br>
 В случае если insertSQL == NIL, отражение добавления записи в базе данных
 не производится. То есть добавленные записи будут только в наборе записей,
 но не в таблицах базы данных.
<br> <br>
 Пример:
<pre>
 INSERT INTO mytable (fname,lname) VALUES (:fname,:lname)
</pre>
 В ординарных ситуациях Ваш insertSQL должен иметь точно такой же вид, за
 исключением имен полей и параметров.
<br> <br>
 Для удобства написания оператора могут использоваться макросы %FIELDS и
 %VALUES. Например, вышеприведенный пример может быть записан так:
<pre>
 INSERT INTO mytable (%FIELDS) VALUES (%VALUES)
</pre>
 Записанный таким образом insertSQL гораздо гибче, так как INSERT INTO
 проинициализирует лишь поля, присутствующие в массиве,
 переданном методу Append(). Но в этом случае методу Append() нельзя
 передавать пустой массив, то есть невозможно будет добавить пустую запись.<br>
<hr>
<b>См. также:</b>
<a href="#append">[ Append() ]</a>
<a href="#trowsetov">[ Обзор TRowset ]</a><br>
<hr>
<a name="deletesql"></a>
<b>deleteSQL</b><br>
 Содержит SQL-оператор DELETE ... WHERE, необходимый для отражения
 изменений набора записей в базе данных.<br>
<hr>
 deleteSQL инициализируется конструктором TConnect:CreateRowset. Этот оператор
 на языке SQL используется для отражения удаления записи в базе данных.
 Оператор выполняется неявно классом TRowset при выполнении метода Delete().
 Об особенностях использования механизма отражения удаления записи в базе
 данных конкретной СУБД, смотрите соответствующий раздел документации.
<br> <br>
 В случае если deleteSQL == NIL, отражение удаления записи в базе данных
 не производится. То есть записи будут удаляться только в наборе записей,
 но не в таблицах базы данных.
<br> <br>
 Пример для СУБД Postgres:
<pre>
DELETE FROM mytable WHERE oid=:oid
</pre>
 Пример для СУБД Oracle:
<pre>
DELETE FROM mytable WHERE rowid=:rowid
</pre>
 В ординарных ситуациях Ваш deleteSQL должен иметь точно такой же вид, за
 исключением имени таблицы.<br>
<hr>
<b>См. также:</b>
<a href="#delete">[ Delete() ]</a>
<a href="#trowsetov">[ Обзор TRowset ]</a><br>
<hr>
<a name="updatesql"></a>
<b>updateSQL</b><br>
 Содержит SQL-оператор UPDATE ... WHERE, необходимый для отражения
 изменений набора записей в базе данных.<br>
<hr>
 updateSQL инициализируется конструктором TConnect:CreateRowset. Этот оператор
 на языке SQL используется для отражения изменения записи в базе данных.
 Оператор выполняется неявно классом TRowset при выполнении метода Write().
<br> <br>
 Об особенностях использования механизма отражения изменения записи в базе
 данных конкретной СУБД смотрите соответствующий раздел документации.
<br> <br>
 В случае если updateSQL == NIL, отражение изменения записи в базе данных
 не производится. То есть записи будут изменены только в наборе записей,
 но не в таблицах базы данных.
<br> <br>
 Пример для СУБД Postgres:
<pre>
UPDATE mytable SET fname=:fname,lname=:lname WHERE oid=:oid
</pre>
 Пример для СУБД Oracle:
<pre>
UPDATE mytable SET fname=:fname,lname=:lname WHERE rowid=:rowid
</pre>
 В ординарных ситуациях Ваш updateSQL должен иметь точно такой же вид, за
 исключением имен таблицы, полей и параметров.
<br> <br>
 Для удобства написания оператора может использоваться макрос %LIST.
 Например, вышеприведенный пример может быть записан так:
<pre>
UPDATE mytable SET %LIST WHERE rowid=:rowid
</pre>
 Записанный таким образом updateSQL гораздо гибче, так как UPDATE
 присвоит новые значения лишь полям, присутствующим в массиве,
 переданном методу Write(). Но в этом случае методу Write() нельзя
 передавать пустой массив, то есть невозможно будет обнулить запись.<br>
<hr>
<b>См. также:</b>
<a href="#trowsetov">[ Обзор TRowset ]</a><br>
<hr>
<a name="refreshsql"></a>
<b>refreshSQL</b><br>
 Содержит SQL-оператор SELECT ... FROM ... WHERE, необходимый для отражения
 изменений базы данных в наборе записей.<br>
<hr>
 refreshSQL инициализируется конструктором TConnect:CreateRowset. Этот оператор
 на языке SQL используется для обновления текущей записи набора данными
 соответствующей записи базы данных.
 Оператор может содержать лишь параметры с именами синтаксически равными
 именам полей набора записей. Оператор выполняется неявно классом TRowset
 при выполнении метода refreshCurrent(). TRowset сам связывает SQL-параметры со
 значениями полей набора.
<br> <br>
 Об особенностях использования механизма отражения изменения записи в базе
 данных конкретной СУБД смотрите соответствующий раздел документации.
<br> <br>
 В случае если refreshSQL == NIL, обновление записи не производится.
<br> <br>
 Пример для СУБД Postgres:
<pre>
SELECT fname,lname FROM mytable WHERE oid=:oid
</pre>
 Пример для СУБД Oracle:
<pre>
SELECT fname,lname FROM mytable WHERE rowid=:rowid
</pre>
 В ординарных ситуациях Ваш updateSQL должен иметь точно такой же вид, за
 исключением имен таблицы, полей и параметров.
<br> <br>
<hr>
<b>См. также:</b>
<a href="#createrowset">[ CreateRowset() ]</a>
<a href="#refreshcurrent">[ RefreshCurrent() ]</a>
<br>
<hr>
<a name="bof"></a>
<b>Bof()</b><br>
Определяет достижение начала набора записей.<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	Bof() --> признак начала набора
<br> <br>
<b>Возвращаемое значение</b>
<br> <br>
	Bof() возвращает .T. после того как была предпринята попытка
	перемещения указателя в обратном направлении за первую запись набора.
	Если в наборе нет ни одной записи, Bof() возвращает .T.
<br> <br>
	В других случаях Bof() возвращает .F.
<br> <br>
<b>Описание</b>
<br> <br>
	Bof() используется для проверки условия достижения границ набора записей
	при перемещении указателя записи в обратном направлении при помощи метода
	Skip().    После   того,   как   признак   начала   установился,   он
		остается до тех пор, пока не будет очередного перемещения указателя.
<br> <br>
<b>Пример</b>
<br> <br>
	Следующий фрагмент печатает записи в обратном порядке:
<pre><b>
rs := conn:CreateRowset("SELECT * FROM mytable")
rs:GoBottom()
DO WHILE !rs:Bof()
   data := rs:Read()
   ? data:fname,data:lname
   rs:Skip(-1)
ENDDO
</b></pre>
<hr>
<b>См. также:</b>
<a href="#eof">[ Eof() ]</a>
<a href="#skip">[ Skip() ]</a><br>
<hr>
<a name="eof"></a>
<b>Eof()</b><br>
Определяет выход за последнюю запись набора записей.<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	Eof() --> признак конца набора
<br> <br>
<b>Возвращаемое значение</b>
<br> <br>
	Eof() возвращает .T. при попытке	переместить указатель за
	последнюю запись набора.
<br> <br>
	Если в наборе нет ни одной записи, Eof() возвращает .T.
<br> <br>
	В других случаях Eof() возвращает .F.
<br> <br>
<b>Описание</b>
<br> <br>
	Eof() используется для проверки условия достижения границ набора записей
	при перемещении указателя записи при помощи метода Skip(). После того,
	как признак конца установился, он остается до тех пор, пока не будет
	очередного перемещения указателя.
<br> <br>
<b>Пример</b>
<br> <br>
	Следующий фрагмент печатает все записи набора:
<pre><b>
rs := conn:CreateRowset("SELECT * FROM mytable")
DO WHILE !rs:Eof()
   data := rs:Read()
   ? data:fname,data:lname
   rs:Skip()
ENDDO
</b></pre>
<hr>
<b>См. также:</b>
<a href="#bof">[ Bof() ]</a>
<a href="#skip">[ Skip() ]</a><br>
<hr>
<a name="recno"></a>
<b>Recno()</b><br>
Возвращает номер текущей записи.<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	Recno() --> номер записи
<br> <br>
<b>Возвращаемое значение</b>
<br> <br>
	Recno() возвращает номер текущей записи в наборе. Если в наборе	нет
	ни одной записи, Recno() возвращает 0.
<br> <br>
<b>Описание</b>
<br> <br>
	Recno() используется для определения номера текущей записи в наборе.
<br> <br>
<b>Пример</b>
<pre>
<b>   ? rs:Recno()</b>
</pre>
<hr>
<a name="lastrec"></a>
<b>Lastrec()</b><br>
Возвращает количество записей в наборе.<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	Lastrec() --> количество записей
<br> <br>
<b>Возвращаемое значение</b>
<br> <br>
	Lastrec() возвращает количество записей в наборе. Если в наборе нет
	ни одной записи, Lastrec() возвращает 0.
<br> <br>
<b>Описание</b>
<br> <br>
	Lastrec() используется для определения количества записей в наборе.
<br> <br>
<b>Пример</b>
<pre>
<b>   ? rs:Lastrec()</b>
</pre>
<hr>
<a name="nfields"></a>
<b>NFields()</b><br>
Возвращает количество полей в записи набора.<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	NFields() --> количество полей
<br> <br>
<b>Возвращаемое значение</b>
<br> <br>
	NFields() возвращает количество полей в записи набора.
<br> <br>
<b>Описание</b>
<br> <br>
	NFields() используется для определения количества полей в записи набора.
<br> <br>
<b>Пример</b>
<pre>
<b>   ? rs:NFields()</b>
</pre>
<hr>
<a name="fieldno"></a>
<b>FieldNo()</b><br>
Возвращает порядковый номер поля по его имени.<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	FieldNo(&lt;fieldname&gt;) --> номер поля
<br> <br>
<b>Аргументы</b>
<br> <br>
	&lt;fieldname&gt; - имя поля.
<br> <br>
<b>Возвращаемое значение</b>
<br> <br>
	FieldNo() возвращает порядковый номер поля с именем &lt;fieldname&gt;.
<br> <br>
<b>Описание</b>
<br> <br>
	FieldNo() используется для определения порядкого номера поля с именем
	&lt;fieldname&gt;.
<br> <br>
<b>Пример</b>
<pre>
<b>   ? rs:FieldNo("fname")</b>
</pre>
<hr>
<b>См. также:</b>
<a href="#fieldname">[ FieldName() ]</a><br>
<hr>
<a name="fieldname"></a>
<b>FieldName()</b><br>
Возвращает имя поля по его порядковому номеру.<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	FieldName(&lt;fieldno&gt;) --> имя поля
<br> <br>
<b>Аргументы</b>
<br> <br>
	&lt;fieldno&gt; - номер поля.
<br> <br>
<b>Возвращаемое значение</b>
<br> <br>
	FieldName() возвращает имя поля с порядковым номером &lt;fieldno&gt;.
<br> <br>
<b>Описание</b>
<br> <br>
	FieldName() используется для определения имени поля с порядковым номером
	&lt;fieldno&gt;.
<br> <br>
<b>Пример</b>
<pre>
<b>   ? rs:FieldName(3)</b>
</pre>
<hr>
<b>См. также:</b>
<a href="#fieldno">[ FieldNo() ]</a><br>
<hr>
<a name="fieldtype"></a>
<b>FieldType()</b><br>
Возвращает тип поля по его порядковому номеру.<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	FieldType(&lt;fieldno&gt;) --> тип поля
<br> <br>
<b>Аргументы</b>
<br> <br>
	&lt;fieldno&gt; - номер поля.
<br> <br>
<b>Возвращаемое значение</b>
<br> <br>
	FieldType() возвращает тип поля с порядковым номером &lt;fieldno&gt;.
<br> <br>
<b>Описание</b>
<br> <br>
	FieldType() используется для определения типа поля в терминах используемой
	СУБД, а не Клиппера. Возвращаемое значение представляет собой 4-х байтовое
	целое, а не один символ, как в функции Клиппер VALTYPE(). Реализации
	DBFSQL для разных СУБД комплектуются соответствующими заголовочными (.CH)
	файлами, содержащими символические имена типов используемой СУБД.
<br> <br>
<b>Пример</b>
<pre>
<b>   ? rs:FieldType(3)</b>
</pre>
<hr>
<b>См. также:</b>
<a href="#fieldname">[ FieldName() ]</a><br>
<hr>
<a name="fieldlen"></a>
<b>FieldLen()</b><br>
Возвращает длину поля по его порядковому номеру.<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	FieldLen(&lt;fieldno&gt;) --> длина поля
<br> <br>
<b>Аргументы</b>
<br> <br>
	&lt;fieldno&gt; - номер поля.
<br> <br>
<b>Возвращаемое значение</b>
<br> <br>
	FieldLen() возвращает длину поля с порядковым номером &lt;fieldno&gt;.
<br> <br>
<b>Описание</b>
<br> <br>
	FieldLen() используется для определения длины поля в терминах используемой
	СУБД, а не Клиппера. Например, для поля типа float8 таблицы Postgres
	FieldLen() вернет 8, для float4 - 4.
<br> <br>
<b>Пример</b>
<pre>
<b>   ? rs:FieldLen(3)</b>
</pre>
<hr>
<b>См. также:</b>
<a href="#fieldname">[ FieldName() ]</a><br>
<hr>
<a name="fieldnullable"></a>
<b>FieldNullable()</b><br>
Определяет, может ли принимать поле значения NULL.<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	FieldNullable(&lt;fieldno&gt;) --> .T. - если может принимать значения NULL
<br> <br>
<b>Аргументы</b>
<br> <br>
	&lt;fieldno&gt; - номер поля.
<br> <br>
<b>Возвращаемое значение</b>
<br> <br>
	FieldNullable() возвращает .T., если поле с порядковым номером &lt;fieldno&gt;
	может принимать значения NULL. В противном случае возвращается .F.
<br> <br>
<b>Описание</b>
<br> <br>
	FieldNullable() используется для определения признака поля NOT NULL.
	Если поле имеет этот признак, возвращается .F. (поле не может принимать
	значения NULL), в противном случае - .T.
<br> <br>
<b>Пример</b>
<pre>
<b>   ? rs:FieldNullable(3)</b>
</pre>
<hr>
<b>См. также:</b>
<a href="#fieldname">[ FieldName() ]</a><br>
<hr>
<a name="fieldunsigned"></a>
<b>FieldUnsigned()</b><br>
Определяет, может ли принимать поле отрицательные значения.<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	FieldUnsigned(&lt;fieldno&gt;) --> .T. - если не может принимать
	отрицательные значения
<br> <br>
<b>Аргументы</b>
<br> <br>
	&lt;fieldno&gt; - номер поля.
<br> <br>
<b>Возвращаемое значение</b>
<br> <br>
	FieldUnsigned() возвращает .T., если поле с порядковым номером &lt;fieldno&gt;
	является беззнаковым. В противном случае возвращается .F.
<br> <br>
<b>Описание</b>
<br> <br>
	FieldUnsigned() используется для определения признака поля UNSIGNED.
	Если поле имеет этот признак, возвращается .T. (поле не может принимать
	отрицательные значения), в противном случае - .F.
<br> <br>
<b>Пример</b>
<pre>
<b>   ? rs:FieldUnsigned(3)</b>
</pre>
<hr>
<b>См. также:</b>
<a href="#fieldname">[ FieldName() ]</a><br>
<hr>
<a name="fieldbinary"></a>
<b>FieldBinary()</b><br>
Определяет, является ли поле бинарным.<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	FieldBinary(&lt;fieldno&gt;) --> .T. - если поле бинарное
<br> <br>
<b>Аргументы</b>
<br> <br>
	&lt;fieldno&gt; - номер поля.
<br> <br>
<b>Возвращаемое значение</b>
<br> <br>
	FieldBinary() возвращает .T., если поле с порядковым номером &lt;fieldno&gt;
	является бинарным. В противном случае возвращается .F.
<br> <br>
<b>Описание</b>
<br> <br>
	FieldBinary() используется для определения, является ли поле бинарным.
<br> <br>
<b>Пример</b>
<pre>
<b>   ? rs:FieldBinary(3)</b>
</pre>
<hr>
<b>См. также:</b>
<a href="#fieldname">[ FieldName() ]</a><br>
<hr>
<a name="getvalue"></a>
<b>GetValue()</b><br>
Возвращает значение поля по его порядковому номеру.<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	GetValue(&lt;fieldno|fieldname&gt;) --> значение поля
<br> <br>
<b>Аргументы</b>
<br> <br>
	&lt;fieldno&gt; - номер поля.
<br> <br>
	&lt;fieldname&gt; - имя поля.
<br> <br>
<b>Возвращаемое значение</b>
<br> <br>
	GetValue() возвращает значение поля с порядковым номером &lt;fieldno&gt;
	или с именем &lt;fieldname&gt;
<br> <br>
<b>Описание</b>
<br> <br>
	GetValue() не обращается к серверу.<br>
	Типы RDBMS преобразуются к типам Clipper. См. таблицу "Реализованные типы"
	в описании особенностей реализации конкретной RDBMS.
<br> <br>
<b>Пример</b>
<pre>
<b>   ? rs:GetValue(3)</b>
</pre>
<hr>
<b>См. также:</b>
<a href="#setvalue">[ SetValue() ]</a><br>
<hr>
<a name="setvalue"></a>
<b>SetValue()</b><br>
Устанавливает значение поля с указанным порядковым номером.<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	SetValue(&lt;fieldno|fieldname&gt;,&lt;value&gt;) --> NIL
<br> <br>
<b>Аргументы</b>
<br> <br>
	&lt;fieldno&gt; - номер поля.
<br> <br>
	&lt;fieldname&gt; - имя поля.
<br> <br>
	&lt;value&gt; - значение.
<br> <br>
<b>Описание</b>
<br> <br>
	SetValue() не обращается к серверу. Для автоматического отображения изменений
	в базе данных используйте метод TRowset:Write().<br>
	Типы RDBMS преобразуются к типам Clipper. См. таблицу "Реализованные типы"
	в описании особенностей реализации конкретной RDBMS.
<br> <br>
<b>Пример</b>
<pre>
<b>
? rs:SetValue(3,"Вася")
? rs:SetValue(4,"Пупкин")
rs:Write(rs:Read()) // выполнить updateSQL (если задан) на сервере
</b>
</pre>
<hr>
<b>См. также:</b>
<a href="#getvalue">[ GetValue() ]</a><br>
<hr>
<a name="append"></a>
<b>Append()</b><br>
Добавляет запись к набору записей.<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	Append(&lt;data&gt;) --> NIL
<br> <br>
<b>Аргументы</b>
<br> <br>
	&lt;data&gt; - ассоциативный массив со значениями полей. Если
	ни один злемент &lt;data&gt; не соответствует именам полей набора,
	добавляется пустая запись.
<br> <br>
<b>Описание</b>
<br> <br>
	Append() добавляет новую запись к набору. Поля новой записи инициализируются
	значениями из массива &lt;data&gt;. Кроме того, производится попытка
	автоматического отражения при помощи оператора insertSQL.
<br> <br>
	В случае, если в операторе insertSQL используются макросы %FIELDS и %VALUES,
	добавление пустой записи запрещено (хотя бы один злемент &lt;data&gt;
	должен иметь имя одного из полей набора).
<br> <br>
	Указатель записи в наборе перемещается на зту новую пустую запись.
	Значение Lastrec() при этом увеличивается на 1. BOF() и EOF() сбрасываются
	в .F.
<br> <br>
<b>Пример</b>
<br> <br>
	В данном примере создается набор записей из таблицы <b>mytable</b>,
	с возможностью добавления записей в базу данных. Создается массив
	&lt;data&gt; соответствующий полям набора, и добавляется новая запись.
	При этом на сервере выполняется оператор<br>
	"INSERT INTO mytable (fname,lname) VALUES (:fname,:lname)",<br>
	со значениями параметров :fname="John" и :lname="Smith".
<pre>
<b>
rs := conn:CreateRowset("SELECT fname,lname FROM mytable",NIL,;
	  "INSERT INTO mytable (%FIELDS) VALUES (%VALUES)")
data := map()
data:fname := "John"
data:lname := "Smith"
rs:Append(data)
</b>
</pre>
<hr>
<b>См. также:</b>
<a href="#insertsql">[ insertSQL ]</a>
<a href="#trowsetov">[ Обзор TRowset ]</a><br>
<hr>
<a name="delete"></a>
<b>Delete()</b><br>
Удаляет текущую запись.<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	Delete() --> NIL
<br> <br>
<b>Описание</b>
<br> <br>
	Delete() удаляет текущую запись в наборе. Кроме того, производится попытка
	автоматического отражения удаления в базе данных при помощи оператора
	deleteSQL.
<br> <br>
	Если удаляется не последняя запись в наборе, Recno() не изменяется.
	Если удаляется последняя запись в наборе, Recno() уменьшается на единицу.
<br> <br>
	Если удаляется единственная запись в наборе, BOF() и EOF() устанавливаются
	в .T., в противном случае BOF() и EOF() сбрасываются в .F.
<br> <br>
<b>Пример</b>
<br> <br>
	В данном примере создается набор записей из таблицы <b>mytable</b>
	базы данных Postgres с возможностью удаления записей в базе данных.
	Удаляется запись в наборе, при этом на сервере выполняется оператор
<pre>
DELETE FROM mytable WHERE oid=:oid
</pre>
	со значением параметра :oid равным значению поля oid текущей записи
	в наборе.
<pre>
<b>
rs := conn:CreateRowset("SELECT oid,fname,lname FROM mytable",NIL,NIL,;
	  "DELETE FROM mytable WHERE oid=:oid")
rs:Delete()
</b>
</pre>
<hr>
<b>См. также:</b>
<a href="#deletesql">[ deleteSQL ]</a>
<a href="#trowsetov">[ Обзор TRowset ]</a><br>
<hr>
<a name="read"></a>
<b>Read()</b><br>
Возвращает значения полей текущей записи.<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	Read() -> ассоциативный массив со значениями полей текущей записи.
<br> <br>
<b>Возвращаемое значение</b>
<br> <br>
	Read() возвращает массив со значениями полей.
<br> <br>
<b>Описание</b>
<br> <br>
	Read() возвращает ассоциативный массив структуры, соответствующей
	структуре записи, содержащий значения всех полей записи.
<br> <br>
<b>Пример</b>
<br> <br>
	В данном примере создается набор записей из таблицы <b>mytable</b>
	и выводятся на зкран все записи набора.
<pre>
<b>
rs := conn:CreateRowset("SELECT fname,lname FROM mytable")
DO WHILE !rs:Eof()
   data := rs:Read()
   ? data:fname,data:lname
   rs:Skip()
ENDDO
</b>
</pre>
<hr>
<b>См. также:</b>
<a href="#write"> [ Write() ]</a>
<a href="#trowsetov">[ Обзор TRowset ]</a><br>
<hr>
<a name="write"></a>
<b>Write()</b><br>
Устанавливает значения полей текущей записи.<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	Write(&lt;data&gt;) --> NIL
<br> <br>
<b>Аргументы</b>
<br> <br>
	&lt;data&gt; - ассоциативный массив со значениями полей. Если
	ни один злемент &lt;data&gt; не соответствует именам полей набора,
	запись обнуляется.
<br> <br>
<b>Описание</b>
<br> <br>
	Write() изменяет значения полей текущей записи. Полям записи
	присваиваются значения из массива &lt;data&gt;. Кроме того,
	производится попытка автоматического отражения изменения в базе данных
	при помощи оператора updateSQL.
<br> <br>
	В случае, если в операторе updateSQL используется макрос %LIST,
	обнуление записи запрещено (хотя бы один злемент &lt;data&gt;
	должен иметь имя одного из полей набора).
<br> <br>
<b>Пример</b>
<br> <br>
	В данном примере создается набор записей из таблицы <b>mytable</b>
	базы данных Postgres с возможностью изменения записей в базе данных.
	Создается массив &lt;data&gt; соответствующий полям набора и
	текущая запись устанавливается значениями из этого массива.
	При этом на сервере выполняется оператор<br>
	"UPDATE mytable SET fname=:fname WHERE oid=:oid",<br>
	со значением параметра :fname="John".
<pre>
<b>
rs := conn:CreateRowset("SELECT fname,lname FROM mytable",NIL,NIL,NIL,;
	  "UPDATE mytable SET %LIST WHERE oid=:oid")
data := map()
data:fname := "John"
rs:Write(data)
</b>
</pre>
<hr>
<b>См. также:</b>
<a href="#read"> [ Read() ]</a>
<a href="#updatesql">[ updateSQL ]</a>
<a href="#trowsetov">[ Обзор TRowset ]</a><br>
<hr>
<a name="gotop"></a>
<b>GoTop()</b><br>
Перемещает указатель на первую запись.<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	GoTop() --> NIL
<br> <br>
<b>Описание</b>
<br> <br>
	Если в наборе нет ни одной записи, функция ничего не делает. В противном
	случае RecNo() возвращает 1, BOF() и EOF() сбрасываются в .F.
<br> <br>
<b>Пример</b>
<pre>
<b>
rs := conn:CreateRowset("SELECT * FROM mytable")
...
rs:GoTop()
</b>
</pre>
<hr>
<b>См. также:</b>
<a href="#trowsetov">[ Обзор TRowset ]</a>
<a href="#skip">[ Skip() ]</a>
<a href="#gobottom">[ GoBottom() ]</a><br>
<hr>
<a name="gobottom"></a>
<b>GoBottom()</b><br>
Перемещает указатель на последнюю запись.<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	GoBottom() --> NIL
<br> <br>
<b>Описание</b>
<br> <br>
	Если в наборе нет ни одной записи, функция ничего не делает. В противном
	случае RecNo() возвращает значение равное Lastrec(), BOF() и EOF()
	сбрасываются в .F.
<br> <br>
<b>Пример</b>
<pre>
<b>
rs := conn:CreateRowset("SELECT * FROM mytable")
rs:GoBottom()
</b>
</pre>
<hr>
<b>См. также:</b>
<a href="#trowsetov">[ Обзор TRowset ]</a>
<a href="#skip">[ Skip() ]</a>
<a href="#gotop">[ GoTop() ]</a><br>
<hr>
<a name="skip"></a>
<b>Skip()</b><br>
Перемещает указатель относительно текущей записи.<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	Skip(&lt;rows&gt;) --> число записей
<br> <br>
<b>Аргументы</b>
<br> <br>
	&lt;rows&gt; - число записей, на которое должен переместиться указатель
	относительно текущей записи. Если &lt;rows&gt; &lt; 0 перемещение производится
	в обратном направлении, если &lt;rows&gt;==0 перемещение не производится,
	если &lt;rows&gt; &gt; 0 перемещение производится в прямом направлении.
<br> <br>
	Если аргумент опущен, производится перемещение на одну запись в прямом
	направлении.
<br> <br>
<b>Возвращаемое значение</b>
<br> <br>
	Skip() возвращает число записей, на которое в действительности переместился
	указатель.
<br> <br>
<b>Описание</b>
<br> <br>
	Skip() перемещает указатель на &lt;rows&gt; записей в прямом или обратном
	направлении. Если предпринята попытка переместиться за пределы набора,
	ABS(&lt;rows&gt;) < ABS(Skip(&lt;rows&gt;)), и устанавливается в .T.
	BOF() или EOF().
<br> <br>
<b>Пример</b>
<pre>
<b>
rs := conn:CreateRowset("SELECT * FROM mytable")
DO WHILE !rs:EOF()
   data := rs:Read()
   ? data:fname,data:lname
   rs:Skip()
ENDDO
</b>
</pre>
<hr>
<b>См. также:</b>
<a href="#trowsetov">[ Обзор TRowset ]</a>
<a href="#bof">[ Bof() ]</a>
<a href="#eof">[ Eof() ]</a><br>
<hr>
<a name="goto"></a>
<b>Goto()</b><br>
Перемещает указатель на запись с заданным номером.<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	Goto(&lt;row&gt;) --> номер записи
<br> <br>
<b>Аргументы</b>
<br> <br>
	&lt;row&gt; - номер записи, на которую должен переместиться указатель.
<br> <br>
<b>Возвращаемое значение</b>
<br> <br>
	Goto() возвращает номер записи, на которую переместился указатель.
<br> <br>
<b>Описание</b>
<br> <br>
	Goto() перемещает указатель на запись с номером &lt;row&gt;.
	Если &lt;row&gt; == 0 никаких действий не производится.	Если
	&lt;row&gt; &gt; Lastrec(), EOF() устанавливается в .T. и возвращается
	Lastrec(). Если &lt;row&gt; &lt; 1, BOF() устанавливается в .T. и
	возвращается 1. В остальных случаях BOF() и EOF() сбрасываются в .F.
	и возвращается &lt;row&gt;.
<br> <br>
	Перед перемещением указателя Goto() также инициирует отражение изменений
	текущей записи в базе данных.
<br> <br>
<b>Пример</b>
<pre>
<b>
rs := conn:CreateRowset("SELECT * FROM mytable")
FOR I:=1 TO rs:Lastrec()
   rs:Goto(I)
   data := rs:Read()
   ? data:fname,data:lname
NEXT
</b>
</pre>
<hr>
<b>См. также:</b>
<a href="#trowsetov">[ Обзор TRowset ]</a>
<a href="#recno">[ Recno() ]</a>
<a href="#lastrec">[ Lastrec() ]</a><br>
<hr>
<a name="createorder"></a>
<b>CreateOrder()</b><br>
Создает локальный индекс (ордер).<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	CreateOrder(&lt;order_name&gt;,&lt;expr&gt;[,&lt;key_len&gt;]) --> NIL
<br> <br>
<b>Аргументы</b>
<br> <br>
	&lt;order_name&gt; - имя создаваемого ордера
<br> <br>
	&lt;expr&gt; - индексное выражение
<br> <br>
	&lt;key_len&gt; - длина ключа (только для символьных ключей)
<br> <br>
<b>Описание</b>
<br> <br>
	CreateOrder() создает локальный индекс (ордер). Для переключения
	режима навигации по определенному ордеру используйте функцию
	TRowset:SetOrder(). Для поиска по ордеру используйте функцию
	TRowset:Seek().
<br> <br>
<b>Пример</b>
<pre>
<b>
rs:CreateOrder("fname","fname",20)
rs:CreateOrder("name",{|rs| rs:GetValue("first")+rs:GetValue("last")},20)
</b>
</pre>
<hr>
<b>См. также:</b>
<a href="#setorder">[ SetOrder() ]</a>
<a href="#seek">[ Seek() ]</a>
<a href="#createrowset">[ CreateRowset() ]</a>
<br>
<hr>
<a name="setorder"></a>
<b>SetOrder()</b><br>
Устанавливает/возвращает активный локальный индекс (ордер).<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	SetOrder([&lt;order_name&gt;]) --> имя активного ордера
<br> <br>
<b>Аргументы</b>
<br> <br>
	&lt;order_name&gt; - имя ордера
<br> <br>
<b>Возвращаемое значение</b>
<br> <br>
	SetOrder() возвращает имя текущего активного ордера, или NIL,
	если такового нет.
<br> <br>
<b>Описание</b>
<br> <br>
	Функция SetOrder() устанавливает режим навигации в соответствии
	с порядком ключей устанавливаемого активного ордера и возвращает
	имя ордера, бывшего активным до вызова функции, или NIL.
<br> <br>
	Если функция вызывается без параметров, функция лишь возвращает
	имя текущего актвного ордера. Чтобы отключить активный ордер
	(перевести режим навигации в натуральном порядке) передайте
	пустую строку ("").
<br> <br>
<b>Пример</b>
<pre>
<b>
rs:CreateOrder("fname","fname",20)
rs:CreateOrder("lname","lname",20)
rs:SetOrder("fname")
rs:Browse() // записи отсортированы по имени
rs:SetOrder("lname")
rs:Browse() // записи отсортированы по фамилии
</b>
</pre>
<hr>
<b>См. также:</b>
<a href="#createorder">[ SetOrder() ]</a>
<a href="#seek">[ Seek() ]</a>
<a href="#createrowset">[ CreateRowset() ]</a>
<br>
<hr>
<a name="seek"></a>
<b>Seek()</b><br>
Быстрый поиск по активному локальному индексу (ордеру).<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	Seek(&lt;value&gt;,[&lt;lSoft&gt;]) --> признак нахождения
<br> <br>
<b>Аргументы</b>
<br> <br>
	&lt;value&gt; - значение для поиска
<br> <br>
	&lt;lSoft&gt; - признак "мягкого" поиска
<br> <br>
<b>Возвращаемое значение</b>
<br> <br>
	Seek() возвращает .T., если запись с искомым значением ключа найдена,
	и .F. в противном случае.
<br> <br>
<b>Описание</b>
<br> <br>
	Функция Seek() ищет запись со значением ключа активного ордера, равного
	&lt;value&gt; и, если такая запись найдена, устанавливает указатель на эту
	запись.
<br> <br>
	Логический параметр &lt;lSoft&gt; влияет на режим поиска:
	если передано .T. и запись не найдена, указатель текущей записи
	становится на записи с ближайшим большим значением ключа. Если передано
	.F. и запись не найдена, указатель текущей записи не меняется.
<br> <br>
<b>Пример</b>
<pre>
<b>
rs:CreateOrder("fname","fname",20)
rs:SetOrder("fname")
rs:Seek("Вася")
</b>
</pre>
<hr>
<b>См. также:</b>
<a href="#createorder">[ SetOrder() ]</a>
<a href="#setorder">[ Seek() ]</a>
<a href="#createrowset">[ CreateRowset() ]</a>
<br>
<hr>
<a name="fieldblock"></a>
<b>FieldBlock()</b><br>
Возвращает блок кода для доступа к полю набора записей.<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	FieldBlock(&lt;fieldno&gt;) --> блок кода для доступа к полю
<br> <br>
<b>Аргументы</b>
<br> <br>
	&lt;fieldno&gt; - порядковый номер поля, блок кода для доступа
	к которому требуется получить.
<br> <br>
<b>Возвращаемое значение</b>
<br> <br>
	FieldBlock() возвращает блок кода для доступа к полю.
<br> <br>
<b>Описание</b>
<br> <br>
	Если блоку передается параметр, значение поля набора изменяется на значение
	этого параметра. В противном случае блок кода возвращает значение поля.<br>
	Автоматического отображения изменения в базе данных не производится.
	Для отражения изменения в базе данных (для выполнения TRowset:updateSQL
	на сервере), необходимо вручную вызвать метод TRowset:Write(). См. пример.
<br> <br>
	Метод FieldBlock() по своему действию аналогичен стандартным функциям
	клиппера FieldBlock() и FieldWBlock().
<br> <br>
<b>Пример</b>
<pre>
<b>
? eval(rs:FieldBlock(2))      // показать значение 2-го поля
eval(rs:FieldBlock(2),"Вася") // установить значение 2-го поля
rs:Write(rs:Read())           // отобразить изменение на сервере
</b>
</pre>
<hr>
<a name="browse"></a>
<b>Browse()</b><br>
Просмотр записей в окне.<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	Browse([&lt;nTop&gt;],[&lt;nLeft&gt;],[&lt;nBottom&gt;],[&lt;nRight&gt;],
[&lt;asColumns&gt;],[&lt;asHeaders&gt;],[&lt;anWidths&gt;]) --> NIL
<br> <br>
<b>Аргументы</b>
<br> <br>
	&lt;nTop&gt;,&lt;nLeft&gt;,&lt;nBottom&gt;,&lt;nRight&gt; -
координаты окна. По умолчанию 0,0,MAXRFOW(),MAXCOL().
<br> <br>
	&lt;asColumns&gt; - массив строк, определяющих имена полей набора,
подлежащих выводу. По умолчанию все поля.
<br> <br>
	&lt;asHeaders&gt; - массив строк, определяющих заголовки столбцов.
По умолчанию - имена полей.
<br> <br>
	&lt;anWidths&gt; - массив чисел, определяющих ширины столбцов.
По умолчанию используются ширины полей первой попавшейся записи.
<br> <br>
<b>Описание</b>
<br> <br>
	Browse() представляет собой простейший инструмент для интерактивной
	навигации по набору записей, без возможности редактирования, добавления
	и удаления записей.
<br> <br>
	Метод Browse() использует функцию SQLBrowse().
<br> <br>
	Вы можете написать свой browse и переопределить стандартный метод.
См. пример.
<br> <br>
<b>Пример</b>
<pre>
<b>
// foo.prg
rs:Browse() // стандартный
rs:Browse := @MyBrowse()
rs:Browse() // ваш собственный MyBrowse()
...
static function MyBrowse()
// ваша реализация
return
// end of foo.prg
</b>
</pre>
<hr>
<a name="rsdestroy"></a>
<b>Destroy()</b><br>
Уничтожает объект TRowset.<br>
<hr>
<br>
<b>Синтаксис</b>
<br> <br>
	Destroy() --> NIL
<br> <br>
<b>Описание</b>
<br> <br>
	Destroy() уничтожает объект класса TRowset.
<br> <br>
<b>Пример</b>
<pre>
<b>
rs := conn:CreateRowset("SELECT * FROM mytable")
...
rs:Destroy()
</b>
</pre>
<hr>
<b>См. также:</b>
<a href="#createrowset">[ TConnect:CreateRowset() ]</a><br>
<hr>
<center>
&#169 Рушад Набиуллин, <A HREF="mailto:rust@itk.ru">rust@itk.ru</A>, 2000
</center>
</BODY>
</HTML>


