<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
<LINK REL=STYLESHEET TYPE="text/css" HREF="styl.css">
<TITLE>Clipper compiler</TITLE>
</HEAD>
<BODY>
<h4>             Новшества в языковых возможностях </h4>
<p>
 Сделан новый оператор switch - выбор одной из многих веток исполнения:
 <xmp>
 	switch (expr)
        	case const1 [,const2 [,const3]]
                	// операции
                case const11
                	// операции
                otherwise
                        // операции
        end
 </xmp>
 Для похожести на "do case","endcase" добавлены команды "do switch","endswitch"
<hr>
 Сделана новая операция :=@ - присвоение по ссылке:
 <xmp>
 a:="a"
 b:=@a
 ? a,b   // "a","a"
 b:="b"
 ? a,b   // "b","b"
 b:=@NIL // отрывает ссылку.
 </xmp>
<hr>
 Специально для удобной работы с MAP и объектами сделан вот такой цикл:
 (подробное описание о MAPах и объектах находится ниже)
 <xmp>
 FOR value IN map_var
 	? value
 NEXT
</xmp>
 будет перебирать все элементы в <i>map_var</i> и класть их в <i>value</i>;
 или
 <xmp>
 FOR key IN map_var KEYS
 	? key, map_var[key]
 NEXT
 </xmp>
 будет перебирать все элементы в map_var и в key складывать значения
 ключей для доступа к текущему элементу MAP или объекта.


<hr>
 Макроподстановки компилируют и исполняют более сложные выражения и рекурсивные
 вызовы макроподстановок. Вернее обрабатываются практически все конструкции,
 кроме команд и операторов типа <i>for, while и т.п.</i>

<hr>
  Рациональные числа с неограниченной точностью! <BR>
  Большие числа пока поддерживают только простые математические операции -+/*^%. <BR>
  Чтобы задействовать данные возможности, надо просто сказать где-нибудь
  в программе <BR>
  <xmp>
  set(_SET_RATIONAL,.t.)
  </xmp>
  или командой описанной в <i>clip.ch</i>
  <xmp>set rational on|off </xmp>
  Компилятор не поддерживает большие числа в качестве констант, т.е.
  при использовании выражений типа <BR>
  <xmp>x:=123456789012345678901234567890</xmp>
  компилятором будет сделана попытка преобразовать его в <i>double,</i> и чем это
  закончиться - одному сопроцессору известно. <BR>
  Чтобы реально использовать большие константы, надо использовать функцию <i>VAL()</i> <br>
  <xmp>x:=val("123456789012345678901234567890")</xmp>
  Можно и так:
  <xmp>x:=val("1234.567890")
  x:=val("1/3")</xmp>
  Функция STR(val,len,dec) теперь поддерживает параметры <i>len, dec</i> любого
  значения. Например:
  <xmp>? str(val("7/3"),1000,990)</xmp>
  Добавлена функция <i>RSTR(val),</i> которая выдает строку в виде
  <i>"numerator/denominator",</i> т.е. эту строку можно поместить в <i>val()</i> и при этом
  не получить никакой потери точности при преобразованиях! <BR>
  <xmp>? rstr(val("7/3")+val("5/6")) // ---->>> "19/6"</xmp>

<hr>
 Хэш-код - число больше чем 1 000 000 000 - результат сворачивания
   строки в число по методу битовых операций с каждым байтом указанной
   строки. Для строк менее 20 символов вероятность получения одинаковых
   кодов для разных строк примерно 1/1000000.
   Для строк более длинного размера вероятноcть падает.

<hr>
  Компилятор  понимает  шестнадцатиричные  числовые  константы  в виде
  0x20, 0x30.
<hr>
  Ассоциативные массивы (AM) - подробнее в модели ОО.</a>
  Если коротко, то обычный массив выглядит так:
  <xmp>
  declare m[5]
  m[1]=11; m[2]=12; ....
  </xmp>
  Ключами доступа к элементам являются непрерывный ряд чисел,
  ограниченный объявленным размером массива, в результате чего вставить
  в такой массив элемент с ключом 6 становиться проблемой и
  тормозом в прикладной программе.
  А у AM ключами являются строки, например:
  <xmp>
  m=map()
  m:asdf=11; m:qwer=12
  ? valtype(m) // 'O'  //object
  ? len(m)     //  2
  ? m:qwer     // 12
  </xmp>
  Фактически в качестве ключа доступа к элементу такого массива является
  хэш-код указанной строки, который вычисляется на этапе компиляции.
  Хэш-код может вычисляться компилятором еще и посредством конструкции <i> `qwer` </i>
  Например:
  <xmp>? m:qwer==m[`qwer`]  // .t.                  </xmp>
  В run-time хэш-код можно вычислить <i>hashstr("QWER")</i>

  <xmp>? m:qwer==m[hashstr("QWER")] // .t. </xmp>

  обратите внимание на то, что <i>QWER</i> пишется большими буквами, это сделано
  из-за того, что компилятор не различает регистры букв. <BR>
  Получить список ключей в АМ можно <i>mapkeys(m)</i> - возвращает массив
  с хэш-кодами, которые есть в массиве m
  <xmp>mm=mapkeys(m)</xmp>
  (вместо функции <i>mapkeys()</i> можно использовать специальный цикл,
  описание которого находится чуть выше)  <BR>
  <xmp>
  ? len(mm) // 2
  for i to len(mm)
    ? mm[i]   //вернет что-то типа 1233345677, 124321423
  next
  </xmp>
  Еще АМ характеризуется очень быстрым доступом к элементам, так как
  фактически поиск нужного элемента производиться по бинарному дереву.
  И вместо <i>ascan(mm,`QWER`)</i> лучше использовать <i>`QWER` $ m  // -> .t.</i>

<hr>

 Модель ОО.
  <p>
  Для начала немного о встроенной ОО-модели клиппера.
  Она построена на основе обычных массивов и любое обращение типа
  <xmp>obj:attribute или obj:method() </xmp>
  приводит к тому, что в массиве <i>obj</i>
  производится поиск элемента, у которого первый элемент совпадает с
  именем <i>attribute</i> или <i>method,</i> причем такой поиск производится линейно
  и практически является аналогом функции
  <xmp>ascan(obj,{|x|x[1]=="attribut"}),</xmp>
  что естественно очень плохо сказывается на производительности
  ОО-модели "чистого" CA-Clipper. Я конечно немного упрощаю для более
  простого понимания, но смысл остается такой, который я описал.
  <p>
  Надеюсь, теперь понятно, для чего сделаны ассоциативные массивы?
  ОО-модель на основе АМ работает быстрее на порядок!
  <p>
  При этом исчезает необходимость в конструкциях типа
  <xmp>obj:=tclass(class_name):new() </xmp>
  и в самом классе <i>tclass,</i> который
  занимается тем, что обеспечивает <i>run-time</i> поддержку регистрации
  новых классов. А это увеличивает эффективность ОО-модели еще
  в несколько раз.
  <p>
  Как сделать свой класс? Очень просто:
<xmp>
  function  MyClassNew()
     obj:=map()                // пустой объект
     clone(MyClass2New(),obj)  // унаследовать структуру от MyClass2
     clone(MyClass3New(),obj)  // унаследовать структуру от MyClass3
			       // если уже имеются совпадающие атрибуты
			       // или методы, то они будут заменены по
			       // принципу "кто последний - тот и папа"
     obj:attribute1:=0
     obj:attribute2:=date()
     obj:method1:=@func1()   // присвоить методу указатель на функцию
     obj:method2:=@func2()   // эти функции должны быть определены в этом же
			     // prg-файле
			     // если методы уже были унаследованы от других
			     // классов - они будут переназначены на указанные.
  return obj                 // вернуть готовый объект

  static function func1
      ::attribute1++
  return NIL

  static function func2(self)
      self:attribute1--
  return self
</xmp>

  Хотелось бы еще добавить два простых правила:
  <ul>
  <li>атрибут рождается при первом присвоении в него чего-нибудь, в том
  числе и NIL;
  <li>методом можно назначить или переназначить в любой момент в <i>run-time</i>
  любую функцию, объявленную как <i>static function</i> в этом модуле.
  Либо  наследовать ее от другого объекта, как обычное присвоение значений.
  <xmp>myObj1:metod1 := myObj2:=metodX</xmp>
  </ul>

  Как использовать объекты? Еще проще, вернее так же, как и в CA-Clipper.
  <xmp>
  obj:=MyClassNew()
  obj:metod1()
  ? obj:attribute1
  </xmp>

  В объекте можно объявить метод <i>destroy(),</i> но это не совсем <i>destructor,</i>
  как это принято в языках 3 поколения.  Есть переменная
  <xmp>
  local myObj:=myclassNew()
  </xmp>
  В ней лежит объект.
  При выходе из тела функции эта переменная будет уничтожена со  всеми
  вложенными в ней данными.
  Берем пример, что в этой <i>myObj</i> имеется атрибут
  <xmp>
  myObj:hFile:=fopen(trali_vali).
  </xmp>
  При уничтожении <i>myObj</i> необходимо закрыть <i>hfile,</i> но компилятор
  об этом не знает, компилятор (вернее не компилятор, а виртуальная машина)
  знает только о том, что в <i>hFile</i> лежит число и уничтожит только число,
  а файл останется открытым!
  Вот для этого и делается метод <i>destroy,</i> который будет вызываться
  (если таковой имеется) перед уничтожением переменной <i>myObj.</i>
  <xmp>
  static function my_destroy()
 	fclose(::hFile)
  return
  </xmp>
<hr>
  Контроль изменений аттрибутов в объекте.
  <p>
  Если надо контролировать изменения атрибутов объекта, то сделайте
  метод <i>modify</i> и установите <i>mapmodify(map_obj, .t. ) </i>. Тогда
  все изменения будут приходить сначала в метод modify и, только после
  этого, изменится значение атрибута, на то значение которое вернет
  метод modify()

<hr>
<a name="recover">  Регенерация объектов. </a>
   <p>
   CLIP умеет хранить в MEMO полях данные любого типа, в том числе и объекты.
   Но при записи объекта в БД не сохраняются методы объекта (потому что нет смысла
   хранить код с каждым экземпляром, да и методы имеют тенденцию к изменению).
   <p>
   А при восстановлении объекта происходит следующее: раскодируюся данные ( var ),
   если тип полученных данных - объект, то у объекта запрашивается атрибут
   CLASSNAME и делается попытка вызвать функцию _recover_&var:CLASSNAME(var),
   в которую передается восстановленный объект. Эта функция и должна назначить
   "утерянные" при записи методы.
   <p>
   Этим же механизмом можно пользоваться и для передачи объектов в виде строки.
   Например по почте или TCP-соединению :)
   <p>
   Вот пример использования:
<xmp>
x:=asdfNew()  /* создается объект */
? "x:m1",x:m1() /* проверка работоспособности */
? "x:m2",x:m2()
y:=var2str(x) /* объект кодируется в строку */
              /* or field->memo_field:=x */
? "y=",y
z:=str2var(y) /* раскодируется обратно, при этом вызывается _recover_asdf() */
              /* or z:=field->memo_field */
? "z=",z
? "z:m1",z:m1() /* проверка на работоспособность */
? "z:m2",z:m2()
?
return


function asdfNew()
	local o:=map()
	o:classname := "ASDF"
	o:a1 := "asdf"
        o:a2 := "qwer"
	_recover_asdf(o)
return o

function _recover_asdf(o)
	o:m1 :=@ asdf_1()
        o:m2 :=@ asdf_2()
        ? "recovering"
return o

static function asdf_1
    ? "asdf_1",::a1
return ::a1
static function asdf_2
    ? "asdf_2",::a2
return ::a1
 </xmp>
<hr>
	Переопределение операторов для объектов
        <p>
    Если объект имет специальные методы, то включается переопреление операций,
    например выражение: <BR>
    oRes := o1 + o2<BR>
    фактически выполнится так: <BR>
    oRes := o1:operator_add(o2)<BR>
    <h5> Список специальных методов:</h5>
    <table border=1>
    <tr>
    <TD>'+'<TD> operator_add
    <TD>'-'<TD> operator_sub
    <tr>
    <TD>'*'<TD> operator_mul
    <TD>'/'<TD> operator_div
    <tr>
    <TD>'%'<TD> operator_mod
    <TD>'^'<TD> operator_pow
    <tr>
    <TD>'|'<TD> operator_or
    <TD>'&'<TD> operator_and
    <tr>
    <TD>'$'<TD> operator_in
    <TD>'='<TD> operator_eq
    <tr>
    <TD>'=='<TD> operator_eeq
    <TD>'!='<TD> operator_neq
    <tr>
    <TD>'<' <TD> operator_lt
    <TD>'>' <TD> operator_gt
    <tr>
    <TD>'<='<TD> operator_le
    <TD>'>='<TD> operator_ge
    </table>

<hr>
  Благодаря такому устройству ОО-модели и возможности компилировать
  быстрый код посредством трансляции в С-программу, появилась возможность
  написать стандартные классы <i>TBrowse, Get</i> на самом CA-Clipper. <BR>
  При этом визуально производительность этих классов не хуже, чем
  написанные на чистом C в стандартном CA-Clipper. <BR>
<hr>
<center>
<HR>
&#169 Ю.Хныкин, <A HREF="mailto:uri@itk.ru">uri@itk.ru</A>, 2001
</center>
</body>
</html>
