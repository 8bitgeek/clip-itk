<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
<LINK REL=STYLESHEET TYPE="text/css" HREF="styl.css">
<TITLE>CLIP compiler</TITLE>
</HEAD>
</HEAD>
<BODY background=fon.gif>
<h5>Возможные проблемы </h5>
<p>
	select 0 ; dbskip() - некоторые функции типа dbskip() в клиппер50
  не выдают ошибку EG_NOTABLE, а в клиппер53 - выдают ошибку, в клипе сделано
  как в клиппер53.
<p>
 	Клип поддерживает синтаксис в стиле CAVO и Flagship <BR>
   local varname AS REF typename, поэтому "AS","REF" являются
   зарезервированными словами.
   Нельзя использовать эти слова в качестве имен переменных
   или функций.
<p>
	static a:= chr(13) + chr(10) <br>
   в клиппере - chr() обрабатывается компилятором, и такое выражение
   считается константой, в клипе все функции равны между собой и такое
   выражение не будет считаться константой.
<p>
   FULLSCREEN/stream - clip умеет работать в двух режимах: <BR>
   - fullscreen - это как обычно было принято в clipper`е, но прошу учесть что
   clipper выводил данные в видео-ОЗУ, а clip-app работает с терминалом и не
   УМЕЕТ читать с терминала как из видео-ОЗУ (это просто невозможно), все
   операции типа save|restore screen производятся с БУФЕРОМ экрана.
   <BR><BR>
   - потоковый - как принято в unix-системах, при этом нельзя использовать
   полноэкранные и клавиатурные функции, только команды типа "?" -
   стандартный вывод.
   <BR><BR>
   Разница проявляется в том что при выводе в поток clip-приложения не
   производят перекодировок выводимой информации.
   <BR><BR>
   clip-приложение по умолчанию работает в потоковом режиме до первой попавшейся
   полноэкранной команды. Как только приложение вызывает одну из полноэкранных
   команд - clipVM пытается проинициализировать ТЕРМИНАЛ и при невозможности
   выдает ошибку и прекращает работу.
   <BR><BR>
   Совет N1 - чтобы сразу переключить свои программы в полноэкранный
   режим поставьте первой строкой в главной процедуре команду: <BR>
   clear screen. <BR>
   Этим самым программа первым делом проинициализирует терминал и переключится
   в полноэкранный режим.
   <BR><BR>
   Совет N2 - если надо работать только в потоковом режиме - используйте
   для вывода только команду "?" и обязательно  перехватите
   обработчик ошибок: <BR>
   <xmp>
   errorBlock({ |err| myErrHandle(err) })
   static function myErrHandle(err)
   	outlog(0,"Error:",err)
        quit
   return
   </xmp>
   потому-что стандартный обработчик имеет вызовы итерактивных функций.
<hr>
<pre>
a = fileseek(currdrive()+"/"+CurDir() + "/*.*", FA_DIRECTORY)
// если в каталоге нет ни одного файла, то получаем пустой массив
// если же имеем хоть один файл, то получим и список директорий
// если инициализировать как:
// a = fileseek(currdrive()+"/"+CurDir(), FA_DIRECTORY)
// то проходит все нормально

maska *.* - это досовская, а в DOS, даже если нет расширения,
все равно предполагается, что в имени файла точка присутствует.
В UNIX нет разделения на имя и расширение, поэтому получается
что маска *.* будет искать файл/каталоги, у которых в имени
имеется точка ! Для UNIX правильная маска в данном случае - "*".
В clip~е объявлен
#define FILE_MASK  "*"
зависимый от особенностей ОСи. Лучше использовать его.
</pre>
<hr>
   Наборы символов FIELD, WHILE, FOR, CASE, END и некоторые другие
   не всегда могут определяться как имена переменных или полей,
   поэтому лучше не использовать имена ключевых слов в качестве
   имен переменных.

<hr>
   Не всегда честно определяется функция IF(,,)
   от оператора  IF .. ELSE .. ENDIF.
   В тех местах, где возможна неопределенность - выдается ошибка.

<hr>
   Не поддерживаются строковые константы, ограниченные символами [].
   Вернее, эти строки будут "интернационализированы".
   В данном случае лучше использовать "экранирование" в виде
   ключевых символов "&\", в частности можно использовать а-ля-сишные
   псевдо-константы &\n &\t &\r &\" &\' && и т.п.

<hr>
   Проблема type():<BR>
   в clipper -<BR>
   type("substr('asdf')") -> вызывается substr()<BR>
   type('alert()') -> не вызывается alert()<BR>
   Т.е., в clipper есть некоторые псевдо-функции, которые могут вызываться.
   В clip, в данный момент, никакие функции не вызываются из type().

<hr>
   Не поддерживаются FKLABEL(), FKMAX().

<hr>
   Не поддерживаются обнаруженная ошибка Clipper, выражающаяся в том, что
   на конструкцию <BR>
   if NIL==0 <BR>
   он выдает ошибку сравнения; а на выражение <BR>
   if (NIL==0) <BR>
   ошибка не выдается - хотя по правилам сравнения с NIL - в первом
   выражении ошибка не должна выдаваться. <BR>
   Мы  считаем,  что  эта  особенность  Clipper не имеет практического
   применения и не поддерживается в Clip~е.

<hr>
   Файловые функции, которым в качестве параметра назначается путь:
   - путь будет оттранслирован - символы '\' в  '/'<BR>
   - символы "c:","d:" будут заменены на соответствующие установки,
   возвращаемые/устанавливаемые через <BR>
   SET("C:","/usr/home/c:"),<BR>
   - все символы в пути будут переведены в нижний регистр, если командой
   set translate path установлен режим ON (default - OFF).<BR>
   При указании имени диска в SET указывайте имя DOS-диска ("C:")<BR>
   именно большими буквами. <BR>
   - по умолчанию, в clipper-программе автоматически объявляется один
   диск "C:" и назначается в юниксовый каталог "/", не забывайте
   вставить в "init procedure" свои назначения дисков.<BR>
   Будьте осторожны с досовским символом "слеш", вместо него лучше
   использовать предопределенный в config.ch PATH_DELIM.

<hr>
   indexExt() возвращает строку в нижнем регистре. Это связано с тем, что
   unix-файловые системы чувствительны к регистру букв, а имена файлов и
   их расширения все-таки принято называть мелкими буквами.

<hr>
   Вывод двойной псевдографики невозможно описать через terminfo,
   зато можно через termcap (немножко нестандартно, используются
   вхождения g1 и g2, пришло от старого Demos Commander).
   Сделайте 'setenv TERMCAP /etc/termcap', и если в описании вашего
   типа терминала все в порядке с псевдографикой, то будут и двойные
   и одинарные линии. Если псевдографики  нет вообще или вместо нее
   абракадабра - пишите, поможем разобраться.

<hr>
   Вывод символов с кодами менее 32 на терминал невозможен, поэтому
   эти символы выводятся sym+32 и подсвечиваются другим цветом.

<hr>
   Придется вам вспомнить о функциях DISPBEGIN(), DISPEND(). Тем, кто
   давно  работает  с  терминалами,  должно  быть понятно для чего это
   нужно.
   А вот новичкам - советую почитать внимательнее описание
   этих функций и представить, как информация бегает от сервера к терминалам
   по узким каналам связи и в каком месте грузиться процессор при выводе
   "якобы на экран". Использовать их не обязательно, но желательно,
   особенно в тех местах, где вы сами выводите на экран и обрабатываете
   ввод с клавиатуры. В тех функциях и командах (PROMPT/MENU, GET/READ ...),
   где обработка экрана и клавиатуры производиться самостоятельно,
   уже используется оптимальный вывод на экран. Так что обрамлять их в
   BEGIN() & END() не надо.

<hr>
   Снято ограничение на размер имени функции/процедуры в 10 символов.
   То же самое касается и имен переменных. И, для облегчения перехода на
   длину более 10 символов, в clip-препроцессоре введен еще одна команда
   "#xdefine lang_name small_name", которую можно использовать для
   быстрой замены всех длинных имен на старые короткие.

<hr>
  Снято ограничение на размер строки в 64k.

<hr>
 Снято ограничение на размер массива в 4096/8192 элемента.

<hr>
 MEMOEDIT сделан на базе класса textedit, возможны проблемы
    с пользовательскими функциями для memoedit.

<hr>
 get:baddate() - оформлен как метод, а не как атрибут.

<hr>
 tbrowse-объект визуализирует не совсем так, как стандартный. Но
    снимает множество проблем, связанных с количеством
    полей в просматриваемой БД и позиционированием курсора при
    перемещении по таблице в пользовательских функциях.

<hr>
 Вывод команды RUN портит экран.
    При выводе на терминал, данная проблема не может быть полностью решена
    без дьявольских ухищрений, так как получается, что несколько программ
    выводят независмо друг от друга на одно устройство. Примерно так же,
    как если бы несколько программ, не зная друг о друге, выводили бы
    информацию в один COM-порт. <BR>
    Советую использовать что-то типа:<BR>
    .....<BR>
    run &command<BR>
    wait "Press any key"<BR>
    clear screen   // или restore screen<BR>
    .....<BR>

  И еще одна особенность команды run. В UNIX эта команда
  запускает shell-оболочку и потом shell выполняет команду.<BR>
  Так вот, команда "run cd mydir" хотя и сработает, но, при
  выходе из shell, текущий каталог вернется на место! <BR>
  Используйте функцию dirchange(new_cur_dir) для смены текущего
  каталога.

<hr>
 Имеется некоторая несовместимость в error-объекте.<BR>
    <ol>
    <li>subsytem - это не метод, а атрибут. Проверьте сразу в
    ваших errorsys, иначе попадете в рекурсивный вызов errorblock
    и получите большие неприятности.</li>
    <li>в объекте error совместимость обеспечена только на уровне</li>
    error.ch, все, что не было в нем описано - не поддерживается.</li>
    <li>error:osCode системно зависимая переменная.</li>
    </ol>

<hr>
    Там, где в программах стоит inkey() без параметров, надо поставить хотя бы
    inkey(0.1). Иначе программа будет поедать слишком много процессорного
    времени.

<hr>
    "restore from" работает всегда с "additive".<BR>
    "save all like <mask> to my_file", <mask> действует только на те имена,
    которые явно объявлены как private и public, если статус private
    переменная получила в результате неявного вызова типа <BR>
    "asdf:=xxx",<BR>
    то такие переменные можно сохранить только явным перечислением:<BR>
    save asdf to my_file

<hr>
  В DBU пришлось кое-что изменить на предмет inkey() и
  стабилизации в BROWSE - эти изменения обрамлены #ifdef __CLIP__.

<hr>
  Не поддерживается, и, видимо, не будет поддерживаться команда set procedure.
  Используйте сборку всей программы на этапе линковки или новые возможности
  CLIP, связанные с po-файлами, читайте описание функции load().

<hr>
 setcolor() оперирует 10 парами цветов, новые 5 пар нигде явно не используются
 и не имеют специального назначения, введены для удобства программирования
 юзерных приложений.

<hr>
<center>
&#169 Ю.Хныкин, <A HREF="mailto:uri@itk.ru">uri@itk.ru</A>, 2000
</center>
</BODY>
</HTML>
