<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
<LINK REL=STYLESHEET TYPE="text/css" HREF="styl.css">
<TITLE>Clipper compiler</TITLE>
</HEAD>
<BODY>

<h4>             Новшества в управлении данными </h4>
<p>
 CLIP поддерживает хранение в MEMO-полях переменных любого типа, включая
 объекты, массивы.
 <xmp>
 field->memo_field := {"A",1.00,date(),.t.,tbrowseNew()}
 ? field->memofield
 </xmp>

<hr>
 Параллельно с функциями db*() имеется пакет функций rdd*() работающий
 не с алиасами, а с указателями на открытые таблицы и связанные с ними
 индексы. Для облегчения работы подобным образом написан
 <a href="o_rdd.html">класс RDD</a>
<hr>
clip при dbUseArea на самом деле файлы не открывает в том понятии,
в котором это понимает DOS.

 На самом деле открывается не файл, а на него создается
 MEMORYMAP - отображение содержимого файла в виртуальном адресном
 пространстве памяти ОС.
 <br>
 Т.е. clip обращается не к файловым операциям, а берет данные
 прямо из памяти. И только, если система не дает этого сделать,
 тогда идет чтение из файла.
 <br>
 Так вот чтобы брать много данных, надо дать процессу возможность
 адресоваться к такому размеру памяти, в котором должны уместится
 все используемые данные + индексы.
 Такие ограничения/разрешения даются при помощи команды shell~а
 ulimit -v.
 <br>
 Clip-программа сама пытается выставить ограничение по максимуму,
 но это зависит от настроек этого самого ulimit. Вполне возможно,
 что такое и не удаcтся сделать и тогда clip пишет в log-файл
 сколько же ему удалось запросить про запас.
 Эту память можно увидеть в программе top под названием shared.
 <br>
 Не надо пугаться, что для этого механизма требуется много физической
 памяти. Это совсем не так.
 <br>
 Эта память используется одновременно несколькими процессами и она
 одна для всех.
 <br>
 Например, ядро пользуется этим же механизмом для обеспечения
 shared-code, т.е. программы грузятся в память и несколько программ
 используют статический код, находящийся в одной и той же памяти.
 Поэтому top, практически у всех программ, показывает некоторое
 кол-во shared памяти.
 <br>
 В связи с этим получилось так, что некоторые операции, которые раньше
 могли исполнятся только в excl режиме, теперь могут быть
 выполнены и share-режиме. Например, zap.
 Не советую, конечно, пользоваться этими возможностями, лучше писать
 "классически".
<hr>
Параллельно с пакетом функций db...(), которые управляют данными посредством
механизма alias & select, имеется пакет функций rdd....(), которые управляют
данными через указатель на файл. Например: <BR>
fd:=rddUseArea(.t.,file_name,......) <BR>
rddGoTop(fd) <BR>
rddSkip(fd,nskip) <BR>
ну и так далее......
/*
<hr>
   Есть RDD с аббревиатурой DBFMEM работает так же, как DBFNTX, но
   не использует дисковых операций! При вызове закрывающих функций
   для индексов и данных уничтожается память, в которой он существовал.
   Очень рекомендую использовать для всяческих временных таблиц не
   слишком большого размера - иначе можете влететь в длинюююююююющий своп.
*/
<hr>
 Чтобы использовать разные кодировки данных поставьте <BR>
	set("DBF_CHARSET",code_page_file_name), при вызове <BR>
	dbusearea эти установки будут учтены.

<hr>
   Имеются функции: <BR>
   <BR>
   dbread() - возвращает объект со структурой, соответствующей
   структуре dbf текущего select <BR>
   Например:<BR>
   use test   // имеет поля field1,field2,....fieldn <BR>
   rec=dbread() <BR>
   ? rec:field1, rec:field2, .... <BR>
   <BR>
   dbwrite(rec) - записывает объект в dbf, равносилен конструкции <BR>
   replace field1 with value1, field2 with value2, ....<BR>
   Например: <BR>
   rec=map() <BR>
   или <BR>
   rec=dbread() <BR>
   rec:field1="asdf"<BR>
   rec:field2=date()<BR>
   dbwrite(rec)<BR>
   <BR>
   dbappend(rec) - добавляет запись и записывает в нее объект.
   <BR>
<hr>
	<b>Оторванные индексы (Independed Indices)</b><br><br>
	Оторванный индекс представляет собой обычный индексный файл.
	Но ключи в него добавляются вручную. Фактически это сортированный
	список ключей с некоторыми ассоциированными с ними данными.
	Набор функций для манипулирования оторванными индексами включает в себя
	функции создания/открытия/закрытия индекса/тега, функции
	добавления/удаления ключей, а также набор функций для навигации
	по ключам. В данный момент в качестве оторванного индекса можно
	использовать только CDX.<br>
	Реализованы следующие функции:<br>

	<b>II_CREATE([&lt;driver&gt;],&lt;name&gt;) -> index handle</b><br>
	создает пустой индекс (tagbag) без единого тега, используя указанный
	трехбуквенный драйвер &lt;driver&gt; (например "CDX"). Если драйвер не указан,
	используется драйвер индексов от текущего RDD (rddsetdefault()).
	После создания индекс остается открытым.
	Возвращается хендл для работы с этим индексом.<br>

	<b>II_CREATETAG(&lt;index handle&gt;,&lt;tag name&gt;,&lt;expr&gt;) -&gt; tag handle</b><br>
	создает в индексе новый тег типа возвращаемого &lt;expr&gt; значения.
	Возвращается хендл для работы с вновь созданным тегом.<br>

	<b>II_OPEN([&lt;driver&gt;],&lt;name&gt;) -&gt; index handle</b><br>
	открывает индекс.<br>

	<b>II_OPENTAG(&lt;index handle&gt;,&lt;name&gt;) -&gt; tag handle</b><br>
	открывает тег.<br>

	<b>II_CLOSE(&lt;index handle&gt;) -&gt; NIL</b><br>
	закрывает индекс.<br>

	<b>II_CLOSETAG(&lt;tag handle&gt;) -&gt; NIL</b><br>
	закрывает тег.<br>

	<b>II_ADDKEY(&lt;tag handle&gt;,&lt;id&gt;,&lt;key&gt;) -&gt; NIL</b><br>
	добавляет ключ в тег. &lt;id&gt; - набор байт (для CDX'а - 4)
	которые будут храниться в ассоциации с ключом. &lt;id&gt; должен
	быть типа CHARACTER. Указатель текущего ключа устанавливается
	на вновь добавленный ключ<br>

	<b>II_DELKEY(&lt;tag handle&gt;) -&gt; NIL</b><br>
	удаляет текущий ключ.<br>

	<b>II_GOTOP(&lt;tag handle&gt;) -&gt; NIL</b><br>
	устанавливает указатель текущего ключа на самый первый ключ
	(ключ с наименьшим значением).<br>

	<b>II_GOBOTTOM(&lt;tag handle&gt;) -&gt; NIL</b><br>
	устанавливает указатель текущего ключа на самый последний ключ
	(ключ с наибольшим значением).<br>

	<b>II_BOF(&lt;tag handle&gt;) -&gt; BOF</b><br>
	возвращает признак перемещения за первый ключ.<br>

	<b>II_EOF(&lt;tag handle&gt;) -&gt; EOF</b><br>
	возвращает признак перемещения за последний ключ.<br>

	<b>II_ID(&lt;tag handle&gt;) -&gt; associated data</b><br>
	возвращает строку байт ассоциированных с текущим ключом
	(для CDX - четыре байта).<br>

	<b>II_KEY(&lt;tag handle&gt;) -&gt; key value</b><br>
	возвращает значение текущего ключа.<br>

	<b>II_SKIP(&lt;tag handle&gt;,&lt;count&gt;) -&gt; NIL</b><br>
	перемещает указатель текущего ключа вперед или назад.<br>
<hr>
	<b>SIX</b><br><br>
	В мемо-полях можно хранить данные любого типа, включая массивы и обЪекты.
	Например:<br>
	<pre>
	dbcreate("test",{{"mmm","M",10,0}})
	use test
	append blank
	? valtype(field->mmm) // "M"

	field->mmm := 123
	? valtype(field->mmm) // "N"

	field->mmm := {1,2,3}
	? valtype(field->mmm) // "A"

	m := map()
	m:fname := "Bob"
	m:lname := "Smith"
	field->mmm := m
	? valtype(field->mmm) // "O"
	</pre>
	Для хранения/восстановления обЪектов с методами ОО-модель предоставляет
	возможность "регенерации" обЪектов.
	<a href="clipper6.html">См. описание ОО-модели.</a>
	<br><br>
	<b>VariFields</b><br>
	Тип "V" позволяет хранить в таблице строки любой длины. При этом
	непосредственно в DBF-файле хранятся лишь первые символы строки, а остаток -
	в FPT-файле. В DBF-файле также хранится 6 байт служебной информации.
	Например:<br>
	<pre>
	dbcreate("test",{{"vchar","V",20,0}})
	field->vchar := "123456789012345678901234567890"
	? field->vchar	// 123456789012345678901234567890
	</pre>
	Если строка умещается в <длина V-поля>-2 символах, то она целиком записывается
	в DBF. В противном случае в DBF запишется первые <длина V-поля>-6 символов,
	а остаток в FPT.<br>
	В V-поле можно хранить даты (V-дата занимает на диске всего 3 байта вместо 8).
	Для этого нужно указать длину V-поля равную 3.<br>
	Аналогично, в V-поле с длиной 4 можно хранить целые числа. Например:<br>
	<pre>
	a := {}
	aadd(a,{"date","V",3,0})
	aadd(a,{"int","V",4,0})
	dbcreate("test",a)
	use test
	append blank
	field->date := date()
	field->int := 1234
	? valtype(field->date),field->date	// D 11/05/2001
	? valtype(field->int),field->int	// N 1234
	</pre>
	<b>Триггеры</b><br>
	Триггер - это пользовательская функция, которая вызывается Клипом при
	возникновении следующих ситуаций:<br>
	<pre>
	  EVENT_PREUSE       - перед открытием базы данных
	* EVENT_POSTUSE      - после открытия базы данных
	* EVENT_UPDATE       - перед изменением индекса
	  EVENT_APPEND       - перед добавлением записи
	  EVENT_DELETE       - перед удалением записи
	  EVENT_RECALL       - перед восстановлением записи
	  EVENT_PACK         - перед PACK
	  EVENT_ZAP          - перед ZAP
	  EVENT_PUT          - перед записью данных в таблицу
	* EVENT_GET          - после чтения данных из таблицы
	  EVENT_PRECLOSE     - перед закрытием базы данных
	* EVENT_POSTCLOSE    - после закрытия базы данных
	  EVENT_PREMEMOPACK  - перед MEMOPACK
	* EVENT_POSTMEMOPACK - после MEMOPACK
	</pre>
	Триггеру передается 4 параметра:
	<xmp>
	<nEvent>    - номер типа события (константы EVENT_* определены в six2clip.ch)
	<nArea>     - номер рабочей области
	<nFieldPos> - номер поля (только для событий EVENT_GET, EVENT_PUT)
	<xTrigVal>  - значение поля (только для событий EVENT_GET, EVENT_PUT)
	</xmp>
	Триггер должен возвращать логическое значение. Если триггер возвращает .T.
	операция выполняется, в противном случае - нет. (Операции соответствующие
	событиям, помеченным (*), выполняются в любом случае).<br>
	Например, триггер может иметь следующий вид:
	<pre>
	function MyTrigger(nEvent,nArea,nFieldPos,xTrigVal)
		do case
			case nEvent == EVENT_DELETE
				// Каскадное удаление записей из дочерней таблицы
				DeleteChilds()
			case nEvent == EVENT_ZAP
				if alert("Are you sure?",{"Yes","No"}) != 1
					return .f.
				endif
			case nEvent == EVENT_PUT
				if FieldName(nFieldPos) == "AGE"
					if xTrigVal < 18 .OR. xTrigVal > 100
						alert("Bad age!")
						return .f.
					endif
				endif
		endcase
	return .t.
	</pre>
	Триггер устанавливается предложением TRIGGER команды USE или
	функцией sx_setTrigger(). (Команда USE ... TRIGGER определена
	в six2clip.ch). Например:
	<pre>
	USE test TRIGGER "MyTrigger"
	</pre>
	или
	<pre>
	USE test
	sx_setTrigger(EVENT_INSTALL,"MyTrigger")
	</pre>
	Если вы создатите "триггер по умолчанию" (функцию sx_defTrigger())
	он будет использоваться со всеми рабочими областями, на которые триггер
	не устанавливался.<br>
	<b>!!!</b> Обратите внимание на то что SIX-овые фичи работают только с DBFCDX
<hr>

<center>
&#169 Ю.Хныкин, <A HREF="mailto:uri@itk.ru">uri@itk.ru</A>, 2000
</center>
</body>
</html>
