<HTML>
<HEAD>
<LINK REL=STYLESHEET TYPE="text/css" HREF="styl.css">
<TITLE>Clipper compiler</TITLE>
</HEAD>
<BODY>
<center>
<A HREF="index.html" target='pole'>CLIP home page</a>


<h4>             Extensions of language features</h4>
</center>
<hr>
 new statement  "switch" -   select  1 from M node
<xmp>
 	switch (expr)
        	case const1 [,const2 [,const3] ... ]
                	// statemetns
                case const11 [, .... ]
                	// statements
                otherwise
        end
</xmp>
   create new command "do switch","endswich" via "do case","endcase"
<hr>
 create new operation ":=@", reference assign:
 <xmp>
 a:="a"
 b:=@a
 ? a,b  // "a","a"
 b:="b"
 ? a,b  // "b","b"
 b:=@NIL // remove reference
 </xmp>

<hr>
 For an easy work with MAP and objects, the following cycle has been made:
 (a detailed description of MAP and objects is given below)
 <xmp>
 FOR value IN map_var
        ? value
 NEXT
</xmp>
 will look through all elements in <i>map_var</i> and put them into
<i>value</i>;
 or
 <xmp>
 FOR key_value IN map_var KEYS
        ? key, map_var[key]
 NEXT
 </xmp>
 will look through all elements in map_var, and the key value will indicate
 the key of access to current elements of MAP or object.


<hr>
 Macro may consist of more complex expressions than in CA-CLIPPER, including recursive
 calls of macros. Practically all lexemes, exept commands and
 operators like <i>for, while, etc.</i>, are processed more accurately.

<hr>
  Rational numbers with unlimited accuracy!<BR>
  Currently, it is able to do  only simple mathematical
  operations -+/*^% on large numbers. <BR>
 To realize these possibilities, it's necessary to write somewhere in program<BR>
  <xmp>
  set(_SET_RATIONAL,.t.)
  </xmp>
  or via the command described in <i>clip.ch</i>
  <xmp>set rational on|off </xmp>
  The compiler does not support large numbers as constants, that is,
  when using expressions like<BR>
  <xmp>x:=123456789012345678901234567890,</xmp>
  the compiler will make an attempt to transform this into <i>double,</i>
  and only coprocessor knows what the result will be :) <BR>
  To actually use large constants, it's necessary to use <i>VAL()</i>
function<br>
  <xmp>x:=val("123456789012345678901234567890")</xmp>
  It's possible as follows:
  <xmp>x:=val("1234.567890")
  x:=val("1/3")</xmp>
  STR(val,len,dec) function now supports <i>len, dec</i> parameters of any
value.
  For example:
  <xmp>? str(val("7/3"),1000,990)</xmp>
  Also, <i>RSTR(val) function is added,</i> and this gives a string in the
form of
  <i>"numerator/denominator",</i> i.e. this string can be put into
<i>val()</i>,
  and at the same time there will be no accuracy loss during
transforming!<BR>
  <xmp>? rstr(val("7/3")+val("5/6")) // ---->>> "19/6"</xmp>

<hr>

  Hash code is the number more than 1 000 000 000, as a result of hashing
  a string to a number by using bit operations.
  For strings of less than 20 characters, the probability of coincidence of
  hash codes is approximately 1/1000000. For longer strings, the probability
  is reduced.

<hr>
  The compiler accepts hexadecimal constants in the form of 0x20, 0x30.
<hr>
  Association arrays (AA) - to understand these, read about OO model.
  For instance, an ordinary array may be written as follows
  <xmp>
  declare m[5]
  m[1]=11; m[2]=12; ....
  </xmp>
  To get access to elements, a consecutive numbers set is used, and it is
  limited with the array size. Inserting a new element becomes a problem,
  and it results in time losses. Opposite to ordinary arrays, elements of
  association arrays are identified by strings, for example:
  <xmp>
  m=map()
  m:asdf=11; m:qwer=12
  ? valtype(m) // 'O'  //object
  ? len(m)     //  2
  ? m:qwer     // 12
  </xmp>
  Actually, elements of association array are identified by a hash code
  of string calculated during compile-time. The compiler calculates hash
  codes of strings enclosed in "`" characters.
  For example:
  <xmp>? m:qwer==m[`qwer`]  // .t.                  </xmp>
  During run-time, hash code can be calculated as<i>hashstr("QWER")</i>

  <xmp>? m:qwer==m[hashstr("QWER")] // .t. </xmp>

  Pay attention to <i>QWER</i> which is written in capital letters, because
  the compiler does not distinguishes letter cases.<BR>
  It's possible to get a list of indexes in the associate array via
  <i>mapkeys(m)</i> which returns the array with hash codes being in m array
  <xmp>mm=mapkeys(m)</xmp>
  (instead of <i>mapkeys()</i> function, a special cycle can be used - its
  description is given above)<BR>
  <xmp>
  ? len(mm) // 2
  for i to len(mm)
    ? mm[i]   //will return something like 1233345677, 124321423
  next
  </xmp>
  Also, the associate array is characterized by a very fast access to
  elements, as a necessary element is actually searched in a hash table.
  And instead of <i>ascan(mm,`QWER`),</i> it's better to use
  <i>`QWER` $ m  // -> .t.</i>

<hr>

 OO model.
  <p>
  Firstly, some words about CA-Clipper built-in OO model.
  Its OO is based on usual array, and any call like
  <xmp>obj:attribute or obj:method() </xmp>
  results in the situation when in <i>obj</i> array there is searching of an
  element whose first element coincides with <i>attribute</i> or
<i>method,</i>
  name, and such search is executed lineary and is practically analogues to
  <xmp>ascan(obj,{|x|x[1]=="attribut"})</xmp> function, which greatly
reduces
  the efficiency of OO model of "pure" CA-Clipper. This, of course, is
rather a
  simplified explanation, but the sense is still that as described.
  <p>
  We believe, now it's clear for what purpose association arrays were made.
  OO model based on association arrays is faster by an order!
  <p>
  At the same time, there's no need in expressions like
  <xmp>obj:=tclass(class_name):new() </xmp>
  and in <i>tclass</i> class itself, which raises OO model efficiency by
several
  times.
  <p>
  How could you make your own class? It's very simple:
  <xmp>
  function  MyClassNew()
     obj:=map()                // empty object
     clone(MyClass2New(),obj)  // adoption of MyClass2 structure
     clone(MyClass3New(),obj)  // adoption of MyClass3 structure
                               // if there are coinciding attributes or
                               // methods, elements of the last class
                               // become main.
     obj:attribute1:=0
     obj:attribute2:=date()
     obj:method1:=@func1()   // method1 becomes a function reference
     obj:method2:=@func2()   // these functions must be defined in
                             // prg file
                             // if methods have been addopted from other classes,
                             // they will be reassigned to indicated classes
  return obj                 // returning a ready object

  static function func1
      ::attribute1++
  retun NIL

  static function func2(self)
      self:attribute1--
  retun self
</xmp>

  Also, we'd like to add two simple rules:
  <ul>
  <li>1. The attribute is created when something, including NIL, is
assigned to it.

  <li>2. At any moment, <i>in run-time,</i>the method can assign or reassign
  any function announced in this mudule as <i>static function</i>, or can
adopt
  this function from another object, as a usual assignment of values.
  <xmp>myObj1:method1 := myObj2:methodX</xmp>
  </ul>

  In what way can objects be used? As in CA-Clipper, or even more simply.
  <xmp>
  obj:=MyClassNew()
  obj:metod1()
  ? obj:attribute1
  </xmp>

  In an object, <i>destroy() method can be announced,</i> but it isn't quite
  <i>destructor,</i> which is usual in languages of the third generation.
  There is <xmp>local myObj:=myclassNew() variable,</xmp> and this is just an
  object. Upon leaving the function body, this variable, along with all its
  data, is destroyed.
  For example, this <i>myObj</i> has attribute
  <xmp>
  myObj:hFile:=fopen(trali_vali).
  </xmp>
  When destroying <i>myObj,</i> it's necessary to close <i>hfile,</i> but
the
  compiler doesn't know this; the compiler (rather a virtual machine) only
  knows that in <i>hFile</i> there's a number and will destroy the number
only,
  but the file will remain open!
  Just for this purpose <i>destroy</i> is created, and it'll called (if
  it exists ) before destroying <i>myObj variable.</i>
  <xmp>
  static function my_destroy()
        fclose(::hFile)
  return
  </xmp>

<hr>
   Control of change attributes.
  <p>
  If it's necessary to control changes of object attributes, make <i>modify
  method</i> and set <i>mapmodify(map_obj, .t. ),</i> modify method will
  be called, and only then the attribute value will be changed.
  New value of attribute changet to return value of method modify()

<hr>
<a name="recover">  Recovering/reviving objects. </a>
   <p>
   CLIP is able to store the data of any type to MEMO fields, including
   objects. But there is no way to store object methods (methods can be changed).
   <p>
   Recovering is made with steps below: data are decoded; if data are of
   'object' type and object have CLASSNAME attribute then called function
   _recover_&(var:CLASSNAME)(var). This function must assign this object methods.
   <p>
   This feature can be used to send object as string via e-mail or TCP :)
   <p>
   Here is an example of using this feature:
<xmp>
x:=asdfNew()  /* Constructor */
? "x:m1",x:m1() /* See wheter it works */
? "x:m2",x:m2()
y:=var2str(x) /* object -> string */
              /* or field->memo_field:=x */
? "y=",y
z:=str2var(y) /* string -> object, _recover_asdf() is called automatically */
              /* or z:=field->memo_field */
? "z=",z
? "z:m1",z:m1() /* see wheter it works now */
? "z:m2",z:m2()
?
return

function asdfNew()
	local o:=map()
	o:classname := "ASDF"
	o:a1 := "asdf"
        o:a2 := "qwer"
	_recover_asdf(o)
return o

function _recover_asdf(o)
	o:m1 :=@ asdf_1()
        o:m2 :=@ asdf_2()
        ? "recovering"
return o

static function asdf_1
    ? "asdf_1",::a1
return ::a1
static function asdf_2
    ? "asdf_2",::a2
return ::a1
</xmp>
<hr>
	Overloading operators for objects
        <p>
    If object have special methods then expession via:<BR>
    oRes := o1 + o2<BR>
    really run as: <BR>
    oRes := o1:operator_add(o2)<BR>
    <h5> List of special methods:</h5>
    <table border=1>
    <tr>
    <TD>'+'<TD> operator_add
    <TD>'-'<TD> operator_sub
    <tr>
    <TD>'*'<TD> operator_mul
    <TD>'/'<TD> operator_div
    <tr>
    <TD>'%'<TD> operator_mod
    <TD>'^'<TD> operator_pow
    <tr>
    <TD>'|'<TD> operator_or
    <TD>'&'<TD> operator_and
    <tr>
    <TD>'$'<TD> operator_in
    <TD>'='<TD> operator_eq
    <tr>
    <TD>'=='<TD> operator_eeq
    <TD>'!='<TD> operator_neq
    <tr>
    <TD>'<' <TD> operator_lt
    <TD>'>' <TD> operator_gt
    <tr>
    <TD>'<='<TD> operator_le
    <TD>'>='<TD> operator_ge
    </table>
<hr>
  Due to such OO model and compiling fast code via the translation into
  C-program, there appears a possibility to write <i>TBrowse and Get
  standard classes</i> in Clipper itself!<BR> At the same time, the
  efficiency of these classes is not worse than those written in pure C
  in CA-Clipper.<BR>
<hr>
<center>
<A HREF="index.html" target='pole'>CLIP home page</a>
<HR>
&#169 Uri Khnykin, <A HREF="mailto:uri@itk.ru">uri@itk.ru</A>, 2001
</center>

