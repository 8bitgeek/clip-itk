<HTML>
<HEAD>
<LINK REL=STYLESHEET TYPE="text/css" HREF="styl.css">
<TITLE>Clipper compiler</TITLE>
</HEAD>
<BODY>
<center>
<A HREF="index.html" target='pole'>CLIP home page</a>


<h4>             Extensions in compiler and preprocessor</h4>
</center>
<hr>
	<h5> Multivalue/multilanguage strings in RUN-TIME</h5>

CLIP now provides methods for developing multilanguage
applications and for controlling multivalue strings in RUN TIME!
Here and below, under term "language" we consider any reason
to make many versions of one string. For example, user, time of day,
user qualification (some accountant need to see "Press spacebar",
and others understand "Press any key" :), and more more other reasons.
<BR><BR>
As an example see the part of sources with comments.
Full sample sources attached (uudecoded).
<xmp>
//file: prg/samples/multilang.prg
#define s1 [Hello world]     // keyword1
#define s2 [Good bye world]  // keyword2
// All strings enclosed in [] delimiters are localized keywords

? "Locale module name is:",__CLIP_MODULE__
// __CLIP_MODULE__ is compile time predefined, it depends on -E compile switch
? "Default string1 is:",s1
? "Default string2 is:",s2
?
? "Install external data from lang1/ml1.mo:"
  ?? loadModuleMsg(__CLIP_MODULE__,"./locale.mo/lang1/"+__CLIP_MODULE__+".mo")
? "String1 for lang1 is:",s1
? "String2 for lang1 is:",s2
?
? "Install external data from lang2/ml1.mo:"
  ?? loadModuleMsg(__CLIP_MODULE__,"./locale.mo/lang2/"+__CLIP_MODULE__+".mo")
? "String1 for lang2 is:",s1
? "String2 for lang2 is:",s2

?
return

#file: prg/samples/Makefile
# [ some defines skipped ]
# CLIP_LOCALE_ROOT defines path where to save modules
CLIP_LOCALE_ROOT=./
export CLIP_LOCALE_ROOT
# [ other targets skipped ]
multilang: multilang.prg
	$(CLIP) $(CLIPFLAGS) -e -M -E CLIP_MODULE="ml1" multilang.prg $(CLIPLIBS)
	clip_msgmerge
	clip_msgfmt


#output from make processing
/home/uri/prg/samples > make multilang
/m2/uri/cliproot/bin/clip -a -O -b -e -M -E CLIP_MODULE="ml1" multilang.prg
parsing file 'multilang.prg' ..
open locale file './/locale.pot/ml1/multilang.pot'
# at this moment keyword1 and keyword2 are moved to external pot-file
.. done (23/2643 lines, 0 warnings, 1.47s)
writing file 'multilang.c' .... done, 3546 bytes ,0.00s
compile file 'multilang.c' .... done, 0.21s
generate reference file 'multilang_ref.c' .... done, 0.04s
make file 'multilang' .... done, 0.33s
clip: 2 files, 2.05s
# at this moment we create two or more directories (one per language)
# compiler does not know how many languages will your app support,
# so we need do it once. A new target language could be added at any time.
# mkdir ./locale.po/lang1
# mkdir ./locale.po/lang2
clip_msgmerge
# generate editable po-modules templates from pot-files
use locale root ./
module ml1
locale lang1 ... OK.
locale lang2 ... OK.
# at this moment we edit files (translate keywords from english to
# desired language). You will need to edit them next time as soon
# as new keywords will be added to application.
# vi ./locale.po/lang1/ml1.po
# vi ./locale.po/lang2/ml1.po
clip_msgfmt
# generate loadable mo-modules
use locale root ./
locale lang1
module ml1
locale lang2
module ml1
</xmp>

<hr>
	All words beginning with <i> HASH_ </i> are translated by the preprocessor
        into <i>hashstr("HASH_.....").</i> We need this to reduce the number of
        files included. And, instead of writing
        <xmp>
        #define HASH_asdf   12345678
        #define HASH_qwerty 231423534
        </xmp>
        and so on, we may simply use <i>HASH_....</i> key words in the program
        text, e.g.
        <xmp>
        do case
        	case HASH_asdf
                case HASH_qwerty
                ....
        endcase
        </xmp>
        You may be sure that, if you come accross a set of <i>HASH_asdf</i>
        symbols in different prg files, the result will be identical, as if
        the word had been announced via #define.


<hr>
	The preprocessor can get data from the environment, for instance:<BR>
        <xmp>
        #define $USER
        </xmp>
        will be actually translated into
        <xmp>
        #define uri
        </xmp>
        In particular, you may use CLIP_LANG environment variable to change
        the language spoken by clip libraries. For example:<BR>
        <xmp>
        export CLIP_LANG=LANG_RUSSIAN
        </xmp>
<hr>
 there are some predefined constants:
	<xmp>
	__FILE__
	__BASE_FILE__
	__LINE__
	__VERSION__
	__CLIP__
	__SYSTEM__
	__DATE__
	__TIME__
        </xmp>

<hr>
 New preprocessor command is added - #xdefine - being the same as #define, but
 insensible to the case of macros name announced.

<hr>
 The set of options may be written into .cliprc file, and the latter
 may be put into the home or current directory.

<hr>
 In addition to std.ch, some more automatically included head files may be
 written by putting in .cliprc file strings like:
 <xmp>
 -U std.ch
 -U clip.ch
 -U config.ch
  </xmp>

<hr>
 Compiler options are not in full compliance with the standard Clipper compiler,
 error and warning messages being not in compliance at all. But we believe that
 this incompliance will not give you great troubles.


<HR>
 The compiler can decode source codes in various Russian codes during the
 compilation, i.e. you may write programs in DOS and, without tricks, make
 them in UNIX. The only restriction: file names must be in the lower case.


<HR>
 <H5> The compiler can generate </H5>
   <ul>
   <li>po files - pseudocode or extended code block - small size, fast
   compilation, possible downloading in run-time, slow execution.
   These po-files are easily decompiled, but there is no decompiler itself yet.
   <li>C-programs - size 2 to 3 times larger than that of PO, compiled from C sources
   into object modules for a long time, operation 30 to 50% faster than that of
   PO, easily managed by tools of C-developer, decompilation is impossible.
   But, as for size and execution speed, manual coding is still more
   efficient; therefore, if you need fast functions, write them in C, or you may
   contact us, and we'll write them in C.
   <li>C+PO programs - pseudocode inside C program - quickly compilated,
   small size, slow operation, but managed by standard tools of C developer.
   Theoretically, decompilation is possible, though this is much more complex than
   for PO files.
   <li> Programs using dynamically loaded libraries (-s options).
   For information, please read about clip_run, and you'll get clear
   understanding how to do this.
   </ul>

<hr>
 Libraries are made of O files by standard librarians.


<hr>
 Libraries are made of PO files by clipar utility.


<hr>
 GET command has been changed, formerly it called _GET_ internal function,
 and now it calls GETNEW with added parameters.


<hr>
 Now, in run-time, you may download a pseudocode (code blocks) from files;
 For example, mylib.prg is being done, in which
        <xmp>
   func myfunc1
   return 1
   func myfunc2
   return 2
         </xmp>
   command is being done
        <xmp>
   clip -p mylib.prg,
        </xmp>
   as a result, mylib.po file with a pseudocode inside appears.<br>
   During the operation of any program, you may write:
           <xmp>
   load("mylib.po")
   ? myfunc1()
   ? myfunc2()
         </xmp>
<hr>
   In addition to outdev and outerr, one more output stream into log file was
   made.
   <xmp>
    SET(_SET_LOGLEVEL,num_level) // sets debug level
    SET(_SET_LOGFILE,filename)   // sets log file name; if it isn't set,
                                    the whole output will be directed into
                                    <program_name>.log
    OUTLOG(level, <list ,,,>)    // if the level isn't indicated, or the
    				    first indicated parameter isnt't a number,
    				    this information will ALWAYS be output
    				    into log file irrespective of current
                                    debug level.
    </xmp>
    For applied logging, use levels 1 to 3; level 4 gives information on
    called functions compiled as a byte code; level 5 outputs information
    on all functions called.<br>
    <b>Note</b> - log file isn't removed, therefere you need to do this
    yourselves.
    <p>
    As an explanation and recommendation: we would use<br>
    <ul>
    <li>level 0 - who and when run program, errorsys, call of important
    operations like indexing.</li>
    <li>level 1 - what menu items were called, what large modules of a program
        were used</li>
    <li>level 3 - analysis of time critical procedures, analysis of user
        activities and the like, document printing, access to "secret" data
        and so on.</li>
<hr>
<center>
<A HREF="index.html" target='pole'>CLIP home page</a>

<HR>
&#169 Uri Khnykin, <A HREF="mailto:uri@itk.ru">uri@itk.ru</A>, 2000
</center>

