<HTML>
<HEAD>
	<TITLE>Редактор DBF-файлов BDBFS</TITLE>
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
	<LINK REL="STYLESHEET" TYPE="text/css" HREF="styl.css">
	<META NAME="keywords" content="DBF, EDITOR, VIEWER, CLIPPER, CLIP, DBASE, XBASE, FOXPRO, SIX, MDX, CDX, NTX, NSX, DATABASE, редактор, вьюер, FLAGSHIP, VISUAL FOXPRO, FLEXMEMO>
	<META NAME="Description" content="Мощный редактор DBF для профессионалов xBase">
	<META NAME="Author" CONTENT="Евгений Бондарь">

	<STYLE>
		H4 {	font-family: Arial;
			font-size: 14pt;
			font-weight: bold;
			font-style: italic;
			text-decoration: underline;
			color: blue
		}

		H5 {	font-family: Arial;
			font-size: 12pt;
			font-weight: bold;
			text-decoration: underline;
			color: darkyellow
		}

		H6 {	font-family: Arial;
			font-size: 10pt;
			font-weight: bold;
			text-decoration: underline;
			color: blue
		}

	</STYLE>
</HEAD>
<BODY background=fon.gif>


<IMG align="right" SRC="bdbf.gif">
<H2><U><center>
			Редактор DBF-файлов BDBFS.EXE
</H2>
<br>
<H3><U>
			   Инструкция программиста
</H3>
</U>
</center>
</U>
<pre>
    Нижеследующее не претендует на полное описание, но, возможно,
кому-нибудь и пригодится.

	Текущее описание соответствует версии
			BDBFS 1.21.
</pre>
<H3> ПРЕДУПРЕЖДЕНИЕ </H3>
<pre>
<I>    Портирование BDBFS на платформу CLIP только началось и идет
не без затруднений, что связано, прежде всего, с использованием в
оригинальном, досовском, варианте BDBFS довольно большого количества
ассемблерных вставок и вообще различных трюков.
	Поэтому на данный момент возможно возникновение самых
разнообразных ошибок в самых неожиданных местах, а несомненные
преимущества CLIP пока никак не используются. Прошу Вас - будьте
толерантны. Ну а познакомиться с оригинальным BDBFS и сопутствующими
утилитами можно на странице http://www.geocities.com/bondar_eugen .
</I>
</pre>
<p><hr>
<a NAME="contents">
	Читайте далее:<br><br>
<ul>
<li><a href="#p1">1.Почему BDBFS ?</a>
<li><a href="#p2">2.Поддерживаемые форматы данных.</a>
<li><a href="#p3">3.Редактирование записей.</a>
<li><a href="#p4">4.Режимы Replace.</a>
<li><a href="#p5">5.Append/Copy.</a>
<li><a href="#p6">6.SUM.</a>
<li><a href="#p7">7.Поиск по индексу(тэгу).</a>
<li><a href="#p8">8.Выражения условий.</a>
<li><a href="#p9">9.Set Fields.</a>
<li><a href="#p10">10.Вычисление выражений.</a>
<li><a href="#p11">11.Задание переменных.</a>
<li><a href="#p12">12.Модификация структуры.</a>
<li><a href="#p13">13.Вставка записи.</a>
<li><a href="#p14">14.Total.</a>
<li><a href="#p15">15.Сохранение/восстановление окружения.</a>
<li><a href="#p16">16.Инициализационные файлы.</a>
<li><a href="#p17">17.Макроклавиши.</a>
<li><a href="#p18">18.Выход в DOS.</a>
<li><a href="#p19">19.Использование мышки.</a>
<li><a href="#p20">20.Совместимость с FoxPro.</a>
<li><a href="#p21">21.Работа в сети и мультизадачных системах.</a>
<li><a href="#p22">22.Обработка ошибок.</a>
<li><a href="#p23">23.Выражения цветности.</a>
<li><a href="#p24">24.Работа с буфером обмена.</a>
<li><a href="#p25">25.История условий и выражений.</a>
<li><a href="#p26">26.Стек позиций.</a>
<li><a href="#p27">27.Редакция memo-полей и внешних файлов.</a>
<li><a href="#p28">28.Печатные формы.</a>
<li><a href="#p29">29.Клавишные коды.</a>
<li><a href="#p30">30.Пользовательское меню.</a>
<li><a href="#p31">31.Проверка/коррекция базы.</a>
<li><a href="#p32">32.Плагины.</a>
<li><a href="#p33">33.Запуск BDBFS.</a>
<li><a href="#p34">34.Форсированный режим.</a>
<li><a href="#p35">35.Видео-режимы.</a>
<li><a href="#p36">36.Языковый интерфейс.</a>
<li><a href="#p37">37.Планы.</a>
<li><a href="#p38">38.Чего в BDBFS нет по сравнению с "конкурентами".</a>
<li><a href="#p39">39.Известные проблемы.</a>
<li><a href="#p40">40.Благодарности.</a>
<li><a href="#p41">41.Дальнейшие ругательства.</a>
<li><a href="#p42">42.Форма распространения.</a>

<li><a href="#pp1">ПРИЛОЖЕНИЕ I.Сводка клавиш.</a>
<li><a href="#pp2">ПРИЛОЖЕНИЕ II.СООБЩЕНИЯ.</a>
<li><a href="#pp3">ПРИЛОЖЕНИЕ III.Поддерживаемые функции.</a>
<li><a href="#pp4">ПРИЛОЖЕНИЕ IV.BDBFS-PRO.</a>

</ul>

<P><HR><a NAME="p1">
	 <h4>1.Почему BDBFS ?</h4>
<pre>

	И в самом деле - аналогов полно, только автору на данный момент
известны следующие viewer/browser-ы:

	- dbview Трофименко ~3к !!!!
	- dbview Царенко ~32k но с редакцией и поиском
	- popdbf Bowen-software - единственный известный мне резидент
	- vdbf Родионова, послуживший толчком для разработки
	- d123 Deveza
	- dbeditor Jeff Parnau
	- dbfedit Lau Preston
	- dbed Дмитриева
	- cdbf Чехуты
	- dbc Кресина

и при этом я нисколько не сомневаюсь, что перечислено далеко не все.
Можно также пользоваться и фирменным DBU Clipper. В конце концов, можно
просто зайти в Fox или там Delphi какой-нибудь ;-).

Тем не менее, у BDBFS есть своя ниша. При его написании девизом было:
	"Сделаем с выбранной базой, все что захотим !"
Имеются ввиду практически все функции, необходимые для повседневной работы
с базами, особенно при сопровождении. При этом хотелось запускать его
достаточно быстро и максимальное количество функций вынести на горячие
клавиши. Кроме того, желательно иметь под рукой единый продукт для работы
с разными форматами баз и индексов.

	Итак, BDBFS умеет:

	 - автоматически или принудительно выбирать формат индексов и MEMO
	 - редактировать записи в режиме BROWSE и EDIT
	 - печатать выбранную базу, в т.ч. и в файл, причем всю или по
	   условию
	 - формировать отчеты
	 - модифицировать структуру базы
	 - выводить структуру на принтер или в файл
	 - оптимизировать структуру
	 - искать по условию LOCATE / CONTINUE
	 - искать контекст без привязки к полям
	 - искать в текущем поле
	 - копировать записи
	 - копировать содержимое отдельных полей слева, справа,
	   снизу и сверху
	 - устанавливать существующий индекс (или tag)
	 - делать новый индекс (или tag)
	 - производить "мягкий" поиск по индексу
	 - производить "расширенный" поиск по индексу
	 - Replace по условию
	 - Sum,Count,Total по условию
	 - Delete/Recall по условию
	 - Copy to File / Append from, в т.ч. по условию и в текстовых
	   форматах. Возможно преобразование и переименование полей,
	   в том числе преобразование формата MEMO-полей
	 - Устанавливать фильтры
	 - Сортировать базу
	 - устанавливать нужный порядок и количество полей, их заголовки.
	   Возможны вычисляемые поля! При этом выбранный разрез может
	   быть распечатан и сохранен для дальнейшего использования!
	 - задавать переменные
	 - вычислять любое Clipper-выражение
	 - задавать макросы
	 - менять диск и директорию
	 - вызывать второй командный процессор
	 - очищать сразу всю запись
	 - делать Upper и Lower в текстовых полях
	 - менять режимы ввода
	 - работать с мышью
	 - выбирать все условия по истории
	 - сохранять и восстанавливать окружение
	 - читать инициализационные файлы
	 - выделять цветом различные ячейки по условию
	 - работать с буфером обмена
	 - самостоятельно отдавать TimeSlice
	 - "замораживать" поля для просмотра
	 - искать максимум/минимум
	 - прогуливаться по дискам/каталогам (Filer)
	 - использовать длинные имена Win9?

	 - и прочие приятные мелочи.

	Почти все функции можно вызвать как через горячие клавиши, так
и через меню.

	Большинство функций понятно любому xBase-систу (хотя знакомство с
Clipper желательно). Некоторые пояснения ниже. Назначение всех клавиш
см. в HELP и <a href="#pp1">сводке клавиш.</a>
<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p2">
         <h4>2.Поддерживаемые форматы данных.</h4><pre>

	Поддерживаются основные на сегодняшний день форматы xBase-файлов:

		dBASE3/Clipper  (DBT/NTX)
		FoxPro          (FPT/IDX/CDX)
		dBASE4          (DBT/MDX)
		SIX3            (SMT/NSX)

	Если у базы есть memo-поле, то соответствующий драйвер выбирается
автоматически. Иначе применяется драйвер по-умолчанию, который можно задать
в ini-файле или в установках(через меню).
Если в ini-файле ничего не задано, используется драйвер FoxPro (SIXCDX).

	Кроме стандартных Clipper-овских, поддерживаются поля типа
		Float (FoxPro), VariField (SIX).

	При открытии закриптованной базы SIX, запрашивается пароль.

	Форматы Visual FoxPro, dBASE5, FlagShip, FlexMemo поддерживаются
в форсированном режиме <a href="#p34">(см. п.34).</a><a><pre>

	Реально можно сделать поддержку NDX, если это кому-то еще
нужно. Что касается остальных существующих форматов (Comix,Inx,etc), то
на данный момент у меня нет драйверов :-(.
<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p3">
	  <h4> 3.Редактирование записей.</h4><pre>

	При входе в BDBFS программа находится в режиме VIEW. Для входа
в режим редакции надо нажать на Enter в выбранном поле, тогда Вы
получаете практически Browse FoxPro, т.е. доступны клавиши вверх, вниз,
PgUp,PgDn,Tab,Shift+Tab. Кроме того, BDBFS переходит в режим BROWSE
при нажатии любой "простой" клавиши в зависимости от типа поля. Например,
при нахождении курсора в поле типа Numeric, переход в редакцию
произойдет по нажатию любой цифры, причем эта цифра сразу отображается.
Для выхода из режима Browse надо нажать Escape или Ctrl+W.
В отличие от FoxPro(dBase), для редактирования memo-поля специальной
клавиши нажимать не нужно.

	Существуют четыре режима ввода в Browse - в обычном("Usual")
нажатие Enter в последнем поле записи просто останавливает ввод;
в режиме "Enter/skip" в этом случае происходит переход на первое
поле следующей записи; в режиме "Lock Enter" нажатие Enter в любом
поле приводит к спуску на запись ниже в том же поле. В режиме
"Enter/stop" после нажатия Enter происходит переход к режиму VIEW.
Режимы можно переключать во время ввода.

	Кроме режима Browse существует режим Edit с "разворотом"
записи по вертикали. В него можно перейти из режима View, нажав
	Alt+E(dit).
	Иногда удобно отредактировать символьное поле, превышающее
размер экрана, как memo-поле. Это можно сделать по нажатию клавиши
	Alt+W(ide).

	Может быть осуществлен откат изменений (по клавише Ctrl+U, Alt+BS)
при редакции текущей базы. Размер буфера откатов задается в
переменной _UndoSize и может быть в пределах от 0 до 4095 действий (по
умолчанию - 1024). Все глобальные изменения базы (PACK, ZAP, etc)
приводят к очистке буфера.

<center>
<form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p4">
	  <h4> 4.Режимы Replace.</h4><pre><pre>

	BDBFS поддерживает три режима Replace в текущем поле:
		- константным выражением (Alt+F4)
		- переменным выражением  (Ctrl+F4)
		- в текущей записи	 (Alt+R)

	Разницу между Alt+F4 и Ctrl+F4 поясним на примере.

	Пусть мы стоим в поле NUM на 15 записи. Теперь задаем
выражение замены Recno()+2 и условие - все записи.

	Теперь по Alt+F4 во всех записях будет внесено значение 17,
а по Ctrl+F4 - соответственно 3,5,7..

	Могут спросить: а зачем нужен Repl в текущей записи, можно ведь
просто зайти и исправить? Но представьте, что у Вас в поле стоит
3242756 и его надо умножить на 234. По Alt+R все просто - Field*234.

	Если при вызове функций замены держать нажатым Shift (например,
Ctrl+Shift+F4), то на каждой записи, подлежащей замене, будет запрошено
подтверждение (с показом текущей и предполагаемой величины поля). Это
особенно удобно при замене переменным выражением.


<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a NAME="p5">
	  <h4> 5.Append/Copy.</h4><pre>

	По клавише F3 просто добавляется пустая запись, Alt+F3 предлагает
скопировать содержимое текущей или последней записи.

	Можно также нажать F3 в режиме Browse, тогда будет образована
новая запись со скопированным текущим полем.

	Можно также сделать Append из файла (Ctrl+F9), причем если в
имени файла указано расширение не .DBF, то будет сделан запрос на тип
присоединяемого файла: SDF,WITH DELIMITERS,DBF. То же относится и к Copy
File (Ctrl+F3).

	Можно сделать Append из "самого себя", при этом будет задан
дополнительный вопрос.

	При присоединении могут возникать конфликтные ситуации двух
типов: несовпадение типов полей и числовое переполнение. До версии
BDBFS 1.07 при обнаружении таких ситуаций такие поля оставались
незаполненными. Начиная с версии 1.07 было принято (спорное) решение
о максимальном выполнении операций. Это означает, что:
	при несовпадении типов полей будет выполнена попытка
преобразования;
	при числовом переполнении в поле будет записано максимально
возможное число.Так, если длина поля в текущей базе=3, а присоединяемое
число=1200, то будет записано 999.

	При копировании файла можно указать только требуемые поля
(вручную или подобрав их по Alt+F2).

	Доступно также преобразование и переименование полей
при копировании (в базу, но не в SDF). Это своего рода мини
Query By Example. Например, вы можете задать выражения
в списке полей:
	Num,Num*2 AS Double,Upper(Char),CTOF(Char) AS Shifr

	Если в выражении поля задано ключевое слово "AS", то поле в
новой базе будет названо так, как Вы попросите (Num*2 AS Double -
поле в копируемой базе будет называться DOUBLE).  Если целевое поле не
названо (слово AS не употреблено), то поле будет названо Exp_??, где ?? -
порядковый номер в списке (аналогично FoxPro).  Если выражение не может
быть вычислено, оно игнорируется. См. также описание <a href="#pp4dbtrans">функции DBTrans().</a><a><pre>

	Можно также скопировать(преобразовать) базу в формат HTML.
Эта операция доступна через меню Файл -> Создать HTML. См. также описание
<a href="#pp4tb2html">функции Tb2Html().</a>

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p6">
	  <h4> 6.SUM.</h4><pre>

	Суммирование всегда происходит по текущему полю, в т.ч.
можно выбрать и вычисляемое поле (см.ниже).
	Суммировать можно по числовому или символьному
полю(т.е. SUM( VAL(field) )). Подразумевается, что Вы знаете, что делаете.
	Можно использовать и функцию Sum(см.ниже).

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p7">
	  <h4> 7.Поиск по индексу(тэгу).</h4><pre>

	При поиске по индексу типа DATE не обязательно писать CTOD.
Так, одинаково правильно
		12/03/93  CTOD('12/03/93')  DATE()

	При поиске по индексу символьного типа значение надо заключать
в кавычки. Впрочем, если выражение поиска начинается с цифры или символа
с кодом более 127, то кавычки не обязательны.

	По умолчанию поиск ведется в режиме SoftSeek OFF
(SET NEAR - для привычных к FoxPro). Чтобы задать режим SoftSeek ON
надо сделать
		{Alt+G} Set(9,.t.)	// см. Set.CH,
или задать =Set(9,.T.) в ini-файле.

	Иногда бывает нужным найти неуникальные записи в индексе.
Это можно сделать с помощью клавиши Alt+2. Курсор при этом установится
на дублирующую запись.

	Доступен также поиск по маске (естественно, в индексе символьного
типа). Правила задания маски аналогичны DOS.  Например, можно задать:

	{Alt+[} 'B?LL',		// Найдено: BILL
	{Alt+Shift+[}		// Продолжили и нашли: BYLL

	{Alt+[} "*МОСКОВС*"	// Найдено: МОСКОВСКАЯ ПЛОЩАДЬ
	{Alt+Shift+[}		// МОСКОВСКАЯ УЛИЦА
	{Alt+Shift+[}		// ПРОСПЕКТ МОСКОВСКИЙ

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p8">
	  <h4> 8.Выражения условий.</h4><pre>

	При выборе многих функций BDBFS, у Вас будет запрошено
условие отбора или поиска. Варьировать выражения в таких условиях
можно достаточно широко. Могут быть применены любые как системные,
так и пользовательские функции. Единственное ограничение - длина
выражения(не более 255 символов).

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p9">
	  <h4> 9.Set Fields.</h4><pre>

	По Ctrl+F2 Вы можете задать содержание, названия и порядок
полей. Содержанием поля может быть любое допустимое выражение.
	В названии допустимы символы нац.алфавитов, причем эти названия
будут выводиться и при печати.

	<font color=magenta>Пример:</font>
		Содержание поля: IS+DOS-KOS
		Название: Исходящий остаток

	Для поля также может быть задан шаблон вывода и печати (picture).
Например, 999,999.99. Форматы шаблонов можно посмотреть в документации
к любому xBase. Кроме того, можно принудительно установить ширину поля.
Обычно это имеет смысл, когда ширина данных поля значительно меньше
ширины заголовка.

	При пометке поля, как удаленного, оно блокируется для вывода и
редакции. При помощи клавиш F8/F7 можно блокировать/разблокировать сразу
все поля, начиная с текущего.

	Установка нужного порядка полей осуществляется при помощи
Ctrl+Up или Ctrl+Down (обмен полей местами).

	Завершить изменения можно клавишей F10. Наблюдайте результат.
Если затем вновь нажать Ctrl+F2, будет восстановлено исходное состояние
базы.

	Вычисляемые поля редакции не подлежат (при переходе на такое поле
курсор не виден). Тем не менее, их можно использовать в выражениях.

	Требуемый порядок и содержание полей можно устанавливать
последовательно. Предположим, мы убрали из просмотра поле F2. Нажали
F10. Посмотрели и решили, что не хотим видеть и поле F3, а не только F2.
Последовательность действий: Ctrl+F2 (восстановили все поля), снова
Ctrl+F2, затем F5 и получаем предыдущие установленные поля. Правим
дальше,etc.

	На Copy File Set Fields влияние не оказывает.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p10">
	  <h4> 10.Вычисление выражений.</h4><pre>

	По нажатию Shift+F6(Alt+G(o),?) можно подсчитать почти любое
корректное Clipper выражение длиной до 255 символов. Не говоря уж о
том, что частенько нужно вспомнить н-р, какое число было Date()-21
или быстренько взять Log(Exp(1)) :-), получился довольно интересный
тренажер Clipper-иста. Можно, например, поэксперементировать
с параметрами Memoedit, понять, наконец, чем отличается Bin2i от Bin2w
или поинтересоваться, что такое Descend('rs|Аpd').

	Можно использовать почти все функции из Clipper.Lib и Extend.Lib,
ряд полезных (на мой взгляд) функций известных библиотек
Six3,NanFor,Clipper Tools,Netto,Blinker, эмуляцию некоторых функций
FoxPro, а также ряд специальных функций BDBFS.
	Список функций приведен <a href="#pp4">в Приложении IV.</a>

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p11">
	  <h4> 11.Задание переменных.</h4><pre>

	По Ctrl+F5 вы можете проинициализировать переменную (или
задать ей новое значение).

	Для простой переменной нужно просто выполнить присвоение

		new=5
		word:='папа'
		today=date()

	Для объявления массива его надо описать:

		arr[20] или arr=Array(20)

	Затем уже можно сделать Arr[3]=Exp(12.09).
	Впрочем, можно и прямо написать: Arr={10,20,'пример'}

	В правой части допустимы любые верные Clipper выражения.

	Зачем все это нужно ?

	Иногда удобно вычислить выражение, а потом его использовать
в условиях или Replace. Используя присвоение переменных и вычисление
выражений можно даже писать небольшие программки. Попробуйте, н-р, сделать
следующее:
	{Ctrl+F5}	aPrg=Array[Adir('*.prg')]
	{Alt+G}		Adir('*.prg',aPrg)
	{Alt+G}		ForAch(5,10,24,'Программы',aPrg)

	У вас в директории есть индекс, который имеет нестандартное
расширение.

	{Ctrl+F5}	_oldind='MyOwn.FIL'
	{Ctrl+F5}	_req=0

	Нужно выбрать базу из резервных копий.

	{Ctrl+F5}	_mask='*.bak'
	{F4}

	Хотите напечатать базу мелким шрифтом и с лозунгом.

	{Ctrl+F5}	_PSCode='Б У Д Ь М О !!!'+chr(15)
	{F2}

	Можно присвоить блок кода

	{Ctrl+F5}	bck={|i|i+1}	, затем
	{Alt+G}		Eval(num)

	И вообще: была бы возможность, применение найдется.
	Несколько примеров есть в Examples.Ini.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p12">
	  <h4> 12.Модификация структуры.</h4><pre>

	После изменения структуры предыдущая версия остается с
расширением BAK. Если существовал memo-файл, то он остается
с расширением TBK.

	Если при модификации возникает ситуация числового переполнения,
то в поле будет занесен 0.

	В программе реализован известный Clipper-истам трюк - образование
символьных полей с длиной более >255 символов. Это делается так: в поле
Field_Dec записывается Mod(L,256), в поле Field_Len - остаток. Например:
длина поля 700. Тогда Field_Dec=2, Field_Len=188. Но чтобы ввести нужную
длину в BDBFS достаточно исправить Field_len. Нужные величины будут
занесены автоматически.

	По клавише F9 (кроме драйвера SIXMDX) вызывается функция
оптимизации структуры. Она проводится с использованием VariField полей
по следующим правилам:
	- символьные поля с длиной > 16 преобразуются в формат V10;
	- MEMO поля преобразуются в формат V6 (ZeroField);
	- числовые поля с длиной от 5 до 10 байт преобразуются в
	  формат V4 (Integer);
	- поля даты преобразуются в формат V3.

	Могут быть заданы поля, названные не-по-английски.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p13">
	  <h4> 13.Вставка записи.</h4><pre>

	Как известно, Clipper операции INSERT не имеет. Но иногда очень
хочется. Поэтому приходится идти тяжким путем:APPEND, сдвинуть все вниз,
очистить верхнюю. На больших базах это может быть долго. При
включенном индексе или тэге INSERT не работает.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p14">
	  <h4> 14.TOTAL.</h4><pre>

	Есть некоторые отличия команды TOTAL в BDBFS и в Clipper:

	- в качестве выражения ON всегда принимается текущий
	  индекс/тэг;
	- не поддерживается TOTAL без установки индекса/тэга
	  (в отсортированной базе);
	- в целевую базу копируются все поля (в Clipper memo-поля
	  исключаются);
	- если существует поле TOTALCOUNT, то в него будет
	  записываться количество подсуммированных записей по
	  каждому ключу;
	- не поддерживаются поля заданные через alias (а зачем?).

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p15">
	  <h4>15.Сохранение/восстановление окружения.</h4><pre>

	Вы можете определить любые переменные, задать условия поиска и
суммирования, определить индекс и необходимые поля и проч., а затем
сохранить все это в обычном memo-файле, нажав Shift+F1.
	Если затем нажать Shift+F5 и задать имя этого файла, все
окружение, включая используемый DBF, будет, по-возможности,
восстановлено. Мало того, можно сразу загрузить окружение, задав имя
MEM-файла в командной строке. Разумеется, может быть сколько угодно
файлов окружения в каталоге.
	По умолчанию используется файл BDBFS.MEM.
	Если в INI-файле (или непосредственно из программы) определена
переменная _AutoSave:=.T., то в текущем каталоге файл BDBFS.MEM создается
автоматически при выходе.
	Если в INI-файле определена переменная _AutoRestore:=.T. и
BDBFS.EXE запускается без параметров, то файл BDBFS.MEM из текущего
каталога считывается автоматически.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p16">
	  <h4> 16.Инициализационные файлы.</h4><pre>

	Вы можете при загрузке или позже, по нажатию Ctrl+F12, прочитать
содержимое файла инициализации. Файл инициализации представляет
из себя обычный текстовый файл, содержащий присвоение переменных,
а также, возможно, выполнение некоторых функций, мини-программ.
Переменные будут затем доступны в программе.

	Определены следующие операции.


	<h5>A.Присвоение.</h5><pre>

	Синтаксис:
		&lt;var&gt;:=&lt;expression&gt;		или
		&lt;var&gt; = &lt;expression&gt;		или
		#define &lt;var&gt; [&lt;expression&gt;]

	<font color=magenta>Примеры:</font>
		MyVar=100
		MyVar := 100
		MyVar=Sqrt(4)
		#define MyVar 100

	В случае #define, в отличие от include файлов Clipper и C,
переменные будут объявлены и доступны не только во время чтения файла
инициализации. Если в define опущено &lt;expression&gt;, оно принимается равным
.T. .
	Полезным может оказаться задание в ini-файле блоков кода.
Позже их можно будет вычислять, обращаясь как к функции.

	<font color=magenta>Пример:</font>
	// в ini-файле
		Squart = {|i|  'Площадь круга радиуса '+STR(i,3)+;
				' = '+LTRIM(STR(3.1415 * i * i,16,2))}

	// в программе
		{?} Squart(4)		или
		{?} Eval(Squart,4)


	<h5>B.Вычисление функции без присвоения переменной.</h5><pre>

	Синтаксис:
		=&lt;expression&gt;	или
		&lt;expression&gt;

	<font color=magenta>Пример:</font>
		=Tone(440,3)
		Eval(bEval, 100)

	Использование формы с начальным символом "=" обязательно если
символ "=" есть и в самом выражении. В остальных случаях операторы
эквивалентны
		=Devout('S='+S)		// Обязательно с первым =


	<h5>C.Включение вторичного файла инициализации.</h5><pre>

	Синтаксис:
		#include &lt;FileSpec&gt;

	&lt;FileSpec&gt; может включать путь и/или расширение (по умолчанию -
.ini). Если путь не задан, то файл будет искаться последовательно в:
	- текущем каталоге
	- каталогах, определенных глобальной переменной _PlugDir (по
	  умолчанию - каталог bdbfs.exe\PLUGINS)
	- в каталогах, определенных переменной окружения SET INCLUDE.

	<font color=magenta>Примеры:</font>
		#include second.ini
		#include 'second'
		#include c:\my\second.ini

	Поскольку поддерживается операция #define, то можно включать
стандартные клипперовские файлы определений, такие, как inkey.ch, Set.ch.
Надо только иметь в виду, что #define с параметрами не поддерживается.

	Вниманию клипперистов и С-онистов: имя файла можно задавать без
кавычек.


	<h5>D.Определение команды.</h5><pre>

	Синтаксис:
		#xcommand &lt;matchPattern&gt; => &lt;resultPattern&gt;

	<font color=magenta>Примеры:</font>

	  #xCommand INVERT =>;
		DBEval({||Rlock(), IF(DELE(),dbRecall(),dbDelete())})

	  #xCommand MODIFY COMMAND &lt;x&gt; => ModiFile(&lt;x&gt;)

	  #xCommand EOM(&lt;x&gt;) => FT_LDAY(&lt;x&gt;)

	В отличие от команд препроцессора Clipper, поддерживается только
один параметр (или отсутствие параметров).

	Наиболее естественно применять команды из вычисления выражений,
<font color=magenta>Например:</font>
		? INVERT


	<h5>E.Определение локальной таблицы команд.</h5><pre>

	Синтаксис:
		#LOCALTABLE

	Команды (определенные оператором #xcommand) занимают определенное
место в памяти и несколько замедляют выполнение операций вычисления (так
как для каждого выражения проверяется подстановка). Поэтому может
оказаться полезным держать в памяти команды только тогда, когда они
реально могут понадобиться.

	<font color=magenta>Пример:</font>
		#LOCALTABLE
		#include MyCmd.ch
		...

	В файле MyCmd.ch определен ряд команд, которые используются в
текущем ini-файле. Предварительное задание #LOCALTABLE гарантирует, что
после завершения интерпретации ini-файла, ресурсы, занятые под эти
команды, будут высвобождены.


	<h5>F.Определение макрокоманд.</h5><pre>

	Синтаксис:
		#MACRO &lt;код клавиши&gt; =&gt; &lt;последовательность нажатий&gt;, или
		#MACRO_IN_[область действия] &lt;код клавиши&gt; =&gt;
					     &lt;последовательность нажатий&gt;

	Последовательность нажатий может быть задана либо как символьная
строка(формат KEYBOARD), либо как массив кодов(формат INKEY). Во втором
случае можно задать функциональные и расширенные клавиши, но длина
последовательности до 16 нажатий (см. описание устройства буфера клавиатуры).

	Могут быть заданы следующие модификации области действия
макрокоманды:
		#MACRO_IN_BROWSE - основной режим,
		#MACRO_IN_DIALOG - режим задания условий, списка полей,
		#MACRO_IN_FIELD  - режим коррекции поля,
		#MACRO_IN_MEMO   - режим редакции MEMO и текстовых файлов.

	Если область действия не указана, макрокоманда действует всегда.


	<font color=magenta>Примеры:</font>
		#MACRO 307 =&gt;  {-9,'ч','5'}
		;банковские функции через меню на Alt+Б.

		#MACRO_IN_FIELD 308 =&gt;  'Это будем частенько нажимать при
		редакции'
		;на Alt+>

		#MACRO_IN_DIALOG 383 =&gt; 'Like("*",&_C_F)'+REPL(CHR(19),9)
		;На Alt+* удобное задание шаблона для поиска


	<h5>G.Объявление локальных переменных.</h5><pre>

	Синтаксис:
		#LOCAL &lt;v1&gt;,&lt;v2&gt;...	или
		LOCAL &lt;v1&gt;,&lt;v2&gt;...

	Переменные, объявленные таким образом будут автоматически
освобождаться по завершению интерпретации ini-файла.

	<font color=magenta>Пример:</font>
		#LOCAL cFile, nSum

	В отличие от программ Clipper нельзя делать немедленное
присвоение, то есть неверно

		LOCAL cFile:="MyFile"


	<h5>H.Аварийное прекращение интерпретации.</h5><pre>

	Синтаксис:
		#BREAK	или
		#BREAK &lt;условие&gt;

	Если задан #BREAK без параметров, интерпретация немедленно
прекращается, в противном случае, выход происходит при выполнении условия.

	<font color=magenta>Пример:</font>
		#BREAK !FILE("NeedFile")


	<h5>I.Параметры и возвращаемые значения.</h5><pre>

	Инициализационному файлу можно передать до 10 параметров, при
интерпретации они будут доступны через идентификаторы _1.._10
соответственно.
	Если ini-файл должен вернуть какое-то значение, необходимо
определить оператор #RETURN.
	Синтаксис:
		#RETURN &lt;expression&gt;	или
		RETURN &lt;expression&gt;

	<font color=magenta>Примеры:</font>
		#RETURN 4
		#RETURN _1*_2

	Вызов ini-файла с параметрами и возвратом необходимо
организовывать через вычисление или пользовательское меню:

		{?} RestoreIni("MyPlug",par1,par2)

	Можно также использовать вложенный вызов непосредственно из
ini-файла:
		MySqrt:=RestoreIni("Sqrt.prb",32.1,3)

	Начиная с версии 1.21 можно использовать и прямой вызов ini-файла
как функции:
		{?} MyPlug(par1,par2)

	Единственное ограничение при этом - ini-файл должен иметь
расширение ini, что необязательно в случае использования RestoreIni().

	Оператор #RETURN не заканчивает программу немедленно, а только
присваивает возвращаемое значение.


	<h5>J.Ветвление по условию.</h5><pre>

	Синтаксис:
		#IF &lt;условие>	(или IF &lt;условие>)
			...
		#ELSE		(или ELSE)
			...
		#ENDIF		(или ENDIF)

	Аналог обыкновенного IF. Допускается вложенность до 10
операторов #IF в одном ini-файле. Объявления с символом # и без него
можно смешивать.

	<font color=magenta>Пример:</font>

	#IF Continue("Do you want to make something?")
		...
		операторы, этот самый Something осуществляющие
		...
	#ELSE
		Nfind("May be next time...")
	#ENDIF


	Частный случай оператора #IF - это операторы #IFDEF, #IFNDEF,
часто использующиеся в include-файлах для предотвращения повторной
загрузки файла.

	<font color=magenta>Примеры:</font>

	// из set.ch Clipper
	#ifndef _SET_CH
		... объявления констант

		#define _SET_CH
	#endif

	// из plugins\clipper.ch
	#IFDEF _CLIPPER_CH
		#BREAK		// если уже читали - сразу выйдем
	#ENDIF
	...
	#DEFINE _CLIPPER_CH

	В операторах #IFDEF, #IFNDEF символ # обязателен.


	<h5>K. Цикл WHILE</h5><pre>

	Синтаксис:
		#WHILE &lt;условие&gt;	или  WHILE &lt;условие&gt;
			...
		#ENDW[hile]		или ENDWHILE или #ENDDO или ENDDO

	Аналог обыкновенного WHILE. Допускается вложенность до 10
операторов #WHILE в одном ini-файле.

	<font color=magenta>Пример:</font>

	sum:=0
	#WHILE !EOF()
		sum:=sum+FieldGet(1)+FieldGet(2)
		DBSKIP()
	#ENDWHILE

<hr>

	Для организации циклов в ini-файлах можно также воспользоваться
функциями For() и While() - <a href="#pp4for">см. приложение IV.</a><a><pre>
Использование функции While() по сравнению с оператором #WHILE менее
наглядно, но дает значительный выигрыш в скорости.

	Инициализационные файлы, аналогично (#include) ищутся помимо
текущего каталога в пути, определенном переменной _PlugDir, а
затем в пути, заданной переменной окружения SET INCLUDE.

	В демонстрационном файле Examples.ini и в каталоге PLUGINS
содержится много различных примеров. См.также <a href="#p32">п.32.</a><a><pre>

	При старте программы всегда делается попытка считать файл
BDBFS.INI, находящийся в каталоге запуска BDBFS.EXE. Если файл
инициализации не задан в командной строке то затем делается попытка
считать файл BDBFS.INI, находящийся в текущем каталоге (при его отсутствии
ищется BDBF.INI - для совместимости c предыдущими версиями BDBF).

	Начиная с версии 1.13 дополнительно могут быть заданы
инициализационные файлы, считываемые при открытии соответствующей базы
(AutoOpen файлы). Такой файл должен иметь расширение .AOP и может
содержать команды, меню <a href="#p30">(см. п.30),</a><a><pre> переменные,
специфичные для данной базы. Кроме того, может быть задан список
и/или названия полей, а также формат их вывода.
Список полей должен быть задан как массив с именем Fields,
список названий - как массив с именем Heads,
список форматов - Pictures, список "ширин" полей - Widths.
Могут задаваться и вычисляемые поля. Если для поля не задано имя,
формат, ширина, используются умолчательные величины.

<font color=magenta>Пример:</font>
	Fields:={'Char','Num','Num*2'}
	Heads:={'Строка','Число','Двойное;число'}
	Pictures:={, '999,999.99'}
	Lens:={7,,,}

	В AutoOpen файлах можно хранить и другие полезные инструкции,
для успешного применения которых желательно изучить <a href="#pp4">Приложение IV.</a><a><pre>
Так, например, можно заставить базу открываться с уже установленным тэгом.
Для этого можно написать __TagNom:=NN, где NN - номер нужного тэга,
или __TagName:='CC', где CC - имя нужного тэга.

	Вы можете интерактивно задать нужные поля (через Ctrl+F2),
установить активный тэг или индекс, а затем сохранить всё это в AOP-файле
по Ctrl+Shift+F1.

	Вызов ini-файла из программы (например, через Ctrl+F12) приводит к
принудительному переоткрытию текущей базы. Если Вы этого не хотите, в
любом месте ini-файла необходимо определить переменную
	lNoReOpen:=.T.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p17">
	  <h4> 17.Макроклавиши.</h4><pre>

	По нажатию Ctrl+F1 вызывается последовательность символов,
запомненная в переменной _MACRO. В режиме просмотра эта возможность
работает как Set Key, в редакции - как Set Function.

	<font color=magenta>Пример:</font>

	{Ctrl+F5} 	_Macro=chr(4)+chr(4)+chr(13)

	Теперь, в режиме просмотра, по Ctrl+F1 вы войдете в редакцию поля
CurrentField+2

	{Ctrl+F5}	_macro='Bravo !'

	Теперь, в режиме редакции, по Ctrl+F1 в поле будет записан текст
Bravo !

	Это удобно, когда надо в интерактивном режиме занести во многие поля
сходную информацию.

	В режиме редакции дополнительно определены следующие макросы:
		Alt+(	=	() и курсор внутри скобок
		Alt+)	=	() и курсор снаружи
		Alt+{	=	{}
		Alt+"	=	[]
		Alt+A	=	.AND.
		Alt+O	=	.OR.
		Alt+B	=	{||}
		Alt+C	=	CTOD("//")

	Это особенно удобно при задании выражений условия.

	Можно определить и свои макроклавиши:

		{Alt+G} __SetFunction(&lt;код клавиши&gt;,&lt;macros>),
	или с помощью команды #MACRO в ini-файле <a href="#p16">(см.п.16).</a><a><pre>
	Кроме того, в режиме редакции доступны "горячие" клавиши
преобразований текущего фокуса ввода (такие же действуют и в BROWSE):
		Alt+U	= UpperCase
		Alt+L	= Lower
		Alt+K	= Capitalize (Proper)
		Alt+Q	= QWERTY-&gt;ЙЦУКЕН (если вы случайно набрали что-то
			  в "английской" раскладке вместо "русской").
		Alt+Y	= наоборот.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p18">
	  <h4> 18.Выход в OS.</h4><pre>

	При выходе в DOS (Alt+F10)  BDBFS занимает в памяти 8k.

	Если Вы хотите прямо запустить из под BDBFS большую программу,
можно воспользоваться функцией

	{Alt+G} BliRun('FoxPro').

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p19">
	  <h4>19.Использование мышки.</h4><pre>

		В режиме просмотра действуют следующие правила:

	- любая кнопка на строке названия базы = Select Base
	- любая кнопка на строке названий полей = Set Fields
	- любая кнопка на функциональной строке = соответствующей
	  функции (исключение: правая на F10 заканчивает без спроса),
	  в т.ч. и с Ctrl,Shift и Alt
	- любая кнопка на нижней полоске скроллинга - сдвижка на
	  относительную позицию поля в файле
	- любая кнопка в основном пространстве (4-MaxRow()-3 строка) =
	  переход на это поле
	- левая кнопка на том же самом поле = Enter
	- правая - вызов контекстного меню
	- любая кнопка на MaxCol() колонке - сдвижка в файле на
	  относительную позицию.

		В режиме выбора по Achoice (н-р, при выборе индекса):

	 - правая=Escape
	 - левая на верхней рамке = PgUp
	 - левая на нижней рамке = PgDn
	 - левая внутри - первый раз:встать на элемент, второй:выбрать

		В меню и в режиме редакции:

	 - правая=Escape
	 - левая=Enter

		При выводе предупреждающих сообщений - любая=Аникею.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p20">
	  <h4>20.Совместимость с FoxPro.</h4><pre>

	BDBFS умеет смотреть и редактировать файлы FoxPro с memo-полями.
Полностью поддерживаются индексные файлы.

	Как уже отмечалось, в Browse поддерживаются клавиши
Tab,Shift+Tab,Ctrl+T.
	Системные переменные печати и количества обработанных записей имеют
те же названия, что и в FoxPRO.
	В выражениях можно использовать почти все функции FoxPro,
не связанные с экранными (Screen,Menu) и печатными формами.
	Обеспечивается правильность блокировок в сети.


	Существует "языковая" проблема в BDBFS, связанная с разницей
в диалектах Clipper и FoxPro.
	Существует CDX, одноименный с базой(а это чаще всего).
	В этом CDX есть тэг, созданный с помощью некорректного (с точки
зрения CLIPPER, но не FOXPRO) выражения. В этом случае SIX-драйвер
отказывается работать с таким CDX вообще, с сообщением об ошибке в
выражении. BDBFS же работу продолжает, но индексы не открыты.  Где
возможно, надо такие тэги заменить на корректные.

	Если в текущем каталоге есть файл EUROPEAN.MEM, он считывается
при старте.

	Поля типа GENERAL и все новые типы Visual FoxPro поддерживаются
в форсированном режиме <a href="#p34">(см. п.34).</a>

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p21">
	  <h4>21.Работа в сети и мультизадачных системах.</h4><pre>

	Все файлы открываются в режиме совместного использования для
записи, что позволяет различным процессам использовать одну и ту же базу.
	Проверки проводились в сети NOVELL и в сессиях WINDOWS,OS/2,DV.

	Гарантируется совместная работа с xBase приложениями,
использующими стандартный режим блокировок. Не гарантируется совместная
работа, н-р, с Dbview от Norton-a.

	BDBFS самостоятельно отдает TimeSlice, так что при работе в
многозадачных системах нет необходимости в посторонних программах
типа TAME.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p22">
	  <h4>22.Обработка ошибок.</h4><pre>

	Вообщем-то, предпринято немало мер к тому, чтобы неправильные
действия не завершали полностью работу. Кроме того, ряд возможных
конфликтных ситуаций обходятся до их возникновения.

	Все же ошибки программы не исключены.
	В этом случае BDBFS рисует рамочку и пишет что-то вроде
		"Неверное выражение	трам-тарарам "
Большая просьба: запишите это трам-тарарам и сообщите автору.
Но имейте в виду, что такое сообщение может возникнуть и в результате,
н-р, Вашего неверного ввода выражения, тогда надо просто поправиться.

	Существует, однако, ряд невосстанавливаемых ошибок, н-р,
"Disk full". Возникнуть она может, например, при копировании файла
(проверить заранее трудно, т.к. неизвестно, сколько места займет файл,
отобранный по условию).

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p23">
	  <h4>23.Выражения цветности.</h4><pre>

	Вы можете выделить цветом в текущем поле записи, отвечающие
определенному условию. Например,

		{Alt+B} data > date()

	Цвет определяется 6 и 7 парой основного цвета редакции.
Имейте ввиду, что удаленные записи показываются 4 и 5 парой.

	Изменить цвета можно, исправив переменную _bm (см.ниже), через
задание выражений или меню Файл - Установки - Цвета.

	Чтобы снять подсветку (вернуться к стандартным цветам), надо нажать
Alt+Shift+B.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p24">
	  <h4>24. Работа с буфером обмена.</h4><pre>

	В BDBFS поддерживается буфер обмена, который действует и в
режиме View и в режиме Get. Для записи значения текущей ячейки в режиме
View или текущего значения редакции - нажмите Ctrl+Grey+.  Для ввода в
ячейку (при соответствии типов) - Alt+GreyEnter или Ctrl+Grey-.

	 Непосредственно с ClipBoard и текущей ячейкой можно производить
операции <font color=red>	+ - * /</font>
(последние 2, естественно, только с числовыми значениями), нажимая
Alt+соответствующие серые. Посмотреть текущее значение ClipBoard можно
по Ctrl+Enter.

	В режиме редактирования memo-полей доступен вывод из ClipBoard.
Во время вывода результата вычисления, суммирования, etc доступна
запись вычисленного в ClipBoard. Впрочем, можно и прямо в поле.

	Операции занесения в буфер доступны и при выводе результатов
операций.

	Очень удобно пользоваться ClipBoard для задания различных
условий. Например, Вы задали длинное выражение поиска. Запомните
его по Ctrl+. Теперь Вы хотите все записи, удовлетворяющие этому
условию скопировать. Перейдите в диалог копирования и при запросе
условия нажмите Ctrl-.

	При работе в win9х (не NT !) доступен и ClipBoard Windows.
Туда (и оттуда) можно скопировать текущее поле. Эти операции доступны
через Ctrl+Ins, Shift+Ins (серые).

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p25">
	  <h4>25.История условий и выражений.</h4><pre>

	Все условия, выражения, списки полей, задаваемые во время сеанса
работы, а также результаты вычислений, суммирования, подсчетов заносятся
в историю, при этом проводится контроль на неповторяемость. Соответственно,
при задании условий и выражений, можно эту историю использовать.
	Клавиша F4 (Ctrl+Down) вызывает историю текущего условия,
		Alt+F4 (Ctrl+Shift+Down) - всех условий,
		Ctrl+F4 - результатов.

Ненужные условия можно стирать при помощи клавиш F8 или Ctrl+D.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p26">
	  <h4>26.Стек позиций.</h4><pre>

	Можно запомнить до 10 позиций(записей) в базе и переходить к ним
по мере надобности. Такая возможность характерна для текстовых редакторов;
не знаю, насколько она будет полезна здесь. Тем не менее, WordStar &
Borland были "ограблены" и по Ctrl+K 0..9 устанавливаются закладки,
восстанавливаемые по Ctrl+Q 0..9. После нажатия Ctrl+K или Ctrl+Q нажатие
0..9 ожидается в течение 20 секунд, затем сбрасывается.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p27">
	  <h4>27.Редакция memo-полей и внешних файлов.</h4><pre>

	Для редакции memo-полей, а также внешних файлов (по нажатию F4
в файлере или через меню "Файл" - "Редактировать текст"), можно
использовать внутренний или внешний редактор. Внутренний редактор
использует стандартный MemoEdit и используется, если не задана (например,
в ini-файле) переменная _MemoEditor. Переменная может быть задана как
строка, например, _MemoEditor:='c:\medit\me.exe' (тогда всегда будет
вызываться MultiEdit) или как массив массивов вида:
	{Маска названия поля,	// н-р "BMP*"
	 Внешний редактор,	// н-р "ME"
	 Смещение в memo-поле,	// по умолчанию 0 - все поле
	 Дополнительные опции,	// по умолчанию отсутствуют
	 Временный файл		// по умолчанию $$BDBF$$.COM
	 }.

	Внешний редактор может быть не задан, тогда предполагается, что в
memo-поле находится программа (например, скрин-сейвер), которая и
запускается на выполнение. Смещение в memo-поле бывает нужно задать,
если, скажем, memo-поле хранит разнородную информацию. Например, база -
пример из поставки Delphi (fish.dbf) содержит поле BMP, в котором сама
картинка хранится с 9 позиции.

<font color=magenta>Пример:</font>
	_MemoEditor:={	{'BMP','pv',9,' /d'},;
			{'SAVER','',0,'','tmp.com'},;
			{'*','ME',0,''};
		     }
	Итак, на поле с названием BMP будет вызываться PV.EXE, поле с
названием SAVER содержит исполняемые программки, а для редакции всего
остального будет вызван MultiEdit.

	Внутренний редактор не может редактировать файлы размером более
64K. Но и при использовании внешнего редактора надо помнить, что
memo-поля формата DBT не способны хранить секции более 64K. Если Ваш файл
имеет большую длину, то при записи его в поле формата DBT он будет
обрезаться.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p28">
	  <h4>28.Печатные формы.</h4><pre>

	Помимо обычной печати по F2, можно использовать специальные
определения для печати форм из любых баз.  Формы хранятся в обычных
текстовых файлах и содержат инструкции для определения колонок,
группировок, суммировок и т.п..

	В печатных формах (файлах-репортах) применяются следующие
переменные:

	_aExpr - массив выражений для каждой колонки.
	_aHead - массив заголовков колонок. Умолчание == _aExpr
	_aElen - массив ширин колонок. По умолчанию принимается
максимальным из ширины поля, ширины заголовка колонки и ширины шаблона
(_aPict) для данного поля. Если ширина выводимого поля больше,
чем ширина колонки, то делается корректный перенос (до 10-и строк на
колонку) по разделителям  пробел, точка, запятая, точка с запятой,
табуляция.

	_aPict - массив шаблонов колонок
	_aTitle - массив заголовка отчета. Умолчание - ничего.
		  Может быть задан как строка или массив строк
	_cFile - файл вывода. Умолчание - имя базы+'.PRN'
	_aSum - массив необходимости суммирования данной колонки
	_fCondit - условие печати
	_aFooter - имя дополнительной процедуры, печатающей подвал или
		   массив, содержащий подвал
	_pEveryStep - имя дополнительной процедуры или блока выполняющейся
перед печатью каждой строки,удовлетворяющей условию _fCondit

	_aGroup - массив, задающий подбивку по группе.
		Структура массива:
		{ &lt;Выражение группирования>,;
		  [&lt;массив или блок для печати заголовка группы>],;
		  [&lt;массив или блок для печати подвала группы>],;
		  [&lt;печать суммы только если в группе более 1 элемента>]
		}.
	Умолчание для заголовка группы: 'Код '+&&lt;Выражение группировки>.
		      подвала группы: 'Всего'.
		      печати суммы: .F. (печатать сумму всегда).

_nDouble - признак необходимости вывода в две колонки на листе.
	   Если 0 или не задан - печатается одна. Если задан числовой
	   параметр - воспринимается как количество пробелов между двумя
	   колонками.

_NoShow - не предлагать файл для просмотра и печати. Это удобно, если
	  нужно задать нестандартную обработку выведенного файла или вывода
	  нескольких автономных частей общего отчета в один файл.

_aPage - массив, задающий подбивку по странице.
	Структура: {&lt;массив или блок для печати заголовка страницы>,;
		    &lt;массив или блок для печати подвала страницы>}.
	Если определен, то печатаются итоги по странице, причем Header
	печатается, начиная со второй.

cDivideT,cDivide - символ разделения колонок соответственно, в
		   заголовке и информационных строках (умолчание - ':').

_nCounter - если >0, то слева выводит порядковый номер шириной _nCounter

CountName - название колонки "Номер по порядку" (умолчание "П/П"). Это
	    имеет смысл только задан _nCounter>0.

_PrintZero - печать нулевых значений, по умолчанию - .F.

	Следующие переменные могут быть дополнительно настроены прямо из
программы (по нажатию F9 в диалоге начала печати).

Печать заголовка на каждой странице	_NeedHeadPage
Печать номеров страниц			_NeedPrPage
Прогон страниц после вывода листа	_NeedEject
Стартовая последовательность принтера	_PSCode
Конечная последовательность принтера	_PECode
Левая граница				_LMargin
Длина страницы (0=лента)		_Plength
Печать стандартного заголовка		_NeedMainHead
Устройство-принтер			_printer
Дописывать ли файл вывода		_NeedApFile


	Файлы - отчеты имеют стандартное расширение .BPF и могут быть
загружены через меню "База" - "Считать файл-отчет".

См. также пример в поставке BDBFS.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p29">
	  <h4>29.Клавишные коды.</h4><pre>

	Нажимая в BDBFS на клавиши, обратите внимание на левый верхний
угол, где высвечивается код нажатой клавиши. Так можно обнаружить
ряд недокументированных в Clipper кодов.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p30">
	  <h4>30.Пользовательское меню.</h4><pre>

	Помимо общего меню, в BDBFS можно определить дополнительное меню
пользователя, доступное по F12. Для этого надо в инициализационном
файле определить два массива: UserMenuPrompts и UserMenuActs. Первый
следует заполнить строчками, предлагаемыми на выбор в меню, второй -
соответствующими блоками кода. Например, Вы хотите иметь возможность
запускать FoxPro из под BDBFS. Тогда в BDBFS.INI надо записать:
	UserMenuPrompts:={'Запуск FoxPro'}
	UserMenuActs:={ {||BluRun('Fox.exe')} }.

	Несколько примеров есть в Examples.Ini.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p31">
	  <h4>31.Проверка/коррекция базы.</h4><pre>

	Меня долго просили (а я упирался) сделать логический контроль
соответствия размера базы заголовку. Упирался я потому, что не желал
иметь дело с результатами работы кэшей и разнообразных сетевых
приложений. Да и утилит такого рода достаточно. Тем не менее, учитывая
тот факт, что ни одна из просмотренных утилит меня полностью не
удовлетворила, все-таки пришлось "спасаться своими руками" и такая
проверка включена в 1.15. Сверяются 3 размера: логический (на основании
структуры), проставленный в заголовке и реальный физический.  Если все
размеры совпадают, выдается сообщение об отсутствии ошибок.  Иначе будет
показано меню с информацией о расхождениях и возможностью
синхронизировать размеры по одному из них. Рекомендую выбирать
логический, но у Вас, разумеется, может быть свое мнение и причины
предпочесть иное.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p32">
	  <h4>32.Плагины.</h4><pre>

	Ну какой нынче программный продукт без плагинов! Видно, иначе
нельзя! "Плагины" BDBFS - это обычные ini-файлы <a href="#p16">(см. п.16), </a><a><pre>
реализующие законченную функцию. Несколько (возможно даже небесполезных)
примеров есть в каталоге PLUGINS. Присылайте мне плоды Вашего творчества.
Лучшее будет опубликовано на страничке и включено в поставку следующих
версий. С указанием автора, естественно.

	Плагины (и #include) файлы ищутся помимо текущего каталога в
пути, определенном переменной _PlugDir, а затем в пути, заданной
переменной окружения SET INCLUDE.  По умолчанию, _PlugDir=каталог
запуска\Plugins. Вы можете задать (например, в BDBFS.INI) несколько
каталогов:  _PlugDir:='c:\bdbfs\plugins; d:\MyOwn\plugins'

	К плагинам в программе можно обращаться как к обычным функциям,
если они имеют стандартное расширение .INI. Пусть, скажем, у Вас есть
плагин MyPlug.ini, вычисляющий некоторую функцию, основываясь на полях
базы.  Тогда можно делать, <font color=magenta>например:</font>
	{?} MyPlug()			// Вычислить текущее
	{CTRL+F5} xVar:=MyPlug()*2      // Присвоить значение
	{F7} MyPlug() > 100		// Поиск

Плагину можно передать параметры (до 5).

	<font color=magenta>Пример:</font> MyPlug(2,3,'Hello')

Для вызова плагина из плагина, а также в случае, когда плагин имеет
нестандартное расширение, используйте функцию RestoreIni().

	<font color=magenta>Пример:</font> RestoreIni('MyPlug',2,3,'Hello')

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p33">
	  <h4>33.Запуск BDBFS.</h4><pre>

	Обычный запуск - BDBFS <имя файла>[.DBF].

	Можно запустить с параметром * - тогда будут предложены
файлы на выбор. Можно запустить BDBFS *.Str - на выбор будут предложены
файлы с расширением STR. Можно использовать и символ ?.

	Параметр /i=&lt;indexname> задает загрузку файла вместе с указанным
индексом.

	Параметр /BW настраивает цвета на монохром. Впрочем,
на черно-белом EGA/VGA и так видно отлично.

	Порядок параметров /BW и /i= можно чередовать.


	При запуске с параметром-именем файла окружения делается попытка
это окружение восстановить. Аналогично, с файлом инициализации.

	<font color=magenta>Пример:</font>
	 	BDBFS Envr.mem


	Параметры /NTX /CDX /MDX /NSX устанавливают соответствующий
драйвер по умолчанию (обычно он определяется в bdbfs.ini). Можно также
использовать форму /SIX[driver].

	<font color=magenta>Примеры:</font>
		BDBFS MyBase /SIXNSX

		BDBFS MyBase /ntx /i=char


	Параметр /CREATE позволяет начать работу с создания новой базы.

	<font color=magenta>Пример:</font>
		BDBFS MyNew /CREATE

	Кроме того, есть несколько параметров, заставляющих BDBFS работать
в пакетном режиме - REINDEX, HTML, PACK, CHECK, PRINT и разновидности
параметра STRUCT_.  В пакетном режиме BDBFS выполняет заданную операцию и
завершает свою работу.

	Параметр REINDEX вызывает переиндексацию базы. Составной индекс
(CDX,NSX,MDX) переиндексируется автоматически, для переиндексации простого
индекса его надо указать в третьем параметре с ключом /i. Если ни одного
индекса не найдено, то будет выдано соответствующее сообщение.

	<font color=magenta>Примеры:</font>
		BDBFS f_w_cdx REINDEX
		BDBFS f_w_ntx REINDEX /i=MyNtx.ntx


	Параметр HTM (HTML) вызывает генерацию файла HTML.

	<font color=magenta>Примеры:</font>
		BDBFS MyDbf HTM			// генерируется MyDbf.htm
		BDBFS MyDbf HTML=e:\1		// генерируется e:\1.htm

	Предупреждение о существовании файла выдается в любом случае,
так что если Вы желаете принудительно переписать существующий HTML,
сначала уничтожьте его.


	Параметр PACK вызывает упаковку базы. Поскольку операция эта
опасная, дополнительный запрос все равно задается.


	Параметр PRINT вызывает печать файла печатной формы <a href="#p28">(см. п.28).</a><a><pre>
Если имя файла не указано, ищется файл с именем, соответствующим базе.

	<font color=magenta>Примеры:</font>
		BDBFS MyDbf /PRINT=Customer	// ищется Customer.BPF
		BDBFS MyDbf /PRINT		// ищется MyDbf.BPF


	Параметр CHECK вызывает проверку заголовка базы <a href="#p31">(см. п.31).</a><a><pre>

	Параметр STRUCT_ позволяет задать автоматическое выполнение
операций, доступных интерактивно в режиме показа структуры (ALT+F2) через
клавиши F2,F4-F6,F10.
	Разновидности параметра:
		STRUCT_PRINT	- вывод структуры на печать.
		STRUCT_FILE	- файл описания структуры (расширение STP)
		STRUCT_EXTENDED	- файл структуры формата COPY STRU EXTENDED
				  (с расширением STE)
		STRUCT_COPY	- файл-копия структуры (расширение STR)
		STRUCT_PROGRAM	- создание программы, генерирующей эту
				  структуру и тэги компаундного индекса
				  (расширение STG).

	Все постфиксы параметра могут быть сокращены до 4-х символов.

	<font color=magenta>Пример:</font>
		BDBFS MyDbf /STRUCT_PROG


	Параметр /FORCED запускает форсированный режим <a href="#p34">(см. п.34).</a><a><pre>


	Для работы с каталогом можно применять команду FOR.

	<font color=magenta>Примеры:</font>
// все переиндексировать
		FOR %%a in (*.DBF) DO bdbfs %%a REINDEX

// создать HTML в подкаталоге _HTMLS_
		echo y | DEL _HTMLS_\*.HTM
		FOR %%a in (*.DBF) DO bdbfs %%a HTM=_HTMLS_\%%a
		REN _HTMLS_\*.DBF _HTMLS_\*.HTM

Счастливые обладатели 4DOS могут сэкономить команду (и время):
		DEL /y _HTMLS_\*.HTM
		FOR %a in (*.DBF) DO bdbfs %a HTM=_HTMLS_\%@NAME[%a]

// Создать документацию по базам данных
		FOR %%a in (*.DBF) DO BDBFS %%a /STRUCT_FILE
		ECHO Документация по базам данных системы > All_Dbf.txt
		FOR %%a in (*.STP) DO COPY All_DBF.TXT+%%a All_Dbf.TXT
		DEL *.STP

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p34">
	  <h4>34. Форсированный режим.</h4><pre>

	Стандарт файла DBF существует уже очень давно. Уже вскоре после
принятия выявились его ограничения, особенно это касалось MEMO-полей, да
и бинарную информацию хотелось хранить и использовать более эффективно.
Не мудрено, что начали появляться всевозможные расширения формата, такие
как FPT файлы FoxPro, Varied поля и криптованные базы SIX и т.д.. Причем,
в последнее несколько лет процесс ускорился, а взаимное "непонимание"
углубилось (несмотря на реализованную в Clipper правильную по сути идею
RDD). В частности, существующие стандартные и SIX-овские драйверы не
позволяют обрабатывать новые конструкции Visual FoxPro, dBASE5, FlagShip
и т.д.. Существуют также программы, позволяющие "обозвать" поля
нестандартным способом (например, начинающиеся с цифры).

	Всё это привело меня к мысли написать программу, позволяющую "на
лету" приводить нестандартные файлы к стандартным, а после завершения
работ - править "обратно". Такой режим и будем называть "форсированным".

	Итак, в форсированном режиме BDBFS понимает и поддерживает
следующие форматы:

	- Visual FoxPro (поля типа Currency, DateTime, General,
Picture, Integer, Double, новый формат memo-полей, новый заголовок);
	- dBASE4, dBASE5 (поля типа Bitmap, новые заголовки);
	- FlagShip (поля типа 2,4,8, новые заголовки);
	- FoxBase 1.0 (заголовок);
	- FlexMemo (memo-поля);
	- и, потенциально, все другие возможные типы полей, которые
в этом случае будут считаться и обрабатываться, как символьные.

	Нестандартные названия полей преобразуются следующим
образом:
	- если в заголовке указан CodePage FoxPro от 1200 до
	  1299, то выполняется AnsiToOem()
	- неалфавитно-цифровые символы заменяются на символ "_"
	- если название начинается с цифры, то оно предваряется
	  символом "_".

	Форсированный режим можно также применять для обработки баз,
содержащих memo-поля длиной более 64K, так как использование стандартных
драйверов приводит в этом случае к внутренней ошибке Clipper.

	На сегодняшний день действуют следующие ограничения для работы
в форсированном режиме:

	- база используется только в монопольном режиме (напомню, ее
	  приходится для этого специальным образом исправлять);
	- если "форсированная" база содержит memo-поля, запрещена
	  упаковка;
	- запрещена модификация структуры;
	- в memo-поле можно записать строку до 64K и стандартный
	  способ SX_Blob2File/SX_File2Blob не работает.


	Форсированный режим включается либо указанием ключа командной
строки /FORCED (например, bdbfs mybase /forced), либо указанием
переменной _lForced:=.t. в инициализационном файле.

	Для доступа к некоторым "нестандартным" типам полей (например, при
использовании в выражениях, при поисках) нужно использовать специальные
функции (обычные редакция, просмотр, замещение дополнительных усилий не
требуют):
	- содержимое memo-поля, полей типа picture, bitmap
		MemoSrc(&lt;field_name>) - возвращает строку
	- поле типа Currency
		YToCurs(&lt;field_name>) - возвращает число
	- поле типа DateTime
		TToC(&lt;field_name>) - возвращает строку
	- поле типа Binary
		CToF(&lt;field_name>) - возвращает число
	- поле типа 2
		Bin2I(&lt;field_name>) - возвращает число

	<font color=magenta>Пример:</font>
// Установить фильтр для поля Cur1 типа Currency
	   {Alt+F} YToCurs(Cur1)>100


	Еще раз напомню, для обработки базы в форсированном режиме,
приходится исправлять её заголовок! Поэтому, если во время работы,
например, мигнет свет, или, скажем, Вы по ошибке прибили сессию, то
структура базы будет испорчена! В случае с Visual FoxPro даже весьма
существенно!
	<font color=red>ПОЭТОМУ, ИСПОЛЬЗУЙТЕ ЭТОТ РЕЖИМ НА СВОЙ СТРАХ И РИСК!</font>

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p35">
	  <h4>35.Видео-режимы.</h4><pre>

	BDBFS корректно поддерживает все ранее установленные текстовые
режимы - от 40*25 до 132*60 и т.д.. Однако, если Вы запустили из под
BDBFS программу, изменившую режим экрана - возможны неприятности.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p36">
	  <h4>36.Языковый интерфейс.</h4><pre>

	Может вызвать удивление смешение в сообщениях и Help-ах
русского и английского. Ориентация здесь была такая: то, что стандартно
и адресовано, в основном, программисту - английское, остальное по-русски.
Help Вы можете сами переписать, как вздумается - см.файл BDBFS.HLP.
Каждая главка заканчивается символом ~. Соответственно, его использовать
в тексте нельзя.  В остальном ограничений нет, пишите как сочтете нужным.
Если кто-то удосужится переписать HELP полностью на английском,
украинском или любом другом языке - я буду очень признателен за версию.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p37">
	  <h4>37.Планы.</h4><pre>

	BDBFS уже почти не развивается, во-первых, из-за достаточной
полноты; во-вторых, из-за нехватки времени; в третьих, из-за малого
количества пожеланий :-). Вы можете это исправить :-) ! Естественно,
вышесказанное не относится к портированию на CLIP - тут работы непочатый
край.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p38">
	  <h4>38.Чего в BDBFS нет по сравнению с "конкурентами".</h4><pre>

	Мне приходилось видеть в продуктах аналогичного назначения
некоторые возможности, отсутствующие сейчас в BDBFS.
Вот их перечень:

	* календарь - не вижу смысла,IMHO не ORGANIZER это, но мнения...
	* экспорт/импорт 1-2-3 - IMHO слишком специализировано.
	* Подсчет стат-величин типа девиации и т.п. - аналогично
	  предыдущему пункту. А может быть кто-то плагином сделает.
	* Графики по полям базы - не будет, IMHO это дело спец-программ.
	* Просмотр экрана DOS - может быть...

	Буду благодарен за любые мнения по этому поводу.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p39">
	  <h4>39.Известные проблемы.</h4><pre>

	Помимо вновь обнаруживаемых ошибок, существует ряд известных
проблем, которые, возможно, будут устранены в будущем. К их числу
относятся:

	Поля типа GENERAL FoxPro, типа BMP DBASE4, базы новых
форматов Visual FoxPro, DBASE4, DBASE5, FlagShip, FlexMemo
поддерживаются только в форсированном режиме <a href="#p34">(см. п.34).</a><a><pre>

	Не поддерживается #define с параметрами в ini-файлах.
	Не поддерживается #xCommand с более, чем один параметром.

	Проблемы с индексами MDX (ограничение драйвера):
	 - не доступны номер ключа в индексе и количество записей в
	   фильтре (без подсчета), что отражается на правильности
	   показа индикаторов;
	 - не доступен поиск по маске в индексах;

	Неправильно работает в 2000 году функция LUPDATE() Clipper.

	"Превышение лимита". Из-за ошибки в реализации в Clipper объекта
TBROWSE, показываются не все поля в базе с большим количеством полей.
По умолчанию количество полей, показываемых в BDBFS ограничено 170
(экспериментальный предел у меня на машине составляет 173). Вы можете
поэкспериментировать, задавая в INI-файле переменную _nBrowMaxField.
По сообщениям пользователей, удавалось добиться 210.

	Длинные имена в файлере показываются до 16-символов.

	Невосстанавливаемая ошибка "Переполнение диска".
	Проверить заранее свободное место трудно из-за того, что
неизвестно, сколько места займет скопированный файл.

	Внутренняя ошибка 1112. Возникает на базах с memo-полем длиной
более 64K. Это - глюк Clipper 5.2 (в 5.01 его не было). Можно либо
работать с такими базами в форсированном режиме <a href="#p34">(см. п.34),</a><a><pre>
либо исключать такие поля из просмотра при помощи AutoOpen файлов <a href="#p16">(см. п.16).</a><a><pre>
Доступ к ним во втором случае возможен через функцию SX_Blob2File().

	Индексы FoxPro, содержащие выражения типа alias.field (вместо
alias->field) вызывают ошибку при любой операции, вызывающей изменение
индекса. Даже и не знаю, что с этим делать...

	Некомпактные IDX (FoxBase) не поддерживаются. Желающие могут
воспользоваться специальной версией (BDBFP), которая может быть загружена
с моей странички.

	Не работает поиск в индексах FoxPro, сделанных с установленной
COLLATE.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p40">
	  <h4>40.Благодарности.</h4><pre>

	Nantucket(CA принципиально не буду), American Cybernetics,
Assembler Software, Borland, SuccessWare - за использованные продукты.

	Авторам Софтпанорамы и эхо-конференций.

	Всем  корреспондентам, присылавшим замечания и предложения.

	Особая признательность Кужию Л.Б.(Львов) за тщательное
тестирование и множество дельных предложений.

	Портирование на CLIP было бы невозможно без
<a href="mailto:uri@itk.ru">Юрия Хныкина uri@itk.ru</a>

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p41">
	  <h4>41.Дальнейшие ругательства.</h4><pre>

	Присылать по адресу:
		Луганск,91024, Ленинградская 8,
		Бондарю Евгению Леонидовичу

		[0642] 46-34-19
		  <a href="mailto:elb@lg.bank.gov.ua">E-Mail:elb@lg.bank.gov.ua</a>
 		  <a href="mailto:Bondar_Eugen@yahoo.com">или Bondar_Eugen@yahoo.com</a>

	<a href="http://www.geocities.com/bondar_eugen/bdbfs_ru.htm">Страничка:</a>

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="p42">
	  <h4>42.Форма распространения.</h4><pre>

	BDBFS распространяется в бСССР свободно, причем версия для
CLIP - в исходных текстах. Любое вознаграждение, в т.ч. моральное ;-),
будет принято с благодарностью.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="pp1">
	  <h4>ПРИЛОЖЕНИЕ I.Сводка клавиш.</h4><pre>

	Помните, что ряд функций доступен только через меню.

	<h5>A.Главный режим.</h5><pre>

<h6>Позиционирование:</h6><pre>

	Up Down Left Right PgUp PgDn

	На последнее поле	Ctrl+End
	На первое поле		Ctrl+Home

	Go top			Ctrl+PgUp
	Go Bottom		Ctrl+PgDn

	К началу следующей	Alt+PgDn
	страницы

	К началу предыдущей	Alt+PgUp
	страницы


<h6>Функции управления:</h6><pre>

	Вызвать главное меню			F10,Alt+V
	Вызвать меню пользователя		F12

	Выбрать базу 				F4
	Открыть предыдущую базу			Ctrl+O

	Установить индексный файл		F5
	Реиндексировать				Alt+F5
	Индексировать				Alt+F9

	Добавить запись				F3,Ins
	Добавить с копированием			Alt+F3
	Вставить новую запись			Shift+F3

	Count по условию			Ctrl+F6
	Суммировать текущее поле		Alt+F6
	Total по текущему выражению		Alt+Shift+F6
	индекса


Замена:
			    Без подтверждения  С подтверждением
   Текущее поле выражением	Alt+R		  Alt+Shift+R
   Поле во всех записях
	постоянным выражением	Alt+F4		  Alt+Shift+F4
   Поле во всех записях
	переменным выражением	Ctrl+F4		  Ctrl+Shift+F4


	Редактировать одну запись (EDIT)	Alt+E

	Редактировать символьное поле		Alt+W
	как memo-поле (для широких полей)

	Справка о базе и окружении		Alt+F1
	Показать/напечатать структуру		Alt+F2

	Присоединить из базы(текста)		Ctrl+F9
	Скопировать в базу(текст)		Ctrl+F3
	Копировать с преобразованием		Ctrl+Shift+F3
	формата MEMO-поля

	Сортировать				Alt+S,Ctrl+F11
	Установить фильтр			Alt+F,Alt+F11

	Напечатать базу [в файл]		F2
	Напечатать запись [в &lt;base.rec>]	Alt+P

	Изменить структуру			Shift+F2
	Установить поля и заголовки		Ctrl+F2

	"Заморозить" текущее поле		Alt+Z
	и все поля левее

	Установить условие подсветки		Alt+B
	Вернуть стандартный цвет поля		Alt+Shift+B

	Создать HTML				Alt+>


<h6>Функции поиска:</h6><pre>

	Встать на запись NN		F6
	Искать по индексу(Seek)		F9
	Искать по условию(Locate)	F7
	Продолжить поиск(Continue)	Alt+F7
	Искать по всем полям сразу	Alt+I
	(контекстный поиск)
	Продолжить контекстный поиск	Alt+Shift+I
	Искать в текущем поле		F11
	(спец.для юзеров)
	Искать максимум/минимум		Alt+M
	Искать самое длинное значение	Ctrl+L
	в текстовом поле
	Искать дубль в индексе		Alt+2
	Искать по маске в индексе	Alt+[
	Продолжить поиск по маске	Alt+Shift+[


<h6>Уничтожение/восстановление:</h6><pre>

	Пометить/восстановить текущую:	Del,Ctrl+T
	Пометить по условию		Ctrl+F8
	Восстановить по условию		Ctrl+F7

	Упаковать			F8
	Уничтожить все(Zap)		Alt+F8

	Очистить текущее поле		Shift+F4
	Очистить все поля записи	Ctrl+Y


<h6>Буфер обмена:</h6><pre>

	Записать в буфер Windows	Ctrl+Ins
	Записать из буфера Windows	Shift+Ins
	Записать во внутренний буфер	Ctrl+Grey+
	Записать из буфера		Ctrl+Grey-, Alt+GreyEnter
	Буфер=Поле+Буфер		Alt+Grey+
	Буфер=Буфер-Поле		Alt+Grey-
	Буфер=Буфер/Поле		Alt+Grey/
	Буфер=Буфер*Поле		Alt+Grey*
	Показать буфер			Ctrl+Enter

<h6>Прочее:</h6><pre>

	Закончить работу			Esc
	Закончить без подтверждения		Alt+X

	Вызов 2-го командного процессора	Alt+F10
	Сменить диск и директорию		Ctrl+F10

	Выполнить макро-функцию			Ctrl+F1
	Установить переменную или массив	Ctrl+F5
	Вычислить выражение			Shift+F6, Alt+G, ?

	Перевести в строчные			Alt+L
	Перевести в прописные			Alt+U
	Первая-Alt+U,остальные-Alt+L		Alt+K
	(капитализация)
	Преобразовать QWERTY->ЙЦУКЕН		Alt+Q
	Преобразовать ЙЦУКЕН->QWERTY		Alt+Y

	Скопировать поле сверху			Alt+Up
	Скопировать поле снизу			Alt+Down
	Скопировать поле слева			Alt+Left
	Скопировать поле справа			Alt+Right

	Обменяться с верхней записью		Ctrl+Up
	Обменяться с нижней записью		Ctrl+Down

	Обменять поле с верхней записью		Alt+Shift+Up
	Обменять поле с нижней записью		Alt+Shift+Down

	Установить закладку			Ctrl+K + 0..9
	Перейти к закладке			Ctrl+Q + 0..9


	Сохранить обстановку			Shift+F1
	Восстановить обстановку			Shift+F5
	Сохранить обстановку в AutoOpen файле	Ctrl+Shift+F1

	Загрузить инициализационный файл	Ctrl+F12

	Вызвать Filer				Alt+F12

	"Освежить" просмотр (в сети)		Ctrl+R

	Отменить исправления в поле		Ctrl+U,Alt+BS


<h6>Работа с компаундными индексами (CDX,MDX,NSX):</h6><pre>

	Выбрать TAG				Alt+T,Shift+F12
	Установить TAG по номеру		Shift+F7
	Установить TAG по имени			Shift+F8
	Сделать новый TAG			Shift+F9
	Удалить TAG				Shift+F10
	Установить другой CDX			Shift+F11



	<h5>B.Режим ввода по GET</h5><pre>

<h6>Позиционирование:</h6><pre>

	Up Down Left Right PgUp PgDn

	Следующее поле			Tab
	Предыдущее поле			Shift+Tab

<h6>Функции управления:</h6><pre>

	Добавить запись				F3
	Переключить режим вставки/переписи	Ins
	Очистить текущее поле			Ctrl+Y
	Завершить ввод без записи		Esc
	Завершить ввод с записью		Enter,Ctrl+W,Ctrl+End
	Отменить изменения 			Ctrl+U

	Переключить режим ввода			F4
	<a href="#p1">(см.п.1)</a><a><pre>
	Вставить строку символов из "MACRO"	Ctrl+F1

	Скопировать поле сверху			Alt+Up
	Скопировать поле снизу			Alt+Down

	Перевести в строчные			Alt+L
	Перевести в прописные			Alt+U
	Первая-Alt+U,остальные-Alt+L		Alt+K
	(капитализация)
	Преобразовать QWERTY->ЙЦУКЕН		Alt+Q
	Преобразовать ЙЦУКЕН->QWERTY		Alt+Y

	Записать в буфер			Ctrl+Grey+
	Записать из буфера			Ctrl+Grey-,Alt+GreyEnter
	Записать в буфер Windows		Ctrl+Ins
	Записать из буфера Windows		Shift+Ins

	Пометить/восстановить текущую		Shift+Del


	<h5>C.Режим SET FIELDS.</h5><pre>

	Убрать поле из списка			DEL,Ctrl+Y
	Изменить порядок			Ctrl+Down, Ctrl+Up
	Восстановить предыдущие установки	F5
	Переключить режим сортировки: "да/нет"	F6
	Завершить изменения			F10
	Отменить изменения			Esc,Alt+X


	<h5>D.Режим MODIFY STRUCTURE</h5><pre>

	Изменить реквизит (если возможно)	Enter
	Добавить новое поле			F3
	Удалить поле				F8
	Вставить поле перед текущим		F5,Ctrl+N
	Установить нужный тип 			C,N,D,L,M,F,V
	(находясь в поле типа)
	Оптимизировать структуру		F9
	Завершить и сохранить изменения		F10
	Отменить изменения			Esc


	<h5>E.Режим просмотра структуры</h5><pre>

	Печать на устройство-принтер		F2, Shift+Tab
	Вывод в текстовый файл (*.STP)		F4
	Вывод в файл со структурой (*.STR)	F6
	-"- с расширенной структурой (*.STE)	F5
	Настройка печати			F9
	Создание программы, генерирующей эту	F10
	структуру и тэги компаундного индекса
	(*.STG)
	Перейти на текущее поле			ENTER


	<h5>F. Диалоги (условия или выражения)</h5><pre>

	Подобрать выражение из истории:
		данного условия			F4,Ctrl+Down
		всех условий			Alt+F4,Ctrl+Shift+Down
		результатов			Ctrl+F4
	Ввести имя текущего поля		F2
	Ввести имя любого поля			Ctrl+F2
	Ввести заголовок текущего поля		F3
	Ввести заголовок любого поля		Ctrl+F3
	Ввести значение текущего поля		F5
	Ввести наименование текущей базы	F6
	Меню ввода 				F10

	В диалоге REPLACE символьного поля	F7
	меню функций

	В диалоге задания списка полей		Alt+F2
	(COPY,SORT) - выбор полей


	<h5>G.Режим просмотра результата (после вычисления, суммирования и т.п.)</h5><pre>

	Продолжить вычисления с результатом	F2
	Вывод результата в текущее поле		F5
	Занесение результата в буфер		Ctrl+Ins
	Преобразовать в "денежный" формат	$
	(519234 - > 5,192.34)
	Меню занесения				F10


	<h5>H.Режим редакции текстового файла или широкого поля (MEMOEDIT)</h5><pre>

	Печать					F2
	Сохранение в файле			F3
	Загрузка из файла			F4
	Переключение режима авто-переноса строк F5
	Запись в текущую позицию буфера Windows
	(при наличии).				F6,Shift+Ins
	Настройка переменных просмотра		F9
	Запись в текущую позицию внутреннего
	буфера					Ctrl+Grey
	Удаление текущей строки			Ctrl+Y
	Удаление слова справа			Ctrl+T
	Реформирование параграфа		Ctrl+B
	Запись изменений и выход.		F10 (Ctrl+W)


	<h5>I.Режим выбора файлов (Filer)</h5><pre>

	Смена текущего диска			F2
	Просмотр текущего файла			F3
	Редакция текущего файла			F4
	Возврат к каталогу,
	с которого начался поиск		F5
	Смена маски просматриваемых файлов	F9
	Просмотр описания текущего файла
	(из файла descript.ion)			F10

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="pp2">
	  <h4>ПРИЛОЖЕНИЕ II. СООБЩЕНИЯ.</h4><pre>

	При открытии базы могут быть выданы следующие сообщения:

	&ltимя файла> - поврежден или блокирован
		Заголовок базы поврежден или база захвачена другим процессом,
		или база помечена как ReadOnly(напоминаю - BDBFS не Viewer!)

	&ltимя файла> - поврежден
		Есть повреждения в списке полей базы

	&ltимя файла> - неверный формат
		Или это вообще не DBF по структуре или это база с
		незнакомым типом поля. Попробуйте запустить bdbfs с
		параметром /FORCED.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="pp3">
	  <h4>ПРИЛОЖЕНИЕ III. Поддерживаемые функции.</h4><pre>

	Как уже отмечалось, можно использовать почти все системные
	функции Clipper.

AADD		ABS		ACHOICE		ACLONE		ACOPY
ADEL		ADIR		AEVAL		AFIELDS		AFILL
AINS		ALIAS		ALLTRIM		ARRAY		ASC
ASCAN		ASIZE		ASORT		AT		BIN2I
BIN2L		BIN2W		BOF		BREAK		CDOW
CHR		CMONTH		COL		CTOD		CURDIR
DATE		DAY		DAYS		DBAPPEND	DBCLEARFILTER
DBCLEARINDEX	DBCLEARREL	DBCLOSEALL	DBCLOSEAREA	DBCOMMIT
DBCOMMITALL	DBCREATE	DBCREATEINDEX	DBDELETE	DBEVAL
DBF		DBFILTER	DBGOBOTTOM	DBGOTO		DBGOTOP
DBRECALL	DBREINDEX	DBSEEK		DBSELECTAREA	DBSETFILTER
DBSETINDEX	DBSETORDER	DBSETRELATION	DBSKIP		DBSTRUCT
DBUNLOCK	DBUSEAREA	DELETED		DESCEND		DEVOUT
DEVPOS		DIRECTORY	DISKSPACE	DISPBOX		DOW
DTOC		DTOS		ELAPTIME	EMPTY		EOF
EVAL		EXP		FCLOSE		FCOUNT		FCREATE
FERASE		FIELDGET	FIELDNAME	FIELDPUT	FILE
FLOCK		FOPEN		FOUND		FREAD		FREADSTR
FRENAME		FSEEK		FWRITE		GETE		GETNEW
HEADER		I2BIN		IF		INDEXKEY	INKEY
INT		ISCOLOR		ISPRINTER	L2BIN		LASTKEY
LASTREC		LEFT		LEN		LENNUM		LOG
LOWER		LTRIM		MAX		MAXCOL		MAXROW
MEMOEDIT	MEMOREAD	MEMORY		MEMOWRIT
MIN		MOD		MONTH		NETERR		NEXTKEY
PAD		PADC		PADL		PADR		PCOL
PCOUNT		PROCNAME	PROW		QOUT		QQOUT
RAT		READEXIT	READKEY		READMODAL	READVAR
RECCOUNT	RECNO		RECSIZE		REPLICATE	RESTSCREEN
RIGHT		RLOCK		ROUND		ROW		RTRIM
SAVESCREEN	SCROLL		SECS		SECONDS		SELECT
SET		SETBLINK	SETCOLOR	SETCURSOR	SETKEY
SETPOS		SOUNDEX		SPACE		SQRT		STR
STRTRAN		STRZERO		STUFF		SUBSTR		TBCOLUMNNEW
TBROWSEDB	TBROWSENEW	TIME		TONE		TRANSFORM
TSTRING		TYPE		VAL		VALTYPE		UPDATED
UPPER		USED		WORD		YEAR,

а также часть специальных недокументированных функций, начинающихся с __ .
Заядлые клипперисты меня поймут, остальные все равно пользоваться не будут.
Специально для "заядлых"! Я не гарантирую, что все __ функции всегда будут
вести себя так, как Вы привыкли. Часть из них была в специальных целях
переписана.

Функции SIX

BAG2TAG		SXCHAR		SXDATE		SXLOG		SXNUM
SX_BLOB2FILE	SX_DATEVAL	SX_DBFDECR	SX_DBFENCR	SX_DECRYPT
SX_DTOP		SX_ENCRYPT	SX_FILE2BLOB	SX_FILEORDER	SX_FINDREC
SX_FNAMEPARSER	SX_GETLOCK	SX_IDTYPE	SX_INDEXCOUNT	SX_INDEXNAME
SX_ISFLOCK	SX_ISLOCKED	SX_ISREADONLY	SX_ISSHARE	SX_KEYADD
SX_KEYCOUN	SX_KEYDATA	SX_KEYDROP	SX_KEYGOTO	SX_KEYNO
SX_KILLTAG	SX_MEMOBLK	SX_MEMOEXT	SX_ORDERCOUNT	SX_PTOD
SX_RLOCK	SX_SETFILE	SX_SETMEMOBLOCK	SX_SETPASS	SX_SETTAG
SX_SLIMFAST	SX_TABLENAME	SX_TABLETYPE	SX_TAGCOUN	SX_TAGINFO
SX_TAGNO	SX_TAGS		SX_TAGUNIQ	SX_VALDATE	SX_VFGET
SX_WILDMATCH	SX_WILDSEEK

M6_ADDSCOPED	M6_CHGOWNER	M6_DBEVAL	M6_DBFILTER	M6_FILTADDREC
M6_FILTCHGREC	M6_FILTCOPY	M6_FILTCOUNT	M6_FILTDROPREC	M6_FILTINFO
M6_FILTINVERSE	M6_FILTJOIN	M6_FREEFILTER	M6_GETAREAFILT	M6_ISFILTER
M6_ISFILTREC	M6_ISOPTIMIZE	M6_NEWFILTER	M6_RECCOUNT
M6_REFRESHFILT	M6_ORDCOND	M6_ORDCREATE	M6_SET
M6_SETAREAFILT	M6_SETFILTER	M6_SETTEMP


Функции Nantucket Forum

FT_AADDITION	FT_AAVG		FT_ADESSORT	FT_AEMAXLEN	FT_AEMINLEN
FT_AMEDIAN	FT_ANOMATCHES	FT_ASUM		FT_AT2
FT_BYT2BIT	FT_BYT2HEX	FT_BYTEAND	FT_BYTENEG	FT_BYTENOT
FT_BYTEOR	FT_BYTEXOR	FT_BITCLR	FT_BITSET	FT_D2E
FT_DEC2BIN	FT_DOSVER	FT_E2D		FT_ELAPSED	FT_FDAY
FT_FINDITH	FT_GCD		FT_GETE		FT_GETMODE	FT_INT86
FT_ISBIT	FT_HEX2DEC	FT_ISBITON	FT_ISPrint	FT_LASTKEY
FT_LDAY		FT_MADD		FT_METAPH	FT_NOOCCUR	FT_PUTKEY
FT_ORIGIN	FT_RAND1	FT_ROUND	FT_SQZN		FT_SYSMEM
FT_TEMPFIL	FT_UNSQZN	FT_WORKDAYS	FT_XTOY


Функции Netto

FN_BIN2HEX	FN_BIN2I	FN_CONNID	FN_CONNINF	FN_CONNNUM
FN_DEFCID	FN_DEVTYPE	FN_ERROR	FN_FSNAME	FN_GETSN
FN_HEX2BIN	FN_I2BIN	FN_INETADD	FN_NAMEL
FN_NETVER	FN_NONULL	FN_OBJCNUM	FN_PEEKSTR	FN_PFCONID
FN_POKESTR	FN_PRCONID	FN_SPFCID	FN_SPRCID	FN_STAADDR
FN_WHOAMI	FN_WRCONNI	FN_WRFSNAM


Функции FoxPro

ALEN		ANSITOOEM	ATC		BETWEEN		CDX
CEILING		CHRTRAN		CTOT		DATETIME	DMY
EVALUATE	FILTER		FLOOR		GOMONTH		INLIST
ISBLANK		KEY		NDX		OCCURS		OEMTOANSI
PI		PROPER		SEEK		SIGN
SYS(2,3,5,6,12-16,21-23,1001,2000,2003,2012,2020,2021)


Функции Clipper Tools

CTOF	FTOC	XTOC	LIKE


Функции, определенные специально для BDBFS описаны в приложении IV.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>

<P><HR><a NAME="pp4">
	  <h4>ПРИЛОЖЕНИЕ IV.BDBFS-PRO.</h4><pre>

	Информация в этом приложении предназначена для желающих максимально
полно освоить BDBFS. Здесь приводятся сведения о вызове процедур и
функций BDBFS, а также использовании внутренних переменных.


	  <h5>A. Системные переменные.</h5><pre>

	Вы можете как угодно использовать в выражениях (примеры
выше) следующие переменные:

							    Умолчание
							    ---------
Переменные условий:
	Условие Locate			_LCONDIT		''
	Выражение поиска		_GSearch		''
	Условие Seek			_FCONDIT		''
	Условие Sum			_SumCOND		''
	Условие Print			_PCOND			''
	Условие Count			_CountCOND		''
	Условие Delete			_DelCOND		''
	Условие вычисления		_ECOND			''
	Условие Replace			_RCOND			''
	Выражение Replace		_Repl			''
	Условие фильтра			_FltrCond		''
	Условие сортировки		_SortCond		''
	Файл	сортировки		_SortFile		''
	Условие TOTAL			_TotalCond		''
	Файл	TOTAL			_TotalFile		''
	Выражение сортировки		_ckSort			''
	Поля копирования		_ckField		''
	Условие цветности		_cb			''
	Условие индекса(тэга)		_IndexFor		''
	Глобальная история условий	_aGlbHcond		{}

Переменные результатов:
	Последняя сумма 		__Sum			 0
	Последний Count 		__Count 		 0
	Последний результат		__Go			 0
	Содержимое ClipBoard		_ClipText		{}
	Выбор по истории при
	занесении из него		_ClipChoice		.T.
	Конвертация OEM/ANSI при работе
	с буфером WINDOWS		_lCnvWClip		.T.
	Директория перехода		_newDir 		''
	Количество обработанных 	_Tally			 0
	записей
	Глобальная история результатов	_aGlbHRes		{}


Установки печати:
	Центровка чисел при выводе		_NeedCentr	.F.
	Печать символа 0 при нулевом числе	_PrintZero	.F.
	Печатать ли номера записей		_NeedRec 	.T.
	Печать заголовка на каждой странице	_NeedHeadPage	.T.
	Печать номеров страниц			_NeedPrPage	.T.
	Прогон страниц после 			_NeedEject	.T.
	Стартовая последовательность принтера	_PSCode 	''
	Конечная последовательность принтера	_PECode 	''
	Левая граница				_LMargin	0
	Длина страницы				_Plength	0(лента)
	Печать стандартного заголовка		_NeedMainHead	.T.
	Устройство-принтер			_printer	PRN
	Дописывать ли файл вывода		_NeedApFile	.F.
	Суммировать ли числовые поля при печати _NeedSum	.T.
	Ширина вывода Memo-полей при печати	_MemoPrnt	50
	Максимально количество строк при	_MemoNumLines	10
	выводе memo и широких текстовых полей
	Символ, разделяющий клетки		_DefaultBorder	 :


Цветовая гамма:
	Основной цвет 		_Bm	 	'w/b,n/bg,N,r/w+,w+/r,w+/b,w+/r'
	Цвет Help и запросов 	_Im	 	'n/w+,g+/n'
	Цвет результатов	_Cm	 	'Gr+/N,W+/B'
	Цвет меню		_MenuColor	'Gr+/b,g+/b'
	Цвет невыбираемых
	элементов меню		HiddenColor	'w/b'
	Заголовки панелей	_HdColor	'G+/b*'

Интерфейс:
	Вывод индикатора	_lMeter		.T.
	Шаг вывода индикатора	_Sx_Step	100
	Редактор Memo		_MemoEditor	'' (встроенный)
	Просмотрщик файлов	_TextViewer	'' (встроенный)
	Шаг табуляции memo	_nMemoTab	 8
	Граница автопереноса	_nMemoWrap	255
	Замер времени		_Timing		.T.
	исполнения
	Ширина показа имен	_DirShow	16
	файлов в Файлере
	Реакция на нажатие	__aExt		{}
	ENTER в Файлере
	(структура массива: {{маска1,команда1},{маска2,команда2}...} )

Прочее:
	Текущая база			_base
	Текущий индексный файл		_oldind
	TBrowse object			_BDBFBrow
	Текущее поле			_C_F
	Содержимое текущего поля	__Content
	Текущий тэг			_TagName
	Текущий компаунд		__CDX
	Маска поиска файлов		_Mask		'*.dbf'
	Текущий RDD 			_DefaultRDD	'SIXCDX'
	Текущее расширение Memo		_DefaultMemo	'FPT'
	Текущее расширение компаунда	_DefaultCDX	'.CDX'
	Пользовательское меню
		Строки			UserMenuPrompts	{}
		Действия		UserMenuActs	{}
	Авто-сохранение окружения	_AutoSave	.F.
	Авто-восстановление окружения	_AutoRestore	.F.
	"Стандартная" клавиатура	_Usa_Keyboard	'QWERTY......'
	"Моя" клавиатура		_My_Keyboard	'ЙЦУКЕН......'
	DOS кодировка			_Oem_Set	'АБВГДЕ......'
	WINDOWS кодировка		_Ansi_Set	'юабцде......'
	Максимальное количество
	отображаемых полей		_nBrowMaxField	170
	Размер буфера UNDO		_UndoSize	1024
	Форсированный режим		_lForced	.F.
	Путь поиска плагинов		_PlugDir	Путь к BDBFS\PLUGINS


	<h5>B.Вызываемые функции.</h5><pre>

	Любую внутреннюю функцию BDBFS, также как и системную, можно вызвать
в любых режимах BDBFS. Наиболее естественным выглядит использование либо
в режиме вычисления (Shift+F6,Alt+G, ?), либо в режиме присвоения (Ctrl+F5).

	<font color=magenta>Примеры:</font>
		{Alt+G}		Aver('Example')
		{Ctrl+F5}	UPC=Aver('Example')

	Для наглядности пояснения будем вести на учебной базе

<font color=blue>	NAME	 S02	S03	S04</font>
	Your	 12	 1	13
	Your1	 32	 2	33
	My	 10	 3	10
	My1	 30	 4	 0


	<h6>1.Функции вычисления.</h6><pre>

	<hr>
		SUM(&lt;ExprC&gt;[,&lt;CondC&gt;]) --&gt; Число

	Суммирует базу по выражению ExprC для условия CondC. Возвращает
	число.

	<font color=magenta>Примеры:</font> {Alt+G}	(1)	Sum('S02+S03','[My] $ Name')
				(2)	Sum('S02','.t.')


	(1) возвратит 47 		(2) - 84

	Умолчание для CondC - все записи.

	Кроме возвращаемого значения результат запоминается в переменной
		__Sum

	<hr>
		AVER(&lt;ExprC&gt;[,&lt;CondC&gt;]) --> Число

	Вычисляет среднее по выражению ExprC для условия CondC. Возвращает
	число.

	Умолчание для CondC - все записи.

	<font color=magenta>Пример:</font> {Ctrl+F5}	MediumS2=Aver('S02','[My] $ Name')

		 возвратит 21

	<hr>
		COUN(&lt;CondC&gt;) --&gt; Число

	Подсчитывает количество записей, удовлетворяющих условию Condc.

	<font color=magenta>Пример:</font> {Ctrl+F5}	CntMy=Coun('[My] $ Name')

		 возвратит 2

	Умолчание для CondC - все записи.

	Кроме возвращаемого значения результат запоминается в переменной
		__count

	<hr>
		SumLine([поле1],[поле2]) --&gt; Число

	Суммирует поля "вдоль" записи, от номера поля1 до номера поля2.
	Если отсутствует FromField подсчет идет от первого, если отсутствует
	ToField - до последнего. Нечисловые поля игнорируются.

	<font color=magenta>Примеры:</font> (для первой записи)
		SumLine()	--&gt; 26
		SumLine(1,2)	--&gt; 12
		SumLine(3)	--&gt; 14

	Кроме возвращаемого значения результат запоминается в переменной
		__Go

	<hr>
		Like(cEtalon,cTest)

	Сравнивает 2 строки с учетом символов расширения ? и *.
	В отличие от маски DOS допускает несколько * в имени.
	Показала те же скоростные результаты, что и такая же функция
	Clipper Tools (наверное, алгоритм тот же-напрашивающаяся рекурсия).
	Но EXE на 0.5 к меньше.
	<font color=magenta>Примеры:</font>
		{F7} Like('spr*.dbf',FileName)

		{Alt+G} Like('?уб*a','дубина') --&gt; .t.

	<hr>
		Crc32(&lt;ExprC&gt;)

	Считает контрольную сумму строки. Используется алгоритм PKZIP.

	<font color=magenta>Пример:</font> Контрольная сумма всех полей:
		Crc32( Name+XTOC(s02)+XTOC(s03)+XTOC(s04) )

	<hr>
		Rand([&lt;ExprN&gt;])

	Возвращает псевдослучайное число в диапазоне от 0 до 1.
	От каждого ExprN возвращается одинаковая последовательность.

	<font color=magenta>Пример:</font> Rand(Seconds())

	<hr>
		Random(&lt;nMin&gt;,&lt;nMax&gt;)

	Возвращает целое псевдослучайное число в диапазоне от
	nMin до nMax.

	<font color=magenta>Пример:</font> Random(0,1000)

	<hr>
		RoundIt(&lt;nVar&gt;,<nPlace)

	Правильное округление. Clipper не всегда правильно выполняет
	операцию округления.

	<font color=magenta>Пример:</font>
		Round(1.025,2)		--&gt;	1.02
		RoundIt(1.025,2)	--&gt;	1.03


	<h6>2. Функции преобразования.</h6><pre>

	<hr>
		Capitalz(&lt;ExprC&gt;) --> ExprC

	Преобразует символьное выражение в строку с первой заглавной.
	При отсутствии параметра возвращает пустую строку.

	<font color=magenta>Пример:</font>
		Capitalz('ЛУГАНСК')	--&gt; Луганск

	<hr>
		OemToAnsi(&lt;ExprC&gt;)

	Преобразует строку в Windows кодировку (1251).
	Украинские буквы поддерживаются согласно ГОСТ Украины.

	Вы можете изменить кодировку под ваши нужды, задав переменные
	_Oem_Set, _Ansi_Set.

	<font color=magenta>Пример:</font>
		OemToAnsi('ЛУГАНСК')	--&gt; ксцюмяй

	<hr>
		AnsiToOem(&lt;ExprC&gt;)

	Обратная функция к OemToAnsi().

		<hr>
		SplitLine(&lt;ExprC&gt;)

	Преобразует строку в массив. Элементы массива отделяются по
	запятым.

	<font color=magenta>Пример:</font>
		SplitLine('Раз,Два,Три') --&gt; {'Раз','Два','Три'}

	<hr>
<a name="pp4dbtrans">		dbTrans(cNewBase,Fields [,bFor,bWhile,nNext,lRest])

	Копирует базу в заданную с возможностью переименования или
	преобразования полей.
	Список полей задается либо в кавычках (как строка), либо как
	массив (что необходимо при задании выражений с запятыми).
	Если в списке полей не заданы вычисляемые поля, то работает
	аналогично системной команде COPY.
	См.также <a href="#p5">п.5. Append/Copy</a> настоящего описания.

	<font color=magenta>Примеры:</font>
		DBTrans('NewFile','Char,Num AS Digit,Num*2 AS Double')

		DBTrans('NewFile',{'LEFT(Char,2) AS Symbol','Num'},;
				  {||Num&lt;>0})

	<hr>
<a name="pp4tb2html">		TB2Html([cHtmlFile, cTitle,aDesign])

	Преобразует текущий TBrowse объект в формат HTML. Если
	название файла не задано - запрашивается. Массив цветов aDesign
	имеет структуру:
		{background color,
		 table background,
		 text color для таблицы и заголовка,
		 text color для помеченных как DELE() записей}.
	По умолчанию используются: "navy","blue","white","red".

	<font color=magenta>Пример:</font>
		Tb2Html('MyBase','WWW FOREVER!',;
			{'fffffc0','fffff80','00000ff','black'})


	<h6>3. Команды установки SET.</h6><pre>

	А. Команды-переключатели. Формат SetКККК(&lt;ExprL&gt;)
	При задании параметра &lt;ExprL&gt; со значением .T.  устанавливаются в ON.

	SetBell=Set Bell		SetDele=Set Deleted
	SetConf=Set Confirm		SetExac=Set Exact

		SetDate(.t.) = Set Date BRITISH
		SetDate(.f.) = Set Date AMERICAN


	Б.Команды-модификаторы.


	<hr>
		SetInde([&lt;ExprC&gt;]) --&gt; .F.

		=Set Index

	Без параметра(или неверным параметром) = Set Index To

	<font color=magenta>Пример:</font>
		SetIndex('D:\TMP.NTX')

	<hr>
		SetPrint([&lt;ExprC&gt;]) --&gt; .F.

		=Set Printer

	Без параметра(или неверным параметром) = Set Printer To

	<font color=magenta>Пример:</font>
		SetPrint('LPT2')	Переназначает вывод на LPT2

	<hr>
		SetFilt([&lt;ExprC&gt;]) --&gt; выражение фильтра

		=Set Filter

	Без параметра(или неверным параметром) = Set Filter To

	<font color=magenta>Пример:</font>
		SetFilt([ 'My' $ Name ])

	<hr>
		SetFunc(&lt;ExprC&gt;,&lt;KeyCode&gt;) --&gt; .F.

		= Set Function

	<font color=magenta>Пример:</font>
		SetFunc('Example',-6)

	 В режиме редактирования при нажатии {F7} будет выводиться
	 'Example'


	<h6>4. Прочее.</h6><pre>

	<hr>
		ModiFile(FileName)	--&gt; .T. при успешной записи

	Простейший текстовый редактор. Поскольку использует MemoEdit,
	то редактирует файлы до 64K. В условиях малого количества
	памяти, этот размер может уменьшаться.

	<font color=magenta>Пример:</font>
		ModiFile('c:\config.Sys')

	<hr>
		Scatter()

	Записывает содержимое текущей записи в массив с именем _Scatter.
	Признак удаления записывается в последнем элементе массива.
	Массив может не существовать до вызова.

	<hr>
		Gather()

	Записывает в текущую запись массив с именем _Scatter, обычно
	созданный функцией Scatter().
	Признак удаления записывается в последнем элементе массива.

	<hr>
		SWAP(recno1,recno2)

	Обменивает через буфер содержимое 2-х записей с физическими
	номерами recno1,recno2.

	<font color=magenta>Пример:</font>
		Swap(1,3)

	<hr>
		WORK(HEAD)  --&gt; ExprC

	Определяет истинное название поля по заголовку.
	Это бывает нужно в случае задания полей по Ctrl+F2, когда Вы не
	помните, как же реально называлось поле, а его имя надо указать,
	например, в поиске.

	<font color=magenta>Пример:</font>
		Work('Мое имя для 2-го поля') --&gt; 'S02'

	<hr>
		FindMax(NeedMax,[FieldName],[EvalBlock]) --&gt; MaxVal

	Универсальная функция поиска максимума/минимума.
		Параметры:
			NeedMax - .T., если нужен максимум,
				  .F. - минимум
			FieldName - поле или выражение, по умолчанию -
				    текущее поле.
			EvalBlock - блок кода, вычисляемый для сравнения,
				    по умолчанию - значение FieldName
				    ( {|i| i } )

	<font color=magenta>Примеры:</font>
		FindMax(.T.,'S02') --&gt; 32

		FindMax(.F.,'S02') --&gt; 10

	// длина самого длинного имени

		FindMax(.T.,'Name',{|i| Len(Trim(i))}) --&gt; 5
			(найдено 'Your1')

	<hr>
		PrintEdit([FileName])

	Выводит текущую запись на устройство печати в развернутом виде.
	Без параметра - на принтер.  По нажатию Alt+P в BDBFS - в файл с
	именем &lt;currentbase&gt;.Rec .  Допись/перепись файла зависит от
	соответствующей настройки принтера.


	<font color=magenta>Пример:</font>
		NEW.DBF Запись 1
	-------------------------------------------------
	NAME				Your
	S02				12
	S03				1
	S04				13

<a NAME="pp4for">
	<hr>
		 For(&lt;nFrom&gt;,&lt;nTo&gt;,&lt;bEval&gt;)

	Цикл For. Может пригодиться, например, в INI-файлах.
	Блоку bEval в качестве параметра передается переменная цикла.

	<font color=magenta>Пример:</font>
		cSet:=''
		For(1,254,{|_1|cSet:=cSet+CHR(_1)})

	<hr>
		 While(&lt;cCondition&gt;,&lt;bEval&gt;[,&lt;cFor&gt;][,&lt;lBase&gt;])

	Цикл While. Если передан lBase==.T. то после выполнения bEval
	делается SKIP.

	<font color=magenta>Пример:</font>
		cName:=''
		While( '!EOF()', {|| cName+= Name},,.T.)

	Результат:	 'YourYour1MyMy1'

		cName:=''
		While( '!EOF()', {|| cName+= Name},'s02 &lt; 30',.T.)

	Результат:	 'YourMy'


	5. Банковские функции.

	<hr>
		 Vkrz1(mfo)

	Возвращает правильный номер МФО по 5 или 6 - разрядному номеру.

	Параметр может быть числовым или символьным,
	возвращаемое значение - числовое.

	<font color=magenta>Примеры:</font>

	Vkrz1(30403) --&gt; 304030
	Vkrz1('304039') --&gt; 304030

	<hr>
		Vkrz14(account,mfo)

	Возвращает правильный счет по плану счетов НБ Украины,
	соответствующий заданному номеру МФО.

	Параметры могут быть числовыми или символьными,
	возвращаемое значение - числовое.

	<font color=magenta>Примеры:</font>

	Vkrz14(1210072810,300001) --&gt; 1210772810
	{F7} Vkrz14(Nls,Mfo)&lt;&gt;Nls	// найти неверные счета

	<hr>
		Vkrz20(account,Rkc)

	Возвращает правильный счет по плану счетов Госбанка России,
	соответствующий заданному номеру РКЦ или кредитной организации.

	Параметры могут быть числовыми или символьными,
	возвращаемое значение - символьное.

	<font color=magenta>Пример:</font>

	Vkrz20('30114В84К00000000501',312) --&gt; 30114В84600000000501

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
</pre>
</HTML>
