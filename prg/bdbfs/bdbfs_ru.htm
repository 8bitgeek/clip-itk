<HTML>
<HEAD>
	<TITLE>Редактор DBF-файлов BDBFS</TITLE>
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
	<META NAME="Author" CONTENT="Евгений Бондарь">

	<STYLE>
		H4 {	font-family: Arial;
			font-size: 14pt;
			font-weight: bold;
			font-style: italic;
			text-decoration: underline;
			color: blue
		}

		H5 {	font-family: Arial;
			font-size: 12pt;
			font-weight: bold;
			text-decoration: underline;
			color: darkyellow
		}

		H6 {	font-family: Arial;
			font-size: 12pt;
			font-weight: bold;
			text-decoration: underline;
			color: blue
		}

		TT {	color: blue	}
		EM {	color: magenta	}
	</STYLE>
</HEAD>
<H2><U><center>
Редактор DBF-файлов BDBFS.EXE
</H2></U>
<br>

<H3> ПРЕДУПРЕЖДЕНИЕ </H3>
<pre><I>    Портирование BDBFS на платформу CLIP началось не так давно и 
идет не без затруднений, что связано, прежде всего, с использованием в
оригинальном, досовском варианте BDBFS довольно большого количества
ассемблерных вставок и вообще различных трюков.
	Поэтому на данный момент возможно возникновение самых
разнообразных ошибок в самых неожиданных местах, а несомненные
преимущества CLIP пока используются мало. Прошу Вас - будьте
толерантны. Ну а познакомиться с оригинальным BDBFS и сопутствующими
утилитами можно на <a href=http://www.geocities.com/bondar_eugen/bdbfs_ru.htm>сайте программы</a>.
</I></pre>

<H3><U>
Инструкция программиста
</H3></U></center><pre>
	Нижеследующее не претендует на полное описание, но, возможно,
кому-нибудь и пригодится.

	Текущее описание соответствует версии
			BDBFS 1.26.
</pre>
<P><HR>
<a name="contents">
	Читайте далее:<br><br>
<ul>
<li><a href="#p1">1.Почему BDBFS ?</a>
<li><a href="#p2">2.Поддерживаемые форматы данных.</a>
<li><a href="#p3">3.Редактирование записей.</a>
<li><a href="#p4">4.Режимы Replace.</a>
<li><a href="#p5">5.Append/Copy.</a>
<li><a href="#p6">6.SUM.</a>
<li><a href="#p7">7.Поиск по индексу(тэгу).</a>
<li><a href="#p8">8.Выражения условий.</a>
<li><a href="#p9">9.Set Fields.</a>
<li><a href="#p10">10.Вычисление выражений.</a>
<li><a href="#p11">11.Задание переменных.</a>
<li><a href="#p12">12.Модификация структуры.</a>
<li><a href="#p13">13.Вставка записи.</a>
<li><a href="#p14">14.TOTAL и SORT.</a>
<li><a href="#p15">15.Сохранение/восстановление окружения.</a>
<li><a href="#p16">16.Инициализационные файлы.</a>
<ul TYPE="square">
	<li><a href="#p16_1">16.1.Auto Open файлы.</a>
</ul>
<li><a href="#p17">17.Макроклавиши.</a>
<li><a href="#p18">18.Выход в DOS.</a>
<li><a href="#p19">19.Использование мышки.</a>
<li><a href="#p20">20.Совместимость с FoxPro.</a>
<li><a href="#p21">21.Работа в сети и мультизадачных системах.</a>
<li><a href="#p22">22.Обработка ошибок.</a>
<li><a href="#p23">23.Выражения цветности.</a>
<li><a href="#p24">24.Работа с буфером обмена.</a>
<li><a href="#p25">25.История условий и выражений.</a>
<li><a href="#p26">26.Стек позиций.</a>
<li><a href="#p27">27.Редакция memo-полей и внешних файлов.</a>
<li><a href="#p28">28.Печатные формы.</a>
<li><a href="#p29">29.Клавишные коды.</a>
<li><a href="#p30">30.Пользовательское меню.</a>
<li><a href="#p31">31.Проверка/коррекция базы.</a>
<li><a href="#p32">32.Плагины.</a>
<li><a href="#p33">33.Запуск BDBFS.</a>
<li><a href="#p34">34.Форсированный режим.</a>
<li><a href="#p35">35.Видео-режимы.</a>
<li><a href="#p36">36.Языковый интерфейс.</a>
<li><a href="#p37">37.Планы.</a>
<li><a href="#p38">38.Чего в BDBFS нет по сравнению с "конкурентами".</a>
<li><a href="#p39">39.Известные проблемы.</a>
<li><a href="#p40">40.Благодарности.</a>
<li><a href="#p41">41.Дальнейшие ругательства.</a>
<li><a href="#p42">42.Форма распространения.</a>
<li><a href="#pp1">ПРИЛОЖЕНИЕ 1.Сводка клавиш.</a>
<li><a href="#pp2">ПРИЛОЖЕНИЕ 2.СООБЩЕНИЯ.</a>
<li><a href="#pp3">ПРИЛОЖЕНИЕ 3.Поддерживаемые функции.</a>
<li><a href="#pp4">ПРИЛОЖЕНИЕ 4.BDBFS-PRO.</a>
<ul TYPE="square">
	<li><a href="#pp4a">A. Системные переменные</a>
	<li><a href="#pp4b">B. Вызываемые функции</a>
	<ol>
	<li><a href="#pp4b1">Функции вычисления</a>
	<li><a href="#pp4b2">Функции преобразования</a>
	<li><a href="#pp4b3">Команды установки SET</a>
	<li><a href="#pp4b4">Прочие системные функции</a>
	<li><a href="#pp4b5">Интерфейсные функции</a>
	<li><a href="#pp4b6">Банковские функции</a>
	</ol>
</ul>
</ul>

<P><HR><a name="p1">
<h4>1.Почему BDBFS ?</h4><pre>

	И в самом деле - аналогов полно, только автору на данный момент
известны следующие viewer/browser-ы:

	- dbview Трофименко ~3к !!!!
	- dbview Царенко ~32k но с редакцией и поиском
	- popdbf Bowen-software - единственный известный мне резидент
	- vdbf Родионова, послуживший толчком для разработки
	- d123 Deveza
	- dbeditor Jeff Parnau
	- dbfedit Lau Preston
	- dbed Дмитриева
	- cdbf Чехуты
	- dbc Кресина

и при этом я нисколько не сомневаюсь, что перечислено далеко не все.
Можно также пользоваться и фирменным DBU Clipper. В конце концов, можно
просто зайти в Fox или там Delphi какой-нибудь ;-).

Тем не менее, у BDBFS есть своя ниша. При его написании девизом было:
	"Сделаем с выбранной базой, все что захотим !"
Имеются ввиду практически все функции, необходимые для повседневной работы
с базами, особенно при сопровождении. При этом хотелось запускать его
достаточно быстро и максимальное количество функций вынести на горячие
клавиши. Кроме того, желательно иметь под рукой единый продукт для работы
с разными форматами баз и индексов.

	Итак, BDBFS умеет:

	 - автоматически или принудительно выбирать формат индексов и MEMO
	 - редактировать записи в режиме BROWSE и EDIT
	 - печатать выбранную базу, в т.ч. и в файл, причем всю или по
	   условию
	 - формировать отчеты
	 - модифицировать структуру базы
	 - выводить структуру на принтер или в файл
	 - оптимизировать структуру
	 - искать по условию LOCATE / CONTINUE
	 - искать контекст без привязки к полям
	 - искать в текущем поле
	 - копировать записи
	 - копировать содержимое отдельных полей слева, справа,
	   снизу и сверху
	 - устанавливать существующий индекс (или tag)
	 - делать новый индекс (или tag)
	 - реиндексировать индексы и полностью перестраивать тэги
	 - производить "мягкий" поиск по индексу
	 - производить "расширенный" поиск по индексу
	 - Replace по условию
	 - Sum, Count, Total по условию
	 - Delete/Recall по условию
	 - Copy to File / Append from, в т.ч. по условию и в текстовых
	   форматах. Возможно преобразование и переименование полей,
	   в том числе преобразование формата MEMO-полей
	 - создавать HTML, XML, XLS файлы, в т.ч. из командной строки
	 - Устанавливать фильтры
	 - Сортировать базу
	 - устанавливать нужный порядок и количество полей, их заголовки.
	   Возможны вычисляемые поля! При этом выбранный разрез может
	   быть распечатан и сохранен для дальнейшего использования!
	 - задавать переменные
	 - вычислять любое Clipper-выражение
	 - задавать макросы
	 - менять диск и директорию
	 - вызывать второй командный процессор
	 - очищать сразу всю запись
	 - делать различные преобразования в текстовых полях
	 - менять режимы ввода
	 - работать с мышью
	 - выбирать все условия по истории
	 - сохранять и восстанавливать окружение
	 - читать инициализационные файлы
	 - выделять цветом различные ячейки по условию
	 - работать с буфером обмена
	 - самостоятельно отдавать TimeSlice
	 - "замораживать" поля для просмотра
	 - искать максимум/минимум
	 - прогуливаться по дискам/каталогам (Filer)
	 - использовать длинные имена Win9?

	 - и прочие приятные мелочи.

	Почти все функции можно вызвать как через горячие клавиши, так
и через меню.

	Большинство функций понятно любому xBase-систу (хотя знакомство с
Clipper желательно). Некоторые пояснения ниже. Назначение всех клавиш
см. в HELP и <a href="#pp1">сводке клавиш</a>.
<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p2">
<h4>2.Поддерживаемые форматы данных.</h4><pre>

	Поддерживаются основные на сегодняшний день форматы xBase-файлов:

		dBASE3/Clipper	(DBT/NTX)
		FoxPro		(FPT/IDX/CDX)
		Visual FoxPro   (измененный заголовок, новые типы полей)
		CLIP		(CTX, новые типы полей)
		SIX		(новые типы полей)

	Если у базы есть memo-поле, то соответствующий драйвер выбирается
автоматически. Иначе применяется драйвер по-умолчанию, который можно задать
в ini-файле или в установках(через меню).
Если в ini-файле ничего не задано, используется драйвер FoxPro (DBFCDX).

	Форматы dBASE4-5, FlagShip, FlexMemo поддерживаются
в <a href="#p34">форсированном режиме</a>.


<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p3">
<h4>3.Редактирование записей.</h4><pre>

	При входе в BDBFS программа находится в режиме VIEW. Для входа
в режим редакции надо нажать на <tt>Enter</tt> в выбранном поле, тогда Вы
получаете практически Browse FoxPro, т.е. доступны клавиши вверх, вниз,
<tt>PgUp, PgDn, Tab, Shift+Tab</tt>. Кроме того, BDBFS переходит в режим BROWSE
при нажатии любой "простой" клавиши в зависимости от типа поля. Например,
при нахождении курсора в поле типа Numeric, переход в редакцию
произойдет по нажатию любой цифры, причем эта цифра сразу отображается.
Для выхода из режима Browse надо нажать <tt>Escape</tt> или <tt>Ctrl+W</tt>.
В отличие от FoxPro(dBase), для редактирования memo-поля специальной
клавиши нажимать не нужно.

	Существуют четыре режима ввода в Browse - в обычном("Usual")
нажатие <tt>Enter</tt> в последнем поле записи просто останавливает ввод;
в режиме "Enter/skip" в этом случае происходит переход на первое
поле следующей записи; в режиме "Lock Enter" нажатие <tt>Enter</tt> в любом
поле приводит к спуску на запись ниже в том же поле. В режиме
"Enter/stop" после нажатия <tt>Enter</tt> происходит переход к режиму VIEW.
Режимы можно переключать во время ввода.

	Кроме режима Browse существует режим Edit с "разворотом"
записи по вертикали. В него можно перейти из режима View, нажав
	<tt>Alt+E(dit)</tt>.
	Иногда удобно отредактировать символьное поле, превышающее
размер экрана, как memo-поле. Это можно сделать по нажатию клавиши
	<tt>Alt+W(ide)</tt>.

	Может быть осуществлен откат изменений (по клавише <tt>Ctrl+U, Alt+BS</tt>)
при редакции текущей базы. Размер буфера откатов задается в
переменной _UndoSize и может быть в пределах от 0 до 4095 действий (по
умолчанию - 1024). Все глобальные изменения базы (PACK, ZAP, etc)
приводят к очистке буфера.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p4">
<h4>4.Режимы Replace.</h4><pre>

	BDBFS поддерживает три режима Replace в текущем поле:
		- константным выражением (<tt>Alt+F4</tt>)
		- переменным выражением  (<tt>Ctrl+F4</tt>)
		- в текущей записи	 (<tt>Alt+R</tt>)

	Разницу между <tt>Alt+F4 и Ctrl+F4</tt> поясним на примере.

	Пусть мы стоим в поле NUM на 15 записи. Теперь задаем
выражение замены Recno()+2 и условие - все записи.

	Теперь по <tt>Alt+F4</tt> во всех записях будет внесено значение 17,
а по <tt>Ctrl+F4</tt> - соответственно 3,5,7..

	Могут спросить: а зачем нужен Repl в текущей записи, можно ведь
просто зайти и исправить? Но представьте, что у Вас в поле стоит
3242756 и его надо умножить на 234. По <tt>Alt+R</tt> все просто - Field*234.

	Если при вызове функций замены держать нажатым Shift (например,
<tt>Ctrl+Shift+F4</tt>), то на каждой записи, подлежащей замене, будет запрошено
подтверждение (с показом текущей и предполагаемой величины поля). Это
особенно удобно при замене переменным выражением.

	При разборе выражений BDBFS может сделать попытку преобразования
к текущему типу. Например, если поле символьное, а задается выражение
замены 123, то оно будет преобразовано к символьному виду. Если текущее
поле типа DATE, а выражение задается в виде {&lt;date>}, то это будет
воспринято не как массив, а как константа типа DATE. В случае, когда
преобразование невозможно, выдается сообщение о несовместимости типов.


<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p5">
<h4>5.Append/Copy.</h4><pre>

	По клавише <tt>F3</tt> просто добавляется пустая запись, <tt>Alt+F3</tt> предлагает
скопировать содержимое текущей или последней записи.

	Можно также нажать <tt>F3</tt> в режиме Browse, тогда будет образована
новая запись со скопированным текущим полем.

	Можно также сделать Append из файла (<tt>Ctrl+F9</tt>), причем если в
имени файла указано расширение не .DBF, то будет сделан запрос на тип
присоединяемого файла: SDF, WITH DELIMITERS, DBF. То же относится и к Copy
File (<tt>Ctrl+F3</tt>).

	Можно сделать Append из "самого себя", при этом будет задан
дополнительный вопрос.

	При присоединении могут возникать конфликтные ситуации двух
типов: несовпадение типов полей и числовое переполнение. До версии
BDBFS 1.07 при обнаружении таких ситуаций такие поля оставались
незаполненными. Начиная с версии 1.07 было принято (спорное) решение
о максимальном выполнении операций. Это означает, что:
	при несовпадении типов полей будет выполнена попытка
преобразования;
	при числовом переполнении в поле будет записано максимально
возможное число.Так, если длина поля в текущей базе=3, а присоединяемое
число=1200, то будет записано 999.

	При копировании файла можно указать только требуемые поля
(вручную или подобрав их по <tt>Alt+F2</tt>).

	Доступно также преобразование и переименование полей
при копировании (в базу, но не в SDF). Это своего рода мини
Query By Example. Например, вы можете задать выражения
в списке полей:
	Num,Num*2 AS Double,Upper(Char),CTOF(Char) AS Shifr

	Если в выражении поля задано ключевое слово "AS", то поле в
новой базе будет названо так, как Вы попросите (Num*2 AS Double -
поле в копируемой базе будет называться DOUBLE). Если целевое поле не
названо (слово AS не употреблено), то поле будет названо Exp_??, где ?? -
порядковый номер в списке (аналогично FoxPro). Если выражение не может
быть вычислено, оно игнорируется. См. также описание <a href="#pp4dbtrans">функции DBTrans()</a>.
<a name="p5_1">
	Можно также экспортировать базу в форматы HTML, XML,
MS EXCEL (XLS). Эти операции доступны через меню Файл -> Экспортировать
в HTML, Экспортировать в XML, Экспортировать в XLS.

	При экспорте (в любой формат) по умолчанию выдается запрос на
перекодировку OEM -> ANSI. Если Вы не хотите, чтобы он выдавался (что
особенно уместно при вызове экспорта из <a href="#p33">командной строки</a>,
нужно в <a href="#p16">инициализационном файле</a> установить переменную
_lexp_o2aq:=.F.. Переменная _lexp_o2a при этом будет отвечать за
необходимость перекодировки: если lexp_o2a==.T. - перекодировка будет
произведена.

	Экспорт в XLS осуществляется в формате Biff5/Biff7, т.е. не в
уникоде. Примечания не записываются, так что длина символьных полей
ограничена 255 символами. Создаваемая книга содержит 1 лист. Данные
записываются, начиная со столбца 2 (B), в первом проставляется символ *
для записей, помеченных к удалению.

	При экспорте в XML:
		- в качестве имени корневого тэга используется имя базы
		  (если оно начинается с цифры - добавляется символ "_");

		- в качестве имени тэга для записей используется слово
		  "Record";

		- поля описываются как тэги, а не как атрибуты;

		- используются внутренние DTD;

		- в качестве атрибутов записи используются:
			- ее физический номер (RecNo);
			- номер в индексе при установленном индексе
			  или тэге (KeyNo);
			- признак удаленности (Deleted - при наличии);

		- в качестве обязательных атрибутов тэга используются:
			- "type" - тип поля;
			- "len"  - длина поля;

		- в качестве дополнительных атрибутов тэга используются:
			- "dec" - при наличии дробной части;
			- "realtype" - когда тип данных отличается от
			  типа поля (например, Strongly-type VariFields
			  или для <a href="#p34">"форсированных" полей</a>);
			- "valtype" - для полей переменного типа
			  (Weakly-Typed VariFields или поля типа Variant);

		- все текстовые поля описываются как секции CDATA;

		- поля типа DATE выводятся в виде DTOS();

		- логические поля выводятся как 1/0;

		- в комментарии записываются:
			- имя базы;
			- описание из файла descript.ion (при наличии);
			- выражение индекса (при установленном индексе).

См. также описание функций <a href="#pp4tb2html">Tb2Html()</a>, <a href="#pp4tb2xml">Tb2Xml()</a>, <a href="#pp4tb2xls">Tb2Xls()</a>.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p6">
<h4>6.SUM.</h4><pre>

	Суммирование всегда происходит по текущему полю, в т.ч.
можно выбрать и <a href="#p9">вычисляемое поле</a>.
	Суммировать можно по числовому или символьному полю
(т.е. SUM( VAL(field) )). Подразумевается, что Вы знаете, что
делаете.  Можно использовать и функцию <a href="#pp4Sum">Sum()</a>.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p7">
<h4>7.Поиск по индексу(тэгу).</h4><pre>

	При поиске по индексу типа DATE не обязательно писать CTOD.
Так, одинаково правильно
		12/03/93  CTOD('12/03/93')  DATE()

	При поиске по индексу символьного типа значение надо заключать
в кавычки. Впрочем, если выражение поиска начинается с цифры или символа
с кодом более 127, то кавычки не обязательны.

	По умолчанию поиск ведется в режиме SoftSeek OFF
(SET NEAR - для привычных к FoxPro). Чтобы задать режим SoftSeek ON
надо сделать
		{<tt>Alt+G</tt>} Set(9,.t.)	// см. Set.CH,
или задать =Set(9,.T.) в ini-файле.

	Иногда бывает нужным найти неуникальные записи в индексе.
Это можно сделать с помощью клавиши <tt>Alt+2</tt>. Курсор при этом установится
на дублирующую запись.

	Доступен также поиск по маске (естественно, в индексе символьного
типа). Правила задания маски аналогичны DOS. Например, можно задать:

	{<tt>Alt+[</tt>} 'B?LL',	// Найдено: BILL
	{<tt>Alt+Shift+[</tt>}		// Продолжили и нашли: BYLL

	{<tt>Alt+[</tt>} "*МОСКОВС*"	// Найдено: МОСКОВСКАЯ ПЛОЩАДЬ
	{<tt>Alt+Shift+[</tt>}		// МОСКОВСКАЯ УЛИЦА
	{<tt>Alt+Shift+[</tt>}		// ПРОСПЕКТ МОСКОВСКИЙ

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p8">
<h4>8.Выражения условий.</h4><pre>

	При выборе многих функций BDBFS, у Вас будет запрошено
условие отбора или поиска. Варьировать выражения в таких условиях
можно достаточно широко. Могут быть применены любые как системные,
так и пользовательские функции. Единственное ограничение - длина
выражения(не более 255 символов).

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p9">
<h4>9.Set Fields.</h4><pre>

	По <tt>Ctrl+F2</tt> Вы можете задать содержание, названия и порядок
полей. Содержанием поля может быть любое допустимое выражение.
	В названии допустимы символы нац.алфавитов, причем эти названия
будут выводиться и при печати.

	<em>Пример:</em>
		Содержание поля: IS+DOS-KOS
		Название: Исходящий остаток

	Для поля также может быть задан шаблон вывода и печати (picture).
Например, 999,999.99. Форматы шаблонов можно посмотреть в документации
к любому xBase. Кроме того, можно принудительно установить ширину поля.
Обычно это имеет смысл, когда ширина данных поля значительно меньше
ширины заголовка.

	При пометке поля, как удаленного, оно блокируется для вывода и
редакции. При помощи клавиш <tt>F8/F7</tt> можно блокировать/разблокировать сразу
все поля, начиная с текущего.

	Установка нужного порядка полей осуществляется при помощи
<tt>Ctrl+Up или Ctrl+Down</tt> (обмен полей местами).

	Завершить изменения можно клавишей <tt>F10</tt>. Наблюдайте результат.
Если затем вновь нажать <tt>Ctrl+F2</tt>, будет восстановлено исходное состояние
базы.

	Вычисляемые поля редакции не подлежат (при переходе на такое поле
курсор не виден). Тем не менее, их можно использовать в выражениях.

	Требуемый порядок и содержание полей можно устанавливать
последовательно. Предположим, мы убрали из просмотра поле S2. Нажали
<tt>F10</tt>. Посмотрели и решили, что не хотим видеть и поле S3, а не только S2.
Последовательность действий: <tt>Ctrl+F2</tt> (восстановили все поля), снова
<tt>Ctrl+F2</tt>, затем <tt>F5</tt> и получаем предыдущие установленные поля. Правим
дальше, etc.

	На Copy File Set Fields влияние не оказывает.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p10">
<h4>10.Вычисление выражений.</h4><pre>

	По нажатию <tt>Shift+F6 (Alt+G(o),?)</tt> можно вычислить почти любое
корректное Clipper выражение длиной до 255 символов. Не говоря уж о
том, что частенько нужно вспомнить н-р, какое число было Date()-21
или быстренько взять Log(Exp(1)) :-), получился довольно интересный
тренажер Clipper-иста. Можно, например, поэксперементировать
с параметрами Memoedit, понять, наконец, чем отличается Bin2i от Bin2w
или поинтересоваться, что такое Descend('rs|Аpd').

	Можно использовать почти все функции из Clipper.Lib и Extend.Lib,
ряд полезных (на мой взгляд) функций известных библиотек Six3, NanFor,
Clipper Tools, Netto, Blinker, эмуляцию некоторых функций FoxPro, а также
специальные функции BDBFS.
	Список функций приведен <a href="#pp4">в Приложении IV</a>.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p11">
<h4>11.Задание переменных.</h4><pre>

	По <tt>Ctrl+F5</tt> вы можете проинициализировать переменную (или
задать ей новое значение).

	Для простой переменной нужно просто выполнить присвоение

		new=5
		word:='папа'
		today=date()

	Для объявления массива его надо описать:

		arr[20] или arr=Array(20)

	Затем уже можно сделать Arr[3]=Exp(12.09).
	Впрочем, можно и прямо написать: Arr={10,20,'пример'}

	В правой части допустимы любые верные Clipper выражения.

	Зачем все это нужно ?

	Иногда удобно вычислить выражение, а потом его использовать
в условиях или Replace. Используя присвоение переменных и вычисление
выражений можно даже писать небольшие программки. Попробуйте, н-р, сделать
следующее:
	{<tt>Ctrl+F5</tt>}	aPrg=Array[Adir('*.prg')]
	{<tt>Alt+G</tt>}		Adir('*.prg',aPrg)
	{<tt>Alt+G</tt>}		ForAch(5,10,24,'Программы',aPrg)

	У вас в директории есть индекс, который имеет нестандартное
расширение.

	{<tt>Ctrl+F5</tt>}	_oldind='MyOwn.FIL'
	{<tt>Ctrl+F5</tt>}	_req=0

	Нужно выбрать базу из резервных копий.

	{<tt>Ctrl+F5</tt>}	_mask='*.bak'
	{<tt>F4</tt>}

	Хотите напечатать базу мелким шрифтом и с лозунгом.

	{<tt>Ctrl+F5</tt>}	_PSCode='Б У Д Ь М О !!!'+chr(15)
	{<tt>F2</tt>}

	Можно присвоить блок кода

	{<tt>Ctrl+F5</tt>}	bck={|i|i+1}	, затем
	{<tt>Alt+G</tt>}		Eval(num)

	И вообще: была бы возможность, применение найдется.
	Несколько примеров есть в Examples.Ini.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p12">
<h4>12.Модификация структуры.</h4><pre>

	После изменения структуры предыдущая версия остается с
расширением BAK. Если существовал memo-файл, то он остается
с расширением TBK.

	Если при модификации возникает ситуация числового переполнения,
то в поле будет занесен 0.

	В программе реализован известный Clipper-истам трюк - образование
символьных полей с длиной более >255 символов. Это делается так: в поле
Field_Dec записывается Mod(L,256), в поле Field_Len - остаток. Например:
длина поля 700. Тогда Field_Dec=2, Field_Len=188. Но чтобы ввести нужную
длину в BDBFS достаточно исправить Field_len. Нужные величины будут
занесены автоматически.

	По клавише <tt>F9</tt> (кроме драйвера SIXMDX) вызывается функция
оптимизации структуры. Она проводится с использованием VariField полей
по следующим правилам:
	- символьные поля с длиной > 16 преобразуются в формат V10;
	- MEMO поля преобразуются в формат V6 (ZeroField);
	- числовые поля с длиной от 5 до 10 байт преобразуются в
	  формат V4 (Integer);
	- поля даты преобразуются в формат V3.

	Могут быть заданы поля, названные не-по-английски.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p13">
<h4>13.Вставка записи.</h4><pre>

	Как известно, Clipper операции INSERT не имеет. Но иногда очень
хочется. Поэтому приходится идти тяжким путем:APPEND, сдвинуть все вниз,
очистить верхнюю. На больших базах это может быть долго. При
включенном индексе или тэге INSERT не работает.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p14">
<h4>14.TOTAL и SORT.</h4><pre>

	Отличия команды TOTAL в BDBFS и в Clipper:

	- не поддерживается TOTAL без установки индекса/тэга
	  (в отсортированной базе);
	- в целевую базу копируются все поля (в Clipper memo-поля
	  исключаются);
	- если существует поле TOTALCOUNT, то в него будет
	  записываться количество подсуммированных записей по
	  каждому ключу;
	- не поддерживаются поля заданные через alias (а зачем?).

	Отличия команды SORT в BDBFS и в Clipper:

	- может быть сортировка по memo-полю (по первым 255 символам);
	- удаленные записи сохраняют свой статус в отсортированной базе.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p15">
<h4>15.Сохранение/восстановление окружения.</h4><pre>

	Вы можете определить любые переменные, задать условия поиска и
суммирования, определить индекс и необходимые поля и проч., а затем
сохранить все это в обычном memo-файле, нажав <tt>Shift+F1</tt>.
	Если затем нажать <tt>Shift+F5</tt> и задать имя этого файла, все
окружение, включая используемый DBF, будет, по-возможности, восстановлено.
Мало того, можно сразу загрузить окружение, задав имя MEM-файла в командной
строке. Разумеется, может быть сколько угодно файлов окружения в каталоге.
	По умолчанию используется файл BDBFS.MEM.
	Если в INI-файле (или непосредственно из программы) определена
переменная _AutoSave:=.T., то в текущем каталоге файл BDBFS.MEM создается
автоматически при выходе.
	Если в INI-файле определена переменная _AutoRestore:=.T. и
BDBFS.EXE запускается без параметров, то файл BDBFS.MEM из текущего
каталога считывается автоматически.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p16">
<h4>16.Инициализационные файлы.</h4><pre>

	Вы можете при загрузке (bdbfs &lt;файл.ini>) или позже, по нажатию
<tt>Ctrl+F12</tt>, прочитать содержимое файла инициализации. Файл инициализации
представляет из себя обычный текстовый файл, содержащий присвоение
переменных, а также, возможно, выполнение некоторых функций,
мини-программ. Фактически, большинство операций, используемых
в Clipper и прочих xBase-диалектах, допустимы в ini-файлах. Переменные,
определенные в ini-файлах, будут затем доступны в программе. Операторы,
определенные специально для BDBFS должны предваряться символом #.
В операторах, совпадающих по синтаксису с Clipper символ # может
отсутствовать (если этого не требует синтаксис самого Clipper).

	Определены следующие операции.
<a name="p16_a">
<h5>A.Присвоение.</h5><pre>

	<em>Синтаксис:</em>
		&lt;var>:=&lt;expression>		или
		&lt;var> = &lt;expression>		или
		#define &lt;var> [&lt;expression>]	или
		#undefine &lt;var>

	<em>Примеры:</em>
		MyVar=100
		MyVar := 100
		MyVar=Sqrt(4)
		#define MyVar 100
		#undef MyVar

	В случае #define, в отличие от include файлов Clipper и C,
переменные будут объявлены и доступны не только во время чтения файла
инициализации. Если в #define опущено <expression>, оно принимается равным
.T. . Операция #undef уничтожает переменную.
	Полезным может оказаться задание в ini-файле блоков кода.
Позже их можно будет вычислять, обращаясь как к функции.

	<em>Пример:</em>
	// в ini-файле
		Squart = {|i|	'Площадь круга радиуса '+STR(i,3)+;
				' = '+LTRIM(STR(3.1415 * i * i,16,2))}

	// в программе
		{?} Squart(4)		или
		{?} Eval(Squart,4)

<a name="p16_b">
<h5>B.Вычисление функции без присвоения переменной.</h5><pre>

	<em>Синтаксис:</em>
		=&lt;expression>	или
		&lt;expression>

	<em>Пример:</em>
		=Tone(440,3)
		Eval(bEval, 100)

	Использование формы с начальным символом "=" обязательно если
символ "=" есть и в самом выражении. В остальных случаях операторы
эквивалентны
		=Devout('S='+S)		// Обязательно с первым =

<a name="p16_c">
<h5>C.Включение вторичного файла инициализации.</h5><pre>

	<em>Синтаксис:</em>
		#include &lt;FileSpec>

	&lt;FileSpec> может включать путь и/или расширение (по умолчанию -
.ini). Если путь не задан, то файл будет искаться последовательно в:
	- текущем каталоге
	- каталогах, определенных глобальной переменной _PlugDir (по
	  умолчанию - каталог bdbfs.exe\PLUGINS)
	- в каталогах, определенных переменной окружения SET INCLUDE.

	<em>Примеры:</em>
		#include second.ini
		#include 'second'
		#include c:\my\second.ini

	Поскольку поддерживается операция #define, то можно включать
стандартные клипперовские файлы определений, такие, как inkey.ch, Set.ch.
Надо только иметь в виду, что #define с параметрами не поддерживается.

	Вниманию клипперистов и С-онистов: имя файла можно задавать без
кавычек.

<a name="p16_d">
<h5>D.Определение команды.</h5><pre>

	<em>Синтаксис:</em>
		#xcommand &lt;matchPattern> => &lt;resultPattern>

	<em>Примеры:</em>

	  #xCommand INVERT =>;
		DBEval({||Rlock(), IF(DELE(),dbRecall(),dbDelete())})

	  #xCommand MODIFY COMMAND &lt;x> => ModiFile(&lt;x>)

	  #xCommand EOM(&lt;x>) => FT_LDAY(&lt;x>)

	В отличие от команд препроцессора Clipper, поддерживается только
один параметр (или отсутствие параметров).

	Наиболее естественно применять команды из вычисления выражений,
например:
		? INVERT

<a name="p16_e">
<h5>E.Определение локальной таблицы команд.</h5><pre>

	<em>Синтаксис:</em>
		#LOCALTABLE

	Команды (определенные оператором #xcommand) занимают определенное
место в памяти и несколько замедляют выполнение операций вычисления (так
как для каждого выражения проверяется подстановка). Поэтому может
оказаться полезным держать в памяти команды только тогда, когда они
реально могут понадобиться.

	<em>Пример:</em>
		#LOCALTABLE
		#include MyCmd.ch
		...

	В файле MyCmd.ch определен ряд команд, которые используются в
текущем ini-файле. Предварительное задание #LOCALTABLE гарантирует, что
после завершения интерпретации ini-файла, ресурсы, занятые под эти
команды, будут высвобождены.

<a name="p16_f">
<h5>F.Определение макрокоманд.</h5><pre>

	<em>Синтаксис:</em>
		#MACRO &lt;код клавиши> => &lt;последовательность нажатий>, или
		#MACRO_IN_[область действия] &lt;код клавиши> =>
					     &lt;последовательность нажатий>

	Последовательность нажатий может быть задана либо как символьная
строка(формат KEYBOARD), либо как массив кодов(формат INKEY). Во втором
случае можно задать функциональные и расширенные клавиши, но длина
последовательности до 16 нажатий (см. описание устройства буфера клавиатуры).
Последовательность может быть задана блоком кода, что позволяет выполнять 
переменные действия.

	Могут быть заданы следующие модификации области действия
макрокоманды:
		#MACRO_IN_BROWSE - основной режим,
		#MACRO_IN_DIALOG - режим задания условий, списка полей,
		#MACRO_IN_FIELD  - режим коррекции поля,
		#MACRO_IN_MEMO	 - режим редакции MEMO и текстовых файлов.

	Если область действия не указана, макрокоманда действует всегда.


	<em>Примеры:</em>
		#MACRO 307 => {-9,'ч','5'}
		;банковские функции через меню на <tt>Alt+Б</tt>

		#MACRO_IN_FIELD 308 => 'Это будем частенько нажимать при
		редакции'
		;на <tt>Alt+></tt>

		#MACRO_IN_DIALOG 383 => 'Like("*",&_C_F)'+REPL(CHR(19),9)
		;На <tt>Alt+*</tt> удобное задание шаблона для поиска

		#MACRO_IN_DIALOG 276 => {|| Time()}
		;По <tt>Alt+T</tt> в диалоге вводится текущее врем

<a name="p16_g">
<h5>G.Объявление переменных.</h5><pre>

	<em>Синтаксис:</em>
		LOCAL &lt;v1>[:=&lt;xv1>],&lt;v2>[:=&lt;xv2>] или
		PRIVATE &lt;v1>[:=&lt;xv1>],&lt;v2>[:=&lt;xv2>] или
		PUBLIC &lt;v1>[:=&lt;xv1>],&lt;v2>[:=&lt;xv2>]

	Переменные, объявленные LOCAL и PRIVATE будут автоматически
освобождаться по завершению интерпретации ini-файла. BDBFS на данный
момент не различает объявления LOCAL и PRIVATE. Оператор PUBLIC, вообще
говоря, не обязателен, поскольку все ранее необъявленные переменные будут
объявлены PUBLIC. Но PRIVATE и PUBLIC введены для большей совместимости с
уже существующими программами на диалектах xBase.

	<em>Примеры:</em>
		#LOCAL cFile, nSum

		LOCAL cFile:="MyFile"

		PUBLIC summa

<a name="p16_h">
<h5>H.Аварийное прекращение интерпретации.</h5><pre>

	<em>Синтаксис:</em>
		#BREAK	или
		#BREAK &lt;условие>

	Если задан #BREAK без параметров, интерпретация немедленно
прекращается, в противном случае, выход происходит при выполнении условия.

	<em>Пример:</em>
		#BREAK !FILE("NeedFile")

<a name="p16_i">
<h5>I.Параметры и возвращаемые значения.</h5><pre>

	Инициализационному файлу можно передать до 5 параметров, при
интерпретации они будут доступны через идентификаторы _1.._5
соответственно. Можно также определить значащие имена параметров в
операторе PARAMETERS.
	<em>Синтаксис:</em>
		PARAMETERS &lt;Список>

	<em>Пример:</em>
		PARAMETERS nVal,cVal,xVal

	Если ini-файл должен вернуть какое-то значение, необходимо
определить оператор #RETURN.
	<em>Синтаксис:</em>
		RETURN &lt;expression>

	<em>Примеры:</em>
		#RETURN 4
		RETURN _1*_2

	Оператор #RETURN не заканчивает программу немедленно, а только
присваивает возвращаемое значение.

	Вызов ini-файла с параметрами и возвратом можно осуществлять
через вызов функции чтения ini-файлов или прямым вызовом по имени
ini-файла.
	<em>Примеры:</em>
		// Вызов в программе
		{?} RestoreIni("MyPlug",par1,par2)	или
		{?} MyPlug(par1,par2)

		// Вложенный вызов из ini-файла:
		MySqrt:=RestoreIni("Sqrts.prb",32.1,3)	или
		MySqrt:=Sqrts(32.1,3)

	Единственное ограничение при прямом вызове по имени - ini-файл
должен иметь расширение ini, что необязательно в случае использования
RestoreIni(). Так, во втором примере вызов MySqrt:=Sqrts(32.1,3) не
сработает, т.к. файл Sqrts имеет нестандартное расширение.

<a name="p16_j">
<h5>J.Ветвление по условию.</h5><pre>

	<em>Синтаксис:</em>
		IF &lt;условие1>
			&lt;команды>
		[ELSEIF &lt;условие2>
			&lt;команды>
		[ELSE]
			&lt;команды>
		ENDIF

	Аналог обыкновенного IF. Допускается вложенность до 10
операторов IF в одном ini-файле. Объявления с символом # и без него
можно смешивать.

	<em>Пример:</em>

	#IF Continue("Do you want to make something?")
		...
		операторы, этот самый Something осуществляющие
		...
	#ELSE
		Nfind("May be next time...")
	#ENDIF


	Частный случай оператора #IF - это операторы #IFDEF, #IFNDEF,
часто использующиеся в include-файлах для предотвращения повторной
загрузки файла.

	<em>Примеры:</em>

	// из set.ch Clipper
	#IFNDEF _SET_CH
		... объявления констант

		#DEFINE _SET_CH
	#ENDIF

	// из PLUGINS\clipper.ch
	#IFDEF _CLIPPER_CH
		#BREAK		// если уже читали - сразу выйдем
	#ENDIF
	...
	#DEFINE _CLIPPER_CH

	В операторах #IFDEF, #IFNDEF символ # обязателен.

<a name="p16_k">
<h5>K.Ветвление CASE</h5><pre>

	<em>Синтаксис:</em>
		DO CASE
			CASE &lt;условие1>
				&lt;команды>
			[CASE &lt;условие2>
				&lt;команды>
			...
			[OTHERWISE]
				&lt;команды>
		ENDCASE

	Аналог обыкновенного CASE. Допускается вложенность до 10
операторов CASE в одном ini-файле. Операторы DO CASE и IF/ELSEIF
эквивалентны. Фактически, можно даже смешивать синтаксис, то есть писать,
например,
		DO CASE .. CASE .. ELSE .. ENDCASE,
хотя это, разумеется, не рекомендуется.

	<em>Пример:</em>

	DO CASE
		CASE  _1 &lt; 0
			s := s - _1
		CASE  _1 = 0
			s := 0
		OTHER
			s := s * _1
	ENDCASE

<a name="p16_l">
<h5>L. Цикл WHILE</h5><pre>

	<em>Синтаксис:</em>
		[DO ]WHILE &lt;условие>
			&lt;команды>...
			[EXIT]
			&lt;команды>...
			[LOOP]
		ENDWHILE или ENDDO

	Аналог обыкновенного WHILE. Допускается вложенность до 10
операторов #WHILE в одном ini-файле.

	<em>Примеры:</em>

	sum:=0
	#WHILE !EOF()
		sum:=sum+FieldGet(1)+FieldGet(2)
		DBSKIP()
	#ENDWHILE

	WHILE .T.
		....
		IF inkey(0)=27	//ESC
			EXIT
		ENDIF
	ENDDO

<a name="p16_m">
<h5>M. Цикл FOR.</h5><pre>

	<em>Синтаксис:</em>
		FOR &lt;счетчик> = &lt;от> TO &lt;до> [STEP &lt;шаг>]
			&lt;команды>...
			[EXIT]
			&lt;команды>...
			[LOOP]
		NEXT или ENDFOR

	Аналог обыкновенного FOR. Допускается вложенность до 10
операторов FOR в одном ini-файле.

	<em>Пример:</em>
		FOR i:=1 TO 100 STEP 2
			s:=s+i
		NEXT

<HR>

	Для организации циклов в ini-файлах можно также воспользоваться
функциями For() и While() - <a href="#pp4for">см. приложение IV</a>.
Использование функций по сравнению с операторами FOR и WHILE менее
наглядно, но дает значительный выигрыш в скорости.

<a name="p16_n">
<h5>N. "Пустые" операторы</h5><pre>

	<em>Синтаксис:</em>
		MEMVAR <varlist>	или
		FIELD <fieldlist>	или
		EXTERNAL <proclist>

	Эти операторы игнорируются при считывании и введены для большей
совместимости с уже существующими программами.

<HR>
	Инициализационные файлы, аналогично #include, ищутся помимо
текущего каталога в пути, определенном переменной _PlugDir, а
затем в пути, заданной переменной окружения SET INCLUDE.

	В демонстрационном файле Examples.ini и в каталоге PLUGINS
содержится много различных примеров. См. также <a href="#p32">п.32</a>.

	При старте программы всегда делается попытка считать файл
BDBFS.INI, находящийся в каталоге запуска BDBFS.EXE. Если файл
инициализации не задан в командной строке то затем делается попытка
считать файл BDBFS.INI, находящийся в текущем каталоге (при его отсутствии
ищется BDBF.INI - для совместимости c предыдущими версиями BDBF).

	Вызов ini-файла из программы (например, через <tt>Ctrl+F12</tt>) приводит к
принудительному переоткрытию текущей базы. Если Вы этого не хотите, в
любом месте ini-файла необходимо определить переменную
	lNoReOpen:=.T.

<a name="p16_1">
<h4>16.1.AutoOpen файлы.</h4><pre>

	Кроме обычных, дополнительно могут быть заданы инициализационные
файлы, считываемые при открытии соответствующей базы (AutoOpen файлы).
Такой файл должен иметь расширение .AOP и может содержать команды, <a href="#p30">меню,</a>
переменные, специфичные для данной базы. Кроме того, может быть задан
список и/или названия полей, а также формат их вывода. Список полей
должен быть задан как массив с именем Fields, список названий - как
массив с именем Heads, список форматов - Pictures, список "ширин" полей -
Widths. Могут задаваться и вычисляемые поля. Если для поля не задано
имя, формат, ширина - используются умолчательные величины.

<em>Пример:</em>
	Fields:={'Char','Num','Num*2'}
	Heads:={'Строка','Число','Двойное;число'}
	Pictures:={, '999,999.99'}
	Lens:={7,,,}

	Иногда возникает необходимость показывать все поля, кроме
некоторых. В этом случае можно (особенно, если полей много) не
перечислять все нужные поля, а указать исключаемые. Это делается с
помощью оператора #EXCLUDE.

	<em>Синтаксис:</em>
		#EXCLUDE &lt;Список исключаемых полей>

	<em>Пример:</em>
		#EXCLUDE Secret, KeyField

	В AutoOpen файлах можно хранить и другие полезные инструкции,
для успешного применения которых желательно изучить <a href="#pp4">Приложение IV</a>.
Так, например, можно заставить базу открываться с уже установленным тэгом.
Для этого можно написать __TagNom:=NN, где NN - номер нужного тэга,
или __TagName:='CC', где CC - имя нужного тэга.

	Вы можете интерактивно задать нужные поля (через <tt>Ctrl+F2</tt>),
установить активный тэг или индекс, а затем сохранить все это в AOP-файле
по <tt>Ctrl+Shift+F1</tt>.

	Вы можете также задать действия, выполняемые при закрытии базы,
то есть в момент выхода из программы или смены текущей базы. Операторы,
выполняемые при закрытии должны располагаться в AutoOpen файле после
определения секции [close].

	<em>Пример:</em>

	// При открытии запомним время создания файла
	aD:=Directory('WrkBase.DBF')
	tOld:=aD[1,4]

	[close]
	// Резервное копирование после возможных изменений
	DBCommit()	// Убедимся, что буфера сброшены
	aD:=Directory('WrkBase.DBF')
	IF tOld <> aD[1,4]
		__DbCopy('Z:\ARCHIVE\RsrvBase')
	ENDIF

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p17">
<h4>17. Макроклавиши.</h4><pre>

	По нажатию <tt>Ctrl+F1</tt> вызывается последовательность символов,
запомненная в переменной _MACRO. В режиме просмотра эта возможность
работает как Set Key, в редакции - как Set Function.

	<em>Пример:</em>

	{<tt>Ctrl+F5</tt>} 	_Macro=chr(4)+chr(4)+chr(13)

	Теперь, в режиме просмотра, по {<tt>Ctrl+F1</tt>} вы войдете в редакцию поля
CurrentField+2

	{<tt>Ctrl+F5</tt>}	_macro='Bravo !'

	Теперь, в режиме редакции, по <tt>Ctrl+F1</tt> в поле будет записан текст
Bravo !

	Это удобно, когда надо в интерактивном режиме занести во многие поля
сходную информацию.

	В режиме редакции дополнительно определены следующие макросы:
		<tt>Alt+(</tt>	=	() и курсор внутри скобок
		<tt>Alt+)</tt>	=	() и курсор снаружи
		<tt>Alt+{</tt>	=	{}
		<tt>Alt+"</tt>	=	[]
		<tt>Alt+A</tt>	=	.AND.
		<tt>Alt+O</tt>	=	.OR.
		<tt>Alt+B</tt>	=	{||}
		<tt>Alt+C</tt>	=	CTOD("//")

	Это особенно удобно при задании выражений условия.

	Можно определить и свои макроклавиши:

		{<tt>Alt+G</tt>} __SetFunction(&lt;код клавиши>,&lt;macros>),
	или с помощью <a href="#p16_f">команды #MACRO</a> в ini-файле.
	Кроме того, в режиме редакции доступны "горячие" клавиши
преобразований текущего фокуса ввода (такие же действуют и в BROWSE):
		<tt>Alt+U</tt>	= UpperCase
		<tt>Alt+L</tt>	= Lower
		<tt>Alt+K</tt>	= Capitalize
		<tt>Alt+P</tt>	= Proper
		<tt>Alt+Q</tt>	= QWERTY->ЙЦУКЕН (если вы случайно набрали что-то
			  в "английской" раскладке вместо "русской").
		<tt>Alt+Y</tt>	= наоборот.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p18">
<h4>18.Выход в OS.</h4><pre>

	При выходе в DOS (<tt>Alt+F10</tt>) BDBFS занимает в памяти 8k.

	Если Вы хотите прямо запустить из под BDBFS большую программу,
можно воспользоваться функцией

	{<tt>Alt+G</tt>} BliRun('FoxPro').

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p19">
<h4>19.Использование мышки.</h4><pre>

		В режиме просмотра действуют следующие правила:

	- любая кнопка на строке названия базы = Select Base
	- любая кнопка на строке названий полей = Set Fields
	- любая кнопка на функциональной строке = соответствующей
	  функции (исключение: правая на <tt>F10</tt> заканчивает без спроса),
	  в т.ч. и с Ctrl, Shift и Alt
	- любая кнопка на нижней полоске скроллинга - сдвижка на
	  относительную позицию поля в файле
	- любая кнопка в основном пространстве (4-MaxRow()-3 строка) =
	  переход на это поле
	- левая кнопка на том же самом поле = <tt>Enter</tt>
	- правая - вызов контекстного меню
	- любая кнопка на MaxCol() колонке - сдвижка в файле на
	  относительную позицию.

		В режиме выбора по Achoice (н-р, при выборе индекса):

	 - правая=<tt>Escape</tt>
	 - левая на верхней рамке = <tt>PgUp</tt>
	 - левая на нижней рамке = <tt>PgDn</tt>
	 - левая внутри - первый раз:встать на элемент, второй:выбрать

		В меню и в режиме редакции:

	 - правая=<tt>Escape</tt>
	 - левая=<tt>Enter</tt>

		При выводе предупреждающих сообщений - любая=Аникею.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p20">
<h4>20.Совместимость с FoxPro.</h4><pre>

	BDBFS умеет смотреть и редактировать файлы FoxPro, в т.ч. 
Visual Foxpro. Полностью поддерживаются индексные файлы, за исключением 
некомпактных.

	Как уже отмечалось, в Browse поддерживаются клавиши
<tt>Tab, Shift+Tab, Ctrl+T</tt>.
	Системные переменные печати и количества обработанных записей имеют
те же названия, что и в FoxPRO.
	В выражениях можно использовать почти все функции FoxPro,
не связанные с экранными (Screen, Menu) и печатными формами.
	Обеспечивается правильность блокировок в сети.


	Существует "языковая" проблема в BDBFS, связанная с разницей
в диалектах Clipper и FoxPro.
	Существует CDX, одноименный с базой(а это чаще всего).
	В этом CDX есть тэг, созданный с помощью некорректного (с точки
зрения CLIPPER, но не FOXPRO) выражения. В этом случае драйвер
отказывается работать с таким CDX вообще, с сообщением об ошибке в
выражении. BDBFS же работу продолжает, но индексы не открыты. Где
возможно, надо такие тэги заменить на корректные.

	Если в текущем каталоге есть файл EUROPEAN.MEM, он считывается
при старте.


<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p21">
<h4>21.Работа в сети и мультизадачных системах.</h4><pre>

	Все файлы открываются в режиме совместного использования для
записи, что позволяет различным процессам использовать одну и ту же базу.
	Проверки проводились в сети NOVELL и в сессиях WINDOWS, OS/2, DV.

	Гарантируется совместная работа с xBase приложениями,
использующими стандартный режим блокировок. Не гарантируется совместна
работа, н-р, с Dbview от Norton-a.

	BDBFS самостоятельно отдает TimeSlice, так что при работе в
многозадачных системах нет необходимости в посторонних программах
типа TAME.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p22">
<h4>22.Обработка ошибок.</h4><pre>

	Вообщем-то, предпринято немало мер к тому, чтобы неправильные
действия не завершали полностью работу. Кроме того, ряд возможных
конфликтных ситуаций обходятся до их возникновения.

	Все же ошибки программы не исключены.
	В этом случае BDBFS рисует рамочку и пишет что-то вроде
		"Неверное выражение	трам-тарарам "
Большая просьба: запишите это трам-тарарам и сообщите автору.
Но имейте в виду, что такое сообщение может возникнуть и в результате,
н-р, Вашего неверного ввода выражения, тогда надо просто поправиться.

	Существует, однако, ряд невосстанавливаемых ошибок, н-р,
"Disk full". Возникнуть она может, например, при копировании файла
(проверить заранее трудно, т.к. неизвестно, сколько места займет файл,
отобранный по условию).

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p23">
<h4>23.Выражения цветности.</h4><pre>

	Вы можете выделить цветом в текущем поле записи, отвечающие
определенному условию. Например,

		{<tt>Alt+B</tt>} data > date()

	Цвет определяется 6 и 7 парой основного цвета редакции.
Имейте ввиду, что удаленные записи показываются 4 и 5 парой.

	Изменить цвета можно, исправив <a href="#pp4">переменную</a> _bm, через
задание выражений или меню Файл - Установки - Цвета.

	Чтобы снять подсветку (вернуться к стандартным цветам), надо нажать
<tt>Alt+Shift+B</tt>.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p24">
<h4>24. Работа с буфером обмена.</h4><pre>

	В BDBFS поддерживается буфер обмена, который действует и в
режиме View и в режиме Get. Для записи значения текущей ячейки в режиме
View или текущего значения редакции - нажмите <tt>Ctrl+Grey+</tt>. Для ввода в
ячейку (при соответствии типов) - <tt>Alt+GreyEnter или Ctrl+Grey-</tt>.

	 Непосредственно с ClipBoard и текущей ячейкой можно производить
операции <em>	+ - * /</em>
(последние 2, естественно, только с числовыми значениями), нажима
<tt>Alt+соответствующие серые</tt>. Посмотреть текущее значение ClipBoard можно
по <tt>Ctrl+Enter</tt>.

	В режиме редактирования memo-полей доступен вывод из ClipBoard.
Во время вывода результата вычисления, суммирования, etc доступна
запись вычисленного в ClipBoard. Впрочем, можно и прямо в поле.

	Операции занесения в буфер доступны и при выводе результатов
операций.

	Очень удобно пользоваться ClipBoard для задания различных
условий. Например, Вы задали длинное выражение поиска. Запомните
его по <tt>Ctrl+</tt>. Теперь Вы хотите все записи, удовлетворяющие этому
условию скопировать. Перейдите в диалог копирования и при запросе
условия нажмите <tt>Ctrl-</tt>.

	Буфер содержит все значения, помещенные в него в текущем сеансе.
Если их больше одного, то при вставке предлагается выбор. Если Вам не
нравится такое поведение, можно через меню или в файле инициализации задать
значение переменной _ClipChoice:=.F., тогда всегда будет использоваться
последнее значение.

	При работе в Windows доступен и системный ClipBoard.
Туда (и оттуда) можно скопировать текущее поле. Эти операции доступны
через <tt>Ctrl+Ins, Shift+Ins (серые)</tt>. Для использования системного буфера
в Windows 2000/XP необходимо наличие утилиты <em>bdb_wclp</em> (включена в
поставку) где-нибудь в пути.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p25">
<h4>25.История условий и выражений.</h4><pre>

	Все условия, выражения, списки полей, задаваемые во время сеанса
работы, а также результаты вычислений, суммирования, подсчетов заносятся
в историю, при этом проводится контроль на неповторяемость. Соответственно,
при задании условий и выражений, можно эту историю использовать.
	Клавиша <tt>F4</tt> (<tt>Ctrl+Down</tt>) вызывает историю текущего условия,
		<tt>Alt+F4 (Ctrl+Shift+Down)</tt> - всех условий,
		<tt>Ctrl+F4</tt> - результатов.

Ненужные условия можно стирать при помощи клавиш <tt>F8</tt> или <tt>Ctrl+D</tt>.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p26">
<h4>26.Стек позиций.</h4><pre>

	Можно запомнить до 10 позиций(записей) в базе и переходить к ним
по мере надобности. Такая возможность характерна для текстовых редакторов;
не знаю, насколько она будет полезна здесь. Тем не менее, WordStar &
Borland были "ограблены" и по <tt>Ctrl+K</tt> 0..9 устанавливаются закладки,
восстанавливаемые по <tt>Ctrl+Q</tt> 0..9. После нажатия <tt>Ctrl+K</tt> или <tt>Ctrl+Q</tt> нажатие
0..9 ожидается в течение 20 секунд, затем сбрасывается.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p27">
<h4>27.Редакция memo-полей и внешних файлов.</h4><pre>

	Для редакции memo-полей, а также внешних файлов (по нажатию <tt>F4</tt>
в файлере или через меню "Файл" - "Редактировать текст"), можно
использовать внутренний или внешний редактор. Внутренний редактор
использует стандартный MemoEdit и используется, если не задана (например,
в ini-файле) переменная _MemoEditor. Переменная может быть задана как
строка, например, _MemoEditor:='c:\medit\me.exe' (тогда всегда будет
вызываться MultiEdit) или как массив массивов вида:
	{Маска названия поля,	// н-р "BMP*"
	 Внешний редактор,	// н-р "ME"
	 Смещение в memo-поле,	// по умолчанию 0 - все поле
	 Дополнительные опции,	// по умолчанию отсутствуют
	 Временный файл		// по умолчанию $$BDBF$$.COM
	 }.

	Внешний редактор может быть не задан, тогда предполагается, что в
memo-поле находится программа (например, скрин-сейвер), которая и
запускается на выполнение. Смещение в memo-поле бывает нужно задать,
если, скажем, memo-поле хранит разнородную информацию. Например, база -
пример из поставки Delphi (fish.dbf) содержит поле BMP, в котором сама
картинка хранится с 9 позиции.

<em>Пример:</em>
	_MemoEditor:={	{'BMP','pv',9,' /d'},;
			{'SAVER','',0,'','tmp.com'},;
			{'*','ME',0,''} }
	Итак, на поле с названием BMP будет вызываться PV.EXE, поле с
названием SAVER содержит исполняемые программки, а для редакции всего
остального будет вызван MultiEdit.

	Внутренний редактор не может редактировать файлы размером более
64K. Но и при использовании внешнего редактора надо помнить, что
memo-поля формата DBT не способны хранить секции более 64K. Если Ваш файл
имеет большую длину, то при записи его в поле формата DBT он будет
обрезаться.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p28">
<h4>28.Печатные формы.</h4><pre>

	Помимо обычной печати по <tt>F2</tt>, можно использовать специальные
определения для печати форм из любых баз. Формы хранятся в обычных
текстовых файлах и содержат инструкции для определения колонок,
группировок, суммировок и т.п..

	В печатных формах (файлах-репортах) применяются следующие
переменные:

	_aExpr - массив выражений для каждой колонки.
	_aHead - массив заголовков колонок. Умолчание == _aExpr
	_aElen - массив ширин колонок. По умолчанию принимается
максимальным из ширины поля, ширины заголовка колонки и ширины шаблона
(_aPict) для данного поля. Если ширина выводимого поля больше,
чем ширина колонки, то делается корректный перенос (до 10-и строк на
колонку) по разделителям: пробел, точка, запятая, точка с запятой,
табуляция.

	_aPict - массив шаблонов колонок
	_aTitle - массив заголовка отчета. Умолчание - ничего.
		  Может быть задан как строка или массив строк
	_cFile - файл вывода. Умолчание - имя базы+'.PRN'
	_aSum - массив необходимости суммирования данной колонки
	_fCondit - условие печати
	_aFooter - имя дополнительной процедуры, печатающей подвал или
		   массив, содержащий подвал
	_pEveryStep - имя дополнительной процедуры или блока выполняющейся
перед печатью каждой строки, удовлетворяющей условию _fCondit


	_aGroup - массив, задающий подбивку по группе.
		Структура массива:
		{ &lt;Выражение группирования>,;
		  [&lt;массив или блок для печати заголовка группы>],;
		  [&lt;массив или блок для печати подвала группы>],;
		  [&lt;печать суммы только если в группе более 1 элемента>]
		}.
	Умолчание для:	заголовка группы: 'Код '+&&lt;Выражение группировки>.
			подвала группы: 'Всего'.
			печати суммы: .F. (печатать сумму всегда).

_nDouble - признак необходимости вывода в две колонки на листе.
	   Если 0 или не задан - печатается одна. Если задан числовой
	   параметр - воспринимается как количество пробелов между двум
	   колонками.

_NoAsk - ничего не спрашивать (принимаются заданные в файле условие
	 печати, файл вывода, диапазон все/оставшиеся)

_NoShow - не предлагать файл для просмотра и печати. Это удобно, если
	  нужно задать нестандартную обработку выведенного файла или вывода
	  нескольких автономных частей общего отчета в один файл.

_aPage - массив, задающий подбивку по странице.
	Структура: {&lt;массив или блок для печати заголовка страницы>,;
		    &lt;массив или блок для печати подвала страницы>}.
	Если определен, то печатаются итоги по странице, причем Header
	печатается, начиная со второй.

cDivideT, cDivide - символ разделения колонок соответственно, в
		    заголовке и информационных строках (умолчание - ':').

_nCounter - если >0, то слева выводит порядковый номер шириной _nCounter

CountName - название колонки "Номер по порядку" (умолчание "П/П"). Это
	    имеет смысл только задан _nCounter>0.

_PrintZero - печать нулевых значений, по умолчанию - .F.

	Следующие переменные могут быть дополнительно настроены прямо из
программы (по нажатию <tt>F9</tt> в диалоге начала печати).

Печать заголовков колонок на каждой
странице				_NeedHeadPage
Печать номеров страниц			_NeedPrPage
Прогон страниц после вывода листа	_NeedEject
Печать стандартной шапки отчета		_NeedMainHead
Печать шапки на каждой странице		_lTitleAll
Печать цифровых заголовков для колонок
	- на первой странице		_lDgtHdr
	- на следующих страницах	_lDhAll
Стартовая последовательность принтера	_PSCode
Конечная последовательность принтера	_PECode
Левая граница				_LMargin
Длина страницы (0=лента)		_Plength
Устройство-принтер			_printer
Дописывать ли файл вывода		_NeedApFile

	Файлы - отчеты имеют стандартное расширение .BPF и могут быть
загружены через меню "База" - "Считать файл-отчет".

См. также пример в поставке BDBFS.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p29">
<h4>29.Клавишные коды.</h4><pre>

	Нажимая в BDBFS на клавиши, обратите внимание на левый верхний
угол, где высвечивается код нажатой клавиши. Так можно обнаружить
ряд недокументированных в Clipper кодов.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p30">
<h4>30.Пользовательское меню.</h4><pre>

	Помимо общего меню, в BDBFS можно определить дополнительное меню
пользователя, доступное по <tt>F12</tt>. Для этого надо в инициализационном
файле определить два массива: UserMenuPrompts и UserMenuActs. Первый
следует заполнить строчками, предлагаемыми на выбор в меню, второй -
соответствующими блоками кода. Например, Вы хотите иметь возможность
запускать FoxPro из под BDBFS. Тогда в BDBFS.INI надо записать:
	UserMenuPrompts:={'Запуск FoxPro'}
	UserMenuActs:={ {||BluRun('Fox.exe')} }.

	Несколько примеров есть в Examples.Ini.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p31">
<h4>31.Проверка/коррекция базы.</h4><pre>

	Меня долго просили (а я упирался) сделать логический контроль
соответствия размера базы заголовку. Упирался я потому, что не желал
иметь дело с результатами работы кэшей и разнообразных сетевых
приложений. Да и утилит такого рода достаточно. Тем не менее, учитывая
тот факт, что ни одна из просмотренных утилит меня полностью не
удовлетворила, все-таки пришлось "спасаться своими руками" и така
проверка была включена. Сверяются 3 размера: логический (на основании
структуры), проставленный в заголовке и реальный физический. Если все
размеры совпадают, выдается сообщение об отсутствии ошибок. Иначе будет
показано меню с информацией о расхождениях и возможностью
синхронизировать размеры по одному из них. Рекомендую выбирать
логический, но у Вас, разумеется, может быть свое мнение и причины
предпочесть иное.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p32">
<h4>32.Плагины.</h4><pre>

	Ну какой нынче программный продукт без плагинов! Видно, иначе
нельзя! "Плагины" BDBFS - это обычные <a href="#p16">ini-файлы</a>, реализующие законченную
функцию. Несколько (возможно даже небесполезных) примеров есть в каталоге
PLUGINS. Присылайте мне плоды Вашего творчества. Лучшее будет опубликовано
на страничке и включено в поставку следующих версий. С указанием автора,
естественно.

	Плагины (и #include) файлы ищутся помимо текущего каталога в
пути, определенном переменной _PlugDir, а затем в пути, заданной
переменной окружения SET INCLUDE. По умолчанию, _PlugDir=каталог
запуска\Plugins. Вы можете задать (например, в BDBFS.INI) несколько
каталогов: _PlugDir:='c:\bdbfs\plugins; d:\MyOwn\plugins'

	К плагинам в программе можно обращаться как к обычным функциям,
если они имеют стандартное расширение .INI. Пусть, скажем, у Вас есть
плагин MyPlug.ini, вычисляющий некоторую функцию, основываясь на полях
базы. Тогда можно делать, например:
	{<tt>?</tt>} MyPlug()			// Вычислить текущее
	{<tt>Ctrl+F5</tt>} xVar:=MyPlug()*2	// Присвоить значение
	{<tt>F7</tt>} MyPlug() > 100		// Поиск

Плагину можно передать параметры (до 5).

	<em>Пример:</em> MyPlug(2,3,'Hello')

Для вызова плагина из плагина, а также в случае, когда плагин имеет
нестандартное расширение, используйте функцию RestoreIni().

	<em>Пример:</em> RestoreIni('MyPlug',2,3,'Hello')

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p33">
<h4>33.Запуск BDBFS.</h4><pre>

	Обычный запуск - BDBFS &lt;имя файла>[.DBF].

	Можно запустить с параметром * - тогда будут предложены
файлы на выбор. Можно запустить BDBFS *.Str - на выбор будут предложены
файлы с расширением STR. Можно использовать и символ ?.

	Параметр /i=&lt;indexname> задает загрузку файла вместе с указанным
индексом.

	Параметр /BW настраивает цвета на монохром. Впрочем,
на черно-белом EGA/VGA и так видно отлично.

	Порядок параметров /BW и /i= можно чередовать.


	При запуске с параметром-именем <a href="#p15">файла окружения</a> делается попытка
это окружение восстановить. Аналогично, с <a href="#p16">файлом инициализации</a>.

	<em>Пример:</em>
	 	BDBFS Envr.mem


	Параметры /DBFNTX /DBFCDX /DBFCTX /VFPCDX /SIXCDX /DBFIDX 
устанавливают соответствующий драйвер по умолчанию (обычно он определяется 
в BDBFS.INI). Можно также использовать короткую форму: /NTX /CDX /CTX /IDX.

	<em>Примеры:</em>
		BDBFS MyBase /VFPCDX		//Visual FoxPro driver

		BDBFS MyBase /ntx /i=char


	Параметр /CREATE позволяет начать работу с создания новой базы.

	<em>Пример:</em>
		BDBFS MyNew /CREATE

	Кроме того, есть несколько параметров, заставляющих BDBFS работать
в пакетном режиме - REINDEX, REBUILD, HTML, XML, XLS, PACK, CHECK, PRINT и
разновидности параметра STRUCT_. В пакетном режиме BDBFS выполняет
заданную операцию и завершает свою работу.

	Параметр REINDEX вызывает переиндексацию базы. Составной индекс
(CDX,NSX,MDX) переиндексируется автоматически, для переиндексации простого
индекса его надо указать в третьем параметре с ключом /i. Если ни одного
индекса не найдено, то будет выдано соответствующее сообщение.

	<em>Примеры:</em>
		BDBFS f_w_cdx REINDEX
		BDBFS f_w_ntx REINDEX /i=MyNtx.ntx


	Параметр REBUILD вызывает полную перестройку составного индекса
(CDX,NSX,MDX). Это дольше, чем переиндексация, зато в ряде случаев
позволяет избавиться от странных глюков и, почти всегда, ведет к
уменьшению размера индексного файла.

	<em>Пример:</em>
		BDBFS f_w_cdx /REBUILD


	Параметры HTM (HTML), XML, XLS вызывают экспорт файла DBF в
указанный формат.

	<em>Примеры:</em>
		BDBFS MyDbf HTM			// генерируется MyDbf.htm
		BDBFS MyDbf HTML=e:\1		// генерируется e:\1.htm
		BDBFS MyDbf /XLS	//генерируется MyDbf.xls

	Предупреждение о существовании файла выдается в любом случае,
так что если Вы желаете принудительно переписать существующий файл,
сначала уничтожьте его.
	Дополнительные сведения об экспорте содержатся в главе
<a href="#p5">"Append/Copy"</a>.


	Параметр PACK вызывает упаковку базы. Поскольку операция эта
опасная, дополнительный запрос все равно задается.


	Параметр PRINT вызывает печать файла <a href="#p28">печатной формы</a>.
Если имя файла не указано, ищется файл с именем, соответствующим базе.

	<em>Примеры:</em>
		BDBFS MyDbf /PRINT=Customer	// ищется Customer.BPF
		BDBFS MyDbf /PRINT		// ищется MyDbf.BPF


	Параметр CHECK вызывает <a href="#p31">проверку заголовка</a> базы.

	Параметр STRUCT_ позволяет задать автоматическое выполнение
операций, доступных интерактивно в режиме показа структуры (<tt>Alt+F2</tt>) через
клавиши <tt>F2, F4-F6, F10</tt>.
	Разновидности параметра:
		STRUCT_PRINT	- вывод структуры на печать.
		STRUCT_FILE	- файл описания структуры (расширение STP)
		STRUCT_EXTENDED	- файл структуры формата COPY STRU EXTENDED
				  (с расширением STE)
		STRUCT_COPY	- файл-копия структуры (расширение STR)
		STRUCT_PROGRAM	- создание программы, генерирующей эту
				  структуру и тэги компаундного индекса
				  (расширение STG).

	Все постфиксы параметра могут быть сокращены до 4-х символов.

	<em>Пример:</em>
		BDBFS MyDbf /STRUCT_PROG


	Параметр /FORCED запускает <a href="#p34">форсированный режим</a>.


	Для работы с каталогом можно применять команду FOR.

	<em>Примеры:</em>
// все переиндексировать
		FOR %%a in (*.DBF) DO bdbfs %%a REINDEX

// создать HTML в подкаталоге _HTMLS_
		echo y | DEL _HTMLS_\*.HTM
		FOR %%a in (*.DBF) DO bdbfs %%a HTM=_HTMLS_\%%a
		REN _HTMLS_\*.DBF _HTMLS_\*.HTM

Счастливые обладатели 4DOS могут сэкономить команду (и время):
		DEL /y _HTMLS_\*.HTM
		FOR %a in (*.DBF) DO bdbfs %a HTM=_HTMLS_\%@NAME[%a]

// создать документацию по базам данных
		FOR %%a in (*.DBF) DO BDBFS %%a /STRUCT_FILE
		ECHO Документация по базам данных системы > All_Dbf.txt
		FOR %%a in (*.STP) DO COPY All_DBF.TXT+%%a All_Dbf.TXT
		DEL *.STP

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p34">
<h4>34. Форсированный режим.</h4><pre>

	Стандарт файла DBF появился много лет назад. Уже вскоре после
принятия выявились его ограничения, особенно это касалось MEMO-полей, да
и бинарную информацию хотелось хранить и использовать более эффективно.
Не мудрено, что начали появляться всевозможные расширения формата, такие
как FPT файлы FoxPro, Varied поля и криптованные базы SIX и т.д.. Причем,
в последние несколько лет процесс ускорился, а взаимное "непонимание"
углубилось (несмотря на реализованную в Clipper правильную по сути идею
RDD). В частности, существующие стандартные и SIX-овские драйверы не
позволяют обрабатывать новые конструкции dBASE5, FlagShip и т.д.. 
Существуют также программы, позволяющие "обозвать" поля нестандартным 
способом (например, начинающиеся с цифры). Clip, в свою очередь умеет
обрабатывать базы Visual FoxPro, но не понимает форматы dBase4 и т.д..

	Всё это привело меня к мысли написать программу, позволяющую "на
лету" приводить нестандартные файлы к стандартным, а после завершения
работ - править "обратно". Такой режим и будем называть "форсированным".

	Итак, в форсированном режиме BDBFS понимает и поддерживает
следующие форматы:
	 - dBASE4, dBASE5 (поля типа Bitmap, новые заголовки);
	 - FlagShip (поля типа 2,4,8, новые заголовки);
	 - FoxBase 1.0 (заголовок);
	 - FlexMemo (memo-поля);
	 - и, потенциально, все другие возможные типы полей, которые в
этом случае будут считаться и обрабатываться, как символьные.

	Нестандартные названия полей преобразуются следующим
образом:
	- если в заголовке указан CodePage FoxPro от 1200 до
	  1299, то выполняется AnsiToOem()
	- неалфавитно-цифровые символы заменяются на символ "_"
	- если название начинается с цифры, то оно предваряется
	  символом "_".

	На сегодняшний день действуют следующие ограничения для работы
в форсированном режиме:

	- база используется только в монопольном режиме (напомню, ее
	  приходится для этого специальным образом исправлять);
	- если "форсированная" база содержит memo-поля, запрещена
	  упаковка;
	- запрещена модификация структуры;


	Форсированный режим включается либо указанием ключа <a href="#p33">командной
строки</a> /FORCED (например, BDBFS mybase /forced), либо указанием
переменной _lForced:=.t. в <a href="#p16">инициализационном файле</a>. Кроме того, если
нестандартная структура обнаружена при открытии файла, а форсированный
режим еще не включен, задается вопрос о включении с указанием
предположительного формата.

	Для доступа к некоторым "нестандартным" типам полей (например, при
использовании в выражениях, при поисках) нужно использовать специальные
функции (обычные редакция, просмотр, замещение дополнительных усилий не
требуют):
	- содержимое memo-поля, полей типа bitmap
		MemoSrc(&lt;field_name>) - возвращает строку
	- поле типа 2
		Bin2I(&lt;field_name>) - возвращает число

	<em>Пример:</em>
// Установить фильтр для поля Cur1 типа Currency
		{<tt>Alt+Shift+F</tt>} YToCurs(Cur1)>100


	Еще раз напомню, для обработки базы в форсированном режиме,
приходится исправлять её заголовок! Поэтому, если во время работы,
например, мигнет свет, или, скажем, Вы по ошибке прибили сессию, то
структура базы будет испорчена! 

	<em>ПОЭТОМУ, ИСПОЛЬЗУЙТЕ ЭТОТ РЕЖИМ НА СВОЙ СТРАХ И РИСК!</em>

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p35">
<h4>35.Видео-режимы.</h4><pre>

	BDBFS корректно поддерживает все ранее установленные текстовые
режимы - от 40*25 до 132*60 и т.д.. Однако, если Вы запустили из под
BDBFS программу, изменившую режим экрана - возможны неприятности.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p36">
<h4>36.Языковый интерфейс.</h4><pre>

	Может вызвать удивление смешение в сообщениях и Help-ах
русского и английского. Ориентация здесь была такая: то, что стандартно
и адресовано, в основном, программисту - английское, остальное по-русски.
Help Вы можете сами переписать, как вздумается - см.файл BDBFS.HLP.
Каждая главка заканчивается символом <em>~</em>. Соответственно, его использовать
в тексте нельзя. В остальном ограничений нет, пишите как сочтете нужным.
Если кто-то удосужится переписать HELP полностью на английском,
украинском или любом другом языке - я буду очень признателен за версию.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p37">
<h4>37.Планы.</h4><pre>

	BDBFS уже почти не развивается, во-первых, из-за достаточной
полноты; во-вторых, из-за нехватки времени; в третьих, из-за малого
количества пожеланий :-). Вы можете это исправить :-) ! Естественно,
вышесказанное не относится к портированию на CLIP и другие платформы
- тут работы непочатый край.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p38">
<h4>38.Чего в BDBFS нет по сравнению с "конкурентами".</h4><pre>

	Мне приходилось видеть в продуктах аналогичного назначения
некоторые возможности, отсутствующие сейчас в BDBFS.
Вот их перечень:

	* календарь - не вижу смысла, IMHO не ORGANIZER это, но мнения...
	* экспорт/импорт 1-2-3 - IMHO слишком специализировано.
	* Подсчет стат-величин типа девиации и т.п. - аналогично
	  предыдущему пункту. А может быть кто-то плагином сделает.
	* Графики по полям базы - не будет, IMHO это дело спец-программ.
	* Просмотр экрана DOS - может быть...

	Буду благодарен за любые мнения по этому поводу.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p39">
<h4>39.Известные проблемы.</h4><pre>

	Помимо вновь обнаруживаемых ошибок, существует ряд известных
проблем, которые, возможно, будут устранены в будущем. К их числу
относятся:

	Базы новых форматов DBASE4, DBASE5, FlagShip, FlexMemo
поддерживаются только в <a href="#p34">форсированном режиме</a>.

	Не поддерживается #define с параметрами в <a href="#p16">ini-файлах</a>.
	Не поддерживается #xCommand с более, чем один параметром.


	Невосстанавливаемая ошибка "Переполнение диска".
	Проверить заранее свободное место трудно из-за того, что
неизвестно, сколько места займет скопированный файл.

	Индексы FoxPro, содержащие выражения типа alias.field (вместо
alias->field) вызывают ошибку при любой операции, вызывающей изменение
индекса. Даже и не знаю, что с этим делать...

	Некомпактные IDX (FoxBase) не поддерживаются. Желающие могут
воспользоваться специальной версией (BDBFP), которая может быть <a href="http://www.geocities.com/bondar_eugen/bdbfs_ru#DownLoad">загружена</a>
с моей странички.

	Не работает поиск в индексах FoxPro, сделанных с установленной
COLLATE.


<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p40">
<h4>40.Благодарности.</h4><pre>

	Nantucket(CA принципиально не буду), American Cybernetics,
Assembler Software, Borland, SuccessWare - за использованные продукты.

	Портирование на CLIP было бы невозможно без
<a href="mailto:uri@itk.ru">Юрия Хныкина uri@itk.ru</a> и всей <a href="http://www.itk.ru">команды CLIP - www.itk.ru</a>

	Авторам Софтпанорамы и эхо-конференций.

	Всем корреспондентам, присылавшим замечания и предложения.

	Особая признательность Кужию Л.Б.(Львов) за тщательное
тестирование и множество дельных предложений.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p41">
<h4>41.Дальнейшие ругательства.</h4><pre>

	Присылать по адресу:
		Луганск, 91024, Ленинградская 8,
		Бондарю Евгению Леонидовичу

		[0642] 46-34-19	<a href="mailto:elb@lg.bank.gov.ua">E-Mail:elb@lg.bank.gov.ua</a>
 			<a href="mailto:Bondar_Eugen@yahoo.com">или Bondar_Eugen@yahoo.com</a>

	<a href="http://www.geocities.com/bondar_eugen/bdbfs_ru.htm">Страничка: http://www.geocities.com/bondar_eugen/</a>

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="p42">
<h4>42.Форма распространения.</h4><pre>

	BDBFS распространяется в бСССР свободно, причем версия дл
CLIP - в исходных текстах. Любое вознаграждение, в т.ч. моральное ;-),
будет принято с благодарностью.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="pp1">
<h4>ПРИЛОЖЕНИЕ 1.Сводка клавиш.</h4><pre>

	Помните, что ряд функций доступен только через меню.

<h5>A.Главный режим.</h5><pre>

<h6>Позиционирование:</h6><pre>
<!--Разрядка в строках - для IE-->
	По полям		<tt>Up Down Left Right PgUp PgDn</tt>

	На  последнее  поле	<tt>Ctrl+End</tt>
	На первое поле		<tt>Ctrl+Home</tt>

	Go top			<tt>Ctrl+PgUp</tt>
	Go  Bottom		<tt>Ctrl+PgDn</tt>


	К началу  следующей	<tt>Alt+PgDn</tt>
	страницы

	К началу предыдущей	<tt>Alt+PgUp</tt>
	страницы


<h6>Функции управления:</h6><pre>

	Вызвать главное меню		<tt>F10, Alt+V</tt>
	Вызвать пользовательское меню 	<tt>F12</tt>

	Выбрать базу			<tt>F4</tt>
	Открыть предыдущую базу		<tt>Ctrl+O</tt>

	Выбрать индексный файл		<tt>F5</tt>
	Реиндексировать			<tt>Alt+F5</tt>
	Индексировать			<tt>Alt+F9</tt>

	Добавить запись			<tt>F3, Ins</tt>
	Добавить с копированием		<tt>Alt+F3</tt>
	Вставить новую запись		<tt>Shift+F3</tt>

	Count   по  условию		<tt>Ctrl+F6</tt>
	Суммировать   текущее   поле	<tt>Alt+F6</tt>
	Total  по  текущему выражению	<tt>Alt+Shift+F6</tt>
	индекса


Замена:
			    Без подтверждения   С подтверждением
   Текущее поле - выражением	<tt>Alt+R		Alt+Shift+R</tt>
   Поле во всех записях
	постоянным выражением	<tt>Alt+F4		Alt+Shift+F4</tt>
   Поле во всех записях
	переменным выражением	<tt>Ctrl+F4		Ctrl+Shift+F4</tt>


	Редактировать  одну  запись    (EDIT)	<tt>Alt+E</tt>

	Редактировать символьное поле		<tt>Alt+W</tt>
	как memo-поле (для широких полей)
	Инвертировать логическое поле		<tt>Пробел</tt>

	Справка  о  базе  и  окружении		<tt>Alt+F1</tt>
	Показать/напечатать структуру		<tt>Alt+F2</tt>

	Присоединить из базы (текста)		<tt>Ctrl+F9</tt>
	Скопировать  в  базу (текст)		<tt>Ctrl+F3</tt>
	Копировать с преобразованием		<tt>Ctrl+Shift+F3</tt>
	формата MEMO-поля

	Сортировать				<tt>Alt+S, Ctrl+F11</tt>
	Меню установки фильтра			<tt>Alt+F, Alt+F11</tt>
	Установить фильтр по условию		<tt>Alt+Shift+F, Alt+Shift+F11</tt>

	Напечатать базу [принтер/файл]		<tt>F2</tt>
	Вывести запись в  &lt;base.rec>		<tt>Ctrl+P</tt>

	Изменить  структуру			<tt>Shift+F2</tt>
	Установить  поля и заголовки		<tt>Ctrl+F2</tt>

	"Заморозить"  текущее  поле 		<tt>Alt+Z</tt>
	и все поля левее

	Установить условие подсветки		<tt>Alt+B</tt>
	Вернуть стандартный цвет поля		<tt>Alt+Shift+B</tt>

	Создать HTML				<tt>Alt+></tt>


<h6>Функции поиска:</h6><pre>

	Встать на запись NN		<tt>F6</tt>
	Искать  по  индексу  (SEEK) 	<tt>F9</tt>
	Искать по условию  (LOCATE) 	<tt>F7</tt>
	Продолжить поиск (CONTINUE) 	<tt>Alt+F7</tt>
	Искать  по всем полям сразу 	<tt>Alt+I</tt>
	(контекстный поиск)
	Продолжить контекстный поиск	<tt>Alt+Shift+I</tt>
	Искать в текущем поле		<tt>F11</tt>
	(спец.для юзеров)
	Меню  поиска  в текущем поле 	<tt>Ctrl+Shift+F11</tt>
	Искать максимум/минимум		<tt>Alt+M</tt>
	Искать самое длинное		<tt>Ctrl+L</tt>
	значение в текстовом поле
	Искать дубль в индексе		<tt>Alt+2</tt>
	Искать  по  маске в индексе 	<tt>Alt+[</tt>
	Продолжить  поиск  по маске 	<tt>Alt+Shift+[</tt>


<h6>Уничтожение/восстановление:</h6><pre>

	Пометить/восстановить
	текущую запись			<tt>Del, Ctrl+T</tt>
	Пометить по условию		<tt>Ctrl+F8</tt>
	Восстановить по условию		<tt>Ctrl+F7</tt>
	Инвертировать пометки		<tt>Ctrl+Shift+F8</tt>

	Упаковать     (PACK) 		<tt>F8</tt>
	Уничтожить все (ZAP)		<tt>Alt+F8</tt>

	Очистить текущее поле		<tt>Shift+F4</tt>
	Очистить  все  поля  записи 	<tt>Ctrl+Y</tt>


<h6>Буфер обмена:</h6><pre>

	Записать  в  буфер  Windows 	<tt>Ctrl+Ins</tt>
	Записать из  буфера Windows 	<tt>Shift+Ins</tt>
	Записать во внутренний буфер	<tt>Ctrl+Grey+</tt>
	Записать из  буфера 		<tt>Ctrl+Grey-, Alt+GreyEnter</tt>
	Буфер = Буфер + Поле 		<tt>Alt+Grey+</tt>
	Буфер = Буфер - Поле		<tt>Alt+Grey-</tt>
	Буфер = Буфер / Поле		<tt>Alt+Grey/</tt>
	Буфер = Буфер * Поле		<tt>Alt+Grey*</tt>
	Показать буфер			<tt>Ctrl+Enter</tt>

<h6>Прочее:</h6><pre>

	Закончить  работу   			<tt>Esc</tt>
	Закончить  без  подтверждения		<tt>Alt+X</tt>

	Вызов  2-го  командного  процессора  	<tt>Alt+F10</tt>
	Сменить  диск  и  директорию		<tt>Ctrl+F10</tt>

	Выполнить макро-функцию			<tt>Ctrl+F1</tt>
	Установить  переменную  или  массив  	<tt>Ctrl+F5</tt>
	Вычислить выражение			<tt>Shift+F6, Alt+G, ?</tt>

	Перевести в строчные			<tt>Alt+L</tt>
	Перевести в прописные			<tt>Alt+U</tt>
	Первая=Alt+U, остальные=Alt+L		<tt>Alt+K</tt>
	(капитализация)
	Преобразовать QWERTY->ЙЦУКЕН		<tt>Alt+Q</tt>
	Преобразовать ЙЦУКЕН->QWERTY		<tt>Alt+Y</tt>
	QWERTY->ЙЦУКЕН->QWERTY			<tt>Ctrl+Shift+X</tt>
	Выровнять 				<tt>Alt+J</tt>

	Скопировать поле сверху			<tt>Alt+Up</tt>
	Скопировать поле снизу			<tt>Alt+Down</tt>
	Скопировать поле слева			<tt>Alt+Left</tt>
	Скопировать поле справа			<tt>Alt+Right</tt>

	Обменяться  с верхней записью		<tt>Ctrl+Up</tt>
	Обменяться  с нижней записью		<tt>Ctrl+Down</tt>

	Обменять поле с верхней записью		<tt>Alt+Shift+Up</tt>
	Обменять поле с нижней записью		<tt>Alt+Shift+Down</tt>

	Установить закладку			<tt>Ctrl+K</tt> + 0..9
	Перейти  к закладке			<tt>Ctrl+Q</tt> + 0..9


	Сохранить обстановку			<tt>Shift+F1</tt>
	Восстановить обстановку			<tt>Shift+F5</tt>
	Сохранить обстановку
	в  AutoOpen  файле 			<tt>Ctrl+Shift+F1</tt>

	Загрузить инициализационный файл      	<tt>Ctrl+F12</tt>

	Вызвать Filer				<tt>Alt+F12</tt>

	Освежить  просмотр  (в сети) 		<tt>Ctrl+R</tt>

	Отменить  исправления  в  поле		<tt>Ctrl+U, Alt+BS</tt>


<h6>Работа с компаундными индексами (CDX,MDX,NSX):</h6><pre>

	Выбрать TAG				<tt>Alt+T, Shift+F12</tt>
	Установить  TAG  по  номеру 		<tt>Shift+F7</tt>
	Установить  TAG  по   имени 		<tt>Shift+F8</tt>
	Сделать  новый  TAG			<tt>Shift+F9</tt>
	Удалить TAG				<tt>Shift+F10</tt>
	Установить другой CDX			<tt>Shift+F11</tt>



<h5>B.Режим ввода по GET</h5><pre>

<h6>Позиционирование:</h6><pre>

	Передвижение в поле		<tt>Left, Right</tt>
	Передвижение между записями 	<tt>Up, Down, PgUp, PgDn</tt>
	Не меняя позиции от начала поля	<tt>Shift+Up, Shift+Dn, Shift+PgUp, Shift+PgDn</tt>

	Следующее поле			<tt>Tab</tt>
	Предыдущее поле			<tt>Shift+Tab</tt>

<h6>Функции управления:</h6><pre>

	Добавить запись 			<tt>F3</tt>
	Переключить режим вставки/переписи	<tt>Ins</tt>
	Очистить  поле  			<tt>Ctrl+Y</tt>
	Завершить ввод без записи		<tt>Esc</tt>
	Завершить ввод с записью		<tt>Enter, Ctrl+W, Ctrl+End</tt>
	Отменить изменени			<tt>Ctrl+U, Alt+BS</tt>

	Переключить <a href="#p3">режим ввода</a> 		<tt>F4</tt>
	Вставить строку символов из "MACRO"	<tt>Ctrl+F1</tt>
	Рассматривать следующую комбинацию
	клавиш,  как код			<tt>Ctrl+Q, Ctrl+2</tt>

	Скопировать поле сверху 		<tt>Alt+Up</tt>
	Скопировать поле снизу  		<tt>Alt+Down</tt>
	Инвертировать логическое		<tt>Пробел</tt>

	Перевести в строчные    		<tt>Alt+L</tt>
	Перевести в прописные   		<tt>Alt+U</tt>
	Первая-прописная, остальные-строчные	<tt>Alt+K</tt>
	(капитализация)
	Преобразовать QWERTY->ЙЦУКЕН    	<tt>Alt+Q</tt>
	Преобразовать ЙЦУКЕН->QWERTY    	<tt>Alt+Y</tt>
	QWERTY->ЙЦУКЕН->QWERTY  		<tt>Ctrl+Shift+X</tt>

	Записать в буфер			<tt>Ctrl+Grey+</tt>
	Записать из буфера			<tt>Ctrl+Grey-, Alt+GreyEnter</tt>
	Записать в буфер Windows		<tt>Ctrl+Ins</tt>
	Записать из буфера Windows		<tt>Shift+Ins</tt>

	Пометить/восстановить текущую   	<tt>Shift+Del</tt>


<h5>C.Режим SET FIELDS.</h5><pre>

	Убрать поле из списка   		<tt>DEL, Ctrl+Y</tt>
	Изменить порядок			<tt>Ctrl+Down, Ctrl+Up</tt>
	Восстановить предыдущие установки	<tt>F5</tt>
	Завершить изменения     		<tt>F10</tt>
	Отменить изменения			<tt>Esc, Alt+X</tt>


<h5>D.Режим MODIFY STRUCTURE</h5><pre>

	Изменить реквизит (если возможно)	<tt>Enter</tt>
	Добавить новое поле     		<tt>F3</tt>
	Удалить поле    			<tt>F8</tt>
	Вставить поле перед текущим		<tt>F5, Ctrl+N</tt>
	Установить нужный тип   		<tt>C,N,D,L,M,F,V</tt>
	(находясь в поле типа)
	Оптимизировать структуру		<tt>F9</tt>
	Завершить и сохранить изменения  	<tt>F10</tt>
	Отменить изменения			<tt>Esc</tt>


<h5>E.Режим просмотра структуры</h5><pre>

	Печать на устройство-принтер		<tt>F2, Shift+Tab</tt>
	Вывод в текстовый файл (*.STP)		<tt>F4</tt>
	Вывод  в  файл  со структурой (*.STR)	<tt>F6</tt>
	-"- с расширенной  структурой (*.STE)	<tt>F5</tt>
	Настройка  печати     			<tt>F9</tt>
	Создание программы, генерирующей эту 	<tt>F10</tt>
	структуру и тэги компаундного индекса
	(*.STG)
	Перейти на текущее поле			<tt>ENTER</tt>


<h5>F. Диалоги (условия или выражения)</h5><pre>

	Подобрать выражение из истории:
		данного условия 		<tt>F4, Ctrl+Down</tt>
		всех условий    		<tt>Alt+F4, Ctrl+Shift+Down</tt>
		результатов     		<tt>Ctrl+F4</tt>
	Ввести имя текущего поля		<tt>F2</tt>
	Имя любого поля  			<tt>Ctrl+F2</tt>
	Заголовок текущего поля 		<tt>F3</tt>
	Заголовок любого поля   		<tt>Ctrl+F3</tt>
	Значение текущего поля  		<tt>F5</tt>
	Значение текущего поля в кавычках	<tt>CTRL+F5</tt>
	Наименование текущей базы		<tt>F6</tt>
	Окавычить веденное			<tt>Alt+Shift+"</tt>
	Меню ввода      			<tt>F10</tt>

	В диалоге REPLACE символьного поля	<tt>F7</tt>
	меню функций

	В диалоге задания списка полей  	<tt>Alt+F2</tt>
	(COPY, SORT) - выбор полей


<h5>G.Режим просмотра результата (после вычисления, суммирования и т.п.)</h5><pre>

	Продолжить вычисления с результатом	<tt>F2</tt>
	Вывод результата в текущее поле 	<tt>F5</tt>
	Занесение результата в буфер    	<tt>Ctrl+Ins</tt>
	Преобразовать в "денежный" формат	<tt>$</tt>
	(519234 - > 5,192.34)
	Меню занесения  			<tt>F10</tt>


<h5>H.Режим редакции текстового файла или широкого поля (MEMOEDIT)</h5><pre>

	Печать  				<tt>F2</tt>
	Сохранение в файле			<tt>F3</tt>
	Загрузка из файла			<tt>F4</tt>
	Переключение режима авто-переноса
	строк   				<tt>F5</tt>
	Запись в текущую позицию буфера
	Windows - 95/98/ME			<tt>F6, Shift+Ins</tt>
	Настройка переменных просмотра  	<tt>F9</tt>
	Запись в текущую позицию внутреннего
	буфера  				<tt>Ctrl+Grey</tt>
	Удаление текущей строки 		<tt>Ctrl+Y</tt>
	Удаление слова справа   		<tt>Ctrl+T</tt>
	Реформирование параграфа		<tt>Ctrl+B</tt>
	Запись изменений и выход		<tt>F10, Ctrl+W</tt>
	Выход с подтверждением  		<tt>Esc</tt>
	Выход без сохранения    		<tt>Alt+X</tt>


<h5>I.Режим выбора файлов (Filer)</h5><pre>

	Смена текущего диска    		<tt>F2</tt>
	Просмотр текущего файла 		<tt>F3</tt>
	Редакция текущего файла 		<tt>F4</tt>
	Возврат к каталогу,
	с которого начался поиск		<tt>F5</tt>
	Смена маски просматриваемых файлов	<tt>F9</tt>
	Просмотр описания текущего файла
	из файла descript.ion   		<tt>F10</tt>

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="pp2">
<h4>ПРИЛОЖЕНИЕ 2. СООБЩЕНИЯ.</h4><pre>

	При открытии базы могут быть выданы следующие сообщения:

	&lt;имя файла> - поврежден или блокирован
		Заголовок базы поврежден или база захвачена другим процессом,
		или база помечена как ReadOnly. Для работы с файлами ReadOnly
		можно использовать BDBFS-Viewer. <a href="http://www.geocities.com/bondar_eugen/bdbfs_ru#DownLoad">См. информацию о загрузке</a>.

	&lt;имя файла> - поврежден
		Есть повреждения в списке полей базы

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="pp3">
<h4>ПРИЛОЖЕНИЕ 3. Поддерживаемые функции.</h4><pre>

	Как уже отмечалось, можно использовать почти все системные
	функции Clipper.

AADD		ABS		ACHOICE		ACLONE		ACOPY
ADEL		ADIR		AEVAL		AFIELDS		AFILL
AINS		ALIAS		ALLTRIM		ARRAY		ASC
ASCAN		ASIZE		ASORT		AT		BIN2I
BIN2L		BIN2W		BOF		BREAK		CDOW
CHR		CMONTH		COL		CTOD		CURDIR
DATE		DAY		DAYS		DBAPPEND  	DBCLEARFILTER
DBCLEARINDEX	DBCLEARREL	DBCLOSEALL	DBCLOSEAREA	DBCOMMIT
DBCOMMITALL	DBCREATE  	DBCREATEINDEX	DBDELETE  	DBEVAL
DBF		DBFILTER  	DBGOBOTTOM	DBGOTO		DBGOTOP
DBRECALL  	DBREINDEX 	DBSEEK		DBSELECTAREA	DBSETFILTER
DBSETINDEX	DBSETORDER	DBSETRELATION	DBSKIP		DBSTRUCT
DBUNLOCK  	DBUSEAREA 	DELETED		DESCEND		DEVOUT
DEVPOS		DIRECTORY 	DISKSPACE 	DISPBOX		DOW
DTOC		DTOS		ELAPTIME  	EMPTY		EOF
EVAL		EXP		FCLOSE		FCOUNT		FCREATE
FERASE		FIELDGET  	FIELDNAME 	FIELDPUT  	FILE
FLOCK		FOPEN		FOUND		FREAD		FREADSTR
FRENAME		FSEEK		FWRITE		GETE		GETNEW
HEADER		I2BIN		IF		INDEXKEY  	INKEY
INT		ISCOLOR		ISPRINTER 	L2BIN		LASTKEY
LASTREC		LEFT		LEN		LENNUM		LOG
LOWER		LTRIM		MAX		MAXCOL		MAXROW
MEMOEDIT  	MEMOREAD  	MEMORY		MEMOWRIT
MIN		MOD		MONTH		NETERR		NEXTKEY
PAD		PADC		PADL		PADR		PCOL
PCOUNT		PROCNAME  	PROW		QOUT		QQOUT
RAT		READEXIT  	READKEY		READMODAL 	READVAR
RECCOUNT  	RECNO		RECSIZE		REPLICATE 	RESTSCREEN
RIGHT		RLOCK		ROUND		ROW		RTRIM
SAVESCREEN	SCROLL		SECS		SECONDS		SELECT
SET		SETBLINK  	SETCOLOR  	SETCURSOR  	SETKEY
SETPOS		SOUNDEX		SPACE		SQRT		STR
STRTRAN		STRZERO		STUFF		SUBSTR		TBCOLUMNNEW
TBROWSEDB  	TBROWSENEW	TIME		TONE		TRANSFORM
TSTRING		TYPE		VAL		VALTYPE		UPDATED
UPPER		USED		WORD		YEAR,

а также часть специальных недокументированных функций, начинающихся с __ .
Заядлые клипперисты меня поймут, остальные все равно пользоваться не будут.
Специально для "заядлых"! Я не гарантирую, что все __ функции всегда будут
вести себя так, как Вы привыкли. Часть из них была в специальных целях
переписана.

Функции SIX

BAG2TAG		SXCHAR		SXDATE		SXLOG		SXNUM
SX_BLOB2FILE	SX_DATEVAL	SX_DBFDECR	SX_DBFENCR	SX_DECRYPT
SX_DTOP		SX_ENCRYPT	SX_FILE2BLOB	SX_FILEORDER	SX_FINDREC
SX_FNAMEPARSER	SX_GETLOCK	SX_IDTYPE  	SX_INDEXCOUNT	SX_INDEXNAME
SX_ISFLOCK	SX_ISLOCKED	SX_ISREADONLY	SX_ISSHARE	SX_KEYADD
SX_KEYCOUN	SX_KEYDATA	SX_KEYDROP	SX_KEYGOTO	SX_KEYNO
SX_KILLTAG	SX_MEMOBLK	SX_MEMOEXT	SX_ORDERCOUNT	SX_PTOD
SX_RLOCK  	SX_SETFILE	SX_SETMEMOBLOCK	SX_SETPASS	SX_SETTAG
SX_SLIMFAST	SX_TABLENAME	SX_TABLETYPE	SX_TAGCOUN	SX_TAGINFO
SX_TAGNO  	SX_TAGS		SX_TAGUNIQ	SX_VALDATE	SX_VFGET
SX_WILDMATCH	SX_WILDSEEK

M6_ADDSCOPED	M6_CHGOWNER	M6_DBEVAL  	M6_DBFILTER	M6_FILTADDREC
M6_FILTCHGREC	M6_FILTCOPY	M6_FILTCOUNT	M6_FILTDROPREC	M6_FILTINFO
M6_FILTINVERSE	M6_FILTJOIN	M6_FREEFILTER	M6_GETAREAFILT	M6_ISFILTER
M6_ISFILTREC	M6_ISOPTIMIZE	M6_NEWFILTER	M6_RECCOUNT
M6_REFRESHFILT	M6_ORDCOND	M6_ORDCREATE	M6_SET
M6_SETAREAFILT	M6_SETFILTER	M6_SETTEMP


Функции Nantucket Forum

FT_AADDITION	FT_AAVG		FT_ADESSORT	FT_AEMAXLEN	FT_AEMINLEN
FT_AMEDIAN	FT_ANOMATCHES	FT_ASUM		FT_AT2
FT_BYT2BIT	FT_BYT2HEX	FT_BYTEAND	FT_BYTENEG	FT_BYTENOT
FT_BYTEOR  	FT_BYTEXOR	FT_BITCLR  	FT_BITSET  	FT_D2E
FT_DEC2BIN	FT_DOSVER  	FT_E2D		FT_ELAPSED	FT_FDAY
FT_FINDITH	FT_GCD		FT_GETE		FT_GETMODE	FT_INT86
FT_ISBIT  	FT_HEX2DEC	FT_ISBITON	FT_ISPrint	FT_LASTKEY
FT_LDAY		FT_MADD		FT_METAPH  	FT_NOOCCUR	FT_PUTKEY
FT_ORIGIN  	FT_RAND1  	FT_ROUND  	FT_SQZN		FT_SYSMEM
FT_TEMPFIL	FT_UNSQZN  	FT_WORKDAYS	FT_XTOY


Функции Netto

FN_BIN2HEX	FN_BIN2I  	FN_CONNID  	FN_CONNINF	FN_CONNNUM
FN_DEFCID  	FN_DEVTYPE	FN_ERROR  	FN_FSNAME  	FN_GETSN
FN_HEX2BIN	FN_I2BIN  	FN_INETADD	FN_NAMEL
FN_NETVER  	FN_NONULL  	FN_OBJCNUM	FN_PEEKSTR	FN_PFCONID
FN_POKESTR	FN_PRCONID	FN_SPFCID  	FN_SPRCID  	FN_STAADDR
FN_WHOAMI  	FN_WRCONNI	FN_WRFSNAM


Функции FoxPro

ALEN		ANSITOOEM  	ATC		BETWEEN		BINTOC
CDX		CEILING		CHRTRAN		CTOBIN		CTOT
DATETIME  	DMY		EVALUATE  	FILTER		FLOOR
GOMONTH		ID		INLIST		ISBLANK		KEY
NDX		OCCURS		OEMTOANSI  	PI		PROPER
SEEK		SIGN
SYS(0-3,5,6,10-16,21-23,1001,2000,2003,2012,2020,2021)


Функции Clipper Tools

CTOF            FTOC            XTOC            LIKE            Expand
CharOnly        CharRem         CharSpread


Функции, определенные специально для BDBFS, описаны в приложении IV.

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
<P><HR><a name="pp4">
<h4>ПРИЛОЖЕНИЕ 4.BDBFS-PRO.</h4><pre>

	Информация в этом приложении предназначена для желающих максимально
полно освоить BDBFS. Здесь приводятся сведения о вызове процедур и
функций BDBFS, а также использовании внутренних переменных.

<a name="pp4a">
	 <h5>A. Системные переменные.</h5><pre>

	Вы можете как угодно использовать в выражениях (примеры
выше) следующие переменные:

                                                            Умолчание
                                                            ---------
Переменные условий:
	Условие Locate          	_LCONDIT                ''
	Выражение поиска        	_GSearch                ''
	Условие Seek            	_FCONDIT                ''
	Условие Sum             	_SumCOND                ''
	Условие Print           	_PCOND                  ''
	Условие Count           	_CountCOND              ''
	Условие Delete          	_DelCOND                ''
	Условие вычисления       	_ECOND                  ''
	Условие Replace         	_RCOND                  ''
	Выражение Replace       	_Repl                   ''
	Условие фильтра         	_FltrCond               ''
	Условие сортировки      	_SortCond               ''
	Файл    сортировки      	_SortFile               ''
	Условие TOTAL           	_TotalCond              ''
	Файл    TOTAL           	_TotalFile              ''
	Выражение сортировки    	_ckSort                 ''
	Поля копирования        	_ckField                ''
	Условие экспорта в HTML 	_HtmlCond               ''
	Файл HTML               	_HtmlFile               ''
	Условие экспорта в XML  	_XmlCond                ''
	Файл XML                	_XmlFile                ''
	Условие экспорта в XLS  	_XlsCond                ''
	Файл XLS                	_XlsFile                ''
	Условие цветности       	_cb                     ''
	Условие индекса(тэга)   	_IndexFor               ''
	Глобальная история условий	_aGlbHcond              {}

Переменные результатов:
	Последняя сумма 		__Sum                    0
	Последний Count 		__Count                  0
	Последний результат     	__Go                     0
	Содержимое ClipBoard    	_ClipText               {}
	Выбор по истории при
	занесении из него		_ClipChoice             .T.
	Конвертация OEM/ANSI при
	работе с буфером WINDOWS	_lCnvWClip              .T.
	Директория перехода     	_newDir                 ''
	Количество обработанных 	_Tally                   0
	записей
	Глобальная история      	_aGlbHRes               {}
	результатов

Установки печати:
	Центровка чисел при выводе		_NeedCentr      .F.
	Печать символа 0 при нулевом числе	_PrintZero      .F.
	Печатать ли номера записей		_NeedRec        .T.
	Печать стандартной шапки отчета 	_NeedMainHead   .T.
	Печать шапки на каждой странице 	_lTitleAll      .F.
	Печать заголовков колонок на каждой
	странице				_NeedHeadPage   .T.
	Печать номеров страниц  		_NeedPrPage     .T.
	Печать цифрового заголовка      	_lDgtHdr        .F.
	для колонок
	 - в т.ч. на каждой странице    	_lDhAll         .F.
	Прогон страниц после    		_NeedEject      .T.
	Стартовая последовательность    	_PSCode         ''
	принтера
	Конечная последовательность     	_PECode         ''
	принтера
	Левая граница   			_LMargin        0
	Длина страницы  			_Plength        0(лента)
	Устройство-принтер			_printer        PRN
	Дописывать ли файл вывода		_NeedApFile     .F.
	Суммировать ли числовые поля     	_NeedSum        .T.
	Ширина вывода Memo-полей		_MemoPrnt       50
	при печати
	Максимальное количество строк при	_MemoNumLines   10
	выводе memo и широких текстовых
	полей
	Символ, разделяющий клетки в отчете	_DefaultBorder   :
	                      - в заголовке	_DefaultHBorder  :


Цветовая гамма:
	Основной цвет 		_Bm	 	'w/b,n/bg,N,r/w+,w+/r,w+/b,w+/r'
	Цвет Help и запросов 	_Im	 	'n/w+,g+/n'
	Цвет результатов       	_Cm	 	'Gr+/N,W+/B'
	Цвет меню    		_MenuColor	'Gr+/b,g+/b'
	Цвет невыбираемых
	элементов меню		HiddenColor	'w/b'
	Заголовки панелей  	_HdColor  	'G+/b*'

Интерфейс:
	Вывод индикатора        _lMeter 		.T.
	Шаг вывода индикатора   _Sx_Step		100
	Редактор Memo           _MemoEditor		'' (встроенный)
	Просмотрщик файлов      _TextViewer		'' (встроенный)
	Шаг табуляции memo      _nMemoTab		  8
	Граница автопереноса    _nMemoWrap		255
	Замер времени           _Timing 		.T.
	исполнения
	Ширина показа имен      _DirShow        	 16
	файлов в Файлере
	Реакция на нажатие	__aExt			{}
	ENTER в Файлере
	(структура массива: {{маска1, команда1}, {маска2, команда2}...} )

Прочее:
	Текущая база                    _base
	Текущий индексный файл          _oldind
	TBrowse object                  _BDBFBrow
	Текущее поле                    _C_F
	Содержимое текущего поля        __Content
	Текущий тэг                     _TagName
	Текущий компаунд                __CDX
	Маска поиска файлов             _Mask           '*.dbf'
	Текущий RDD                     _DefaultRDD     'DBFCDX'
	Текущее расширение Memo         _DefaultMemo    'FPT'
	Текущее расширение компаунда    _DefaultCDX     '.CDX'
	Пользовательское меню
		Строки                  UserMenuPrompts   {}
		Действия                UserMenuActs      {}
	Авто-сохранение окружения       _AutoSave       .F.
	Авто-восстановление окружения   _AutoRestore    .F.
	Стандартная клавиатура          _Usa_Keyboard   'QWERTY......'
	Национальная клавиатура         _My_Keyboard    'ЙЦУКЕН......'
	DOS (866) кодировка             _Oem_Set        'АБВГДЕ......'
	WINDOWS (1251) кодировка        _Ansi_Set       'L+T+-+......'
	Максимальное количество
	отображаемых полей              _nBrowMaxField  170
	Размер буфера UNDO              _UndoSize       1024
	Форсированный режим             _lForced        .F.
	Запрос на перекодировку
	OEM -> ANSI при экспорте        _lexp_o2aq      .T.
	Необходимость перекодировки     _lexp_o2        .T.
	Путь поиска плагинов            _PlugDir        Путь к BDBFS\PLUGINS

<a name="pp4b">
<h5>B.Вызываемые функции.</h5><pre>

	Любую внутреннюю функцию BDBFS, также как и системную, можно
вызвать в любых режимах BDBFS. Наиболее естественным выглядит
использование либо в режиме вычисления (<tt>Shift+F6, Alt+G, ?</tt>),
либо в режиме присвоения (<tt>Ctrl+F5</tt>).

	<em>Примеры:</em>
	{<tt>Alt+G</tt>}	Aver('Example')
	{<tt>Ctrl+F5</tt>}	UPC=Aver('Example')

	Для наглядности пояснения будем вести на учебной базе

<tt>	NAME	 S02	S03	S04</tt>
	Your	 12	 1	13
	Your1	 32	 2	33
	My	 10	 3	10
	My1	 30	 4	 0

<a name="pp4b1">
<h6>1.Функции вычисления.</h6><pre>

<HR>
	SUM(&lt;ExprC>[,&lt;CondC>]) --> Число

	Суммирует базу по выражению ExprC для условия CondC.

	<em>Примеры:</em>
		<tt>{Alt+G}</tt>	(1)	Sum('S02+S03','[My] $ Name')
			(2)	Sum('S02','.t.')


	(1) возвратит 47 		(2) - 84

	Умолчание для CondC - все записи.

	Кроме возвращаемого значения результат запоминается в переменной
__Sum.

<HR>
	AVER(&lt;ExprC>[,&lt;CondC>]) --> Число

	Вычисляет среднее по выражению ExprC для условия CondC.

	Умолчание для CondC - все записи.

	<em>Пример:</em> {<tt>Ctrl+F5</tt>}	MediumS2=Aver('S02','[My] $ Name')

		 возвратит 21

<HR>
	COUN(&lt;CondC>) --> Число

	Подсчитывает количество записей, удовлетворяющих условию Condc.

	<em>Пример:</em> {<tt>Ctrl+F5</tt>}	CntMy=Coun('[My] $ Name')

		 возвратит 2

	Умолчание для CondC - все записи.

	Кроме возвращаемого значения результат запоминается в переменной
__count.

<HR>
	SumLine([поле1],[поле2]) --> Число

	Суммирует поля "вдоль" записи, от номера поля1 до номера поля2.
Если отсутствует FromField подсчет идет от первого, если отсутствует
ToField - до последнего. Нечисловые поля игнорируются.

	<em>Примеры:</em> (для первой записи)
		SumLine()	--> 26
		SumLine(1,2)	--> 12
		SumLine(3)	--> 14

	Кроме возвращаемого значения результат запоминается в переменной
__Go.

<HR>
	Like(cEtalon,cTest)

	Сравнивает 2 строки с учетом символов расширения ? и *.
В отличие от маски DOS допускает несколько * в имени. Показала те же 
скоростные результаты, что и такая же функция Clipper Tools (наверное, 
алгоритм тот же-напрашивающаяся рекурсия). Но EXE на 0.5 к меньше.

	<em>Примеры:</em>
		{<tt>F7</tt>} Like('spr*.dbf',FileName)

		{<tt>Alt+G</tt>} Like('?уб*a','дубина') --> .t.

<HR>
	Crc32(&lt;ExprC>)

	Считает контрольную сумму строки. Используется алгоритм PKZIP.

	<em>Пример:</em> Контрольная сумма всех полей:
		Crc32( Name+XTOC(s02)+XTOC(s03)+XTOC(s04) )

<HR>
	Rand([&lt;ExprN>])

	Возвращает псевдослучайное число в диапазоне от 0 до 1.
От каждого ExprN возвращается одинаковая последовательность.

	<em>Пример:</em> Rand(Seconds())

<HR>
	Random(&lt;nMin>,&lt;nMax>)

	Возвращает целое псевдослучайное число в диапазоне от
nMin до nMax.

	<em>Пример:</em> Random(0,1000)

<HR>
	RoundIt(&lt;nVar>,&lt;nPlace>)

	Правильное округление. Clipper не всегда правильно выполняет
операцию округления.

	<em>Пример:</em>
		Round(1.025,2)		-->	1.02
		RoundIt(1.025,2)	-->	1.03

<a name="pp4b2">
<h6>2. Функции преобразования.</h6><pre>

<HR>
	Capitalz(&lt;ExprC>) --> ExprC

	Преобразует символьное выражение в строку с первой заглавной.
При отсутствии параметра возвращает пустую строку.

	<em>Пример:</em>
		Capitalz('ЛУГАНСК')	--> Луганск

<HR>
	Padj(&lt;ExprC>,&lt;cAlign>,&lt;cFill>,&lt;nLen>) --> ExprC

	Выравнивает строку по длине &lt;nLen>.

	&lt;nlen> по умолчанию = длине текущего поля.

	Тип выравнивания определяется параметром &lt;cAlign>:
		"L" - Строка выравнивается по левому краю.
		"C" - Строка выравнивается по центру.
		"R" - Строка выравнивается по правому краю.
		"J" - Строка выравнивается по ширине (выключка).
		"E" - Строка расширяется символом &lt;cFill>.

	Если &lt;cAlign> не задан, предлагается выбор.

	&lt;cFill> - символ-заполнитель, по умолчанию пробел.

	<em>Примеры:</em>
		//Пусть длина текущего поля=12
		PADJ("Отчет",'C')	-->	"   Отчет    "
		PADJ("Отчет",'E')	-->	"О т ч е т   "
		PADJ("Мой отчет",'J')	-->	"Мой    отчет"

<HR>
	OemToAnsi(&lt;ExprC>)

	Преобразует строку в Windows кодировку (1251).
Украинские буквы поддерживаются согласно ГОСТ Украины.

	Вы можете изменить кодировку под ваши нужды, задав переменные
_Oem_Set, _Ansi_Set.

	<em>Пример:</em>
		OemToAnsi('ЛУГАНСК')	--> TL+L=T│

<HR>
	AnsiToOem(&lt;ExprC>)

	Обратная функция к OemToAnsi().

<HR>
	SplitLine(&lt;ExprC>)

	Преобразует строку в массив. Элементы массива отделяются по
запятым.

	<em>Пример:</em>
		SplitLine("Раз, Два, Три") --> {"Раз", "Два", "Три"}

<HR><a name="pp4dbtrans">
	dbTrans(cNewBase,Fields [,bFor,bWhile,nNext,lRest])

	Копирует базу в заданную с возможностью переименования или
преобразования полей.
	Список полей задается либо в кавычках (как строка), либо как
массив (что необходимо при задании выражений с запятыми). Если в списке 
полей не заданы вычисляемые поля, то работает аналогично системной команде 
COPY. См. также <a href="#p5">п.5. Append/Copy</a>.

	<em>Примеры:</em>
		DBTrans('NewFile','Char,Num AS Digit,Num*2 AS Double')

		DBTrans('NewFile',{'LEFT(Char,2) AS Symbol','Num'},;
				  {||Num&lt;>0})

<HR><a name="pp4tb2html">
	TB2Html([&lt;cHtmlFile>] [, &lt;cTitle] [, &lt;aDesign>])

	Экспортирует базу в формат HTML. Если название файла не задано -
запрашивается. Заголовок cTitle по умолчанию - имя базы.
Массив цветов aDesign имеет структуру:

		{background color,
		 table background,
		 text color для таблицы и заголовка,
		 text color для помеченных как DELE() записей}.

	По умолчанию используются: "navy","blue","white","red".

	<em>Пример:</em>
		Tb2Html('MyBase','WWW FOREVER!',;
			{'fffffc0','fffff80','00000ff','black'})

<HR><a name="pp4tb2xml">
	TB2Xml([&lt;cXmlFile>] [, &lt;cTitle] [, &lt;lYesNo>] [, &lt;cRecName>])

	Экспортирует базу в формат XML. Если название файла не задано -
запрашивается. Заголовок cTitle, записываемый в комментарии, по
умолчанию - имя базы (описание из Descript.ion записывается в
комментарии всегда). Параметр cRecName задает имя тэга для записи, по 
умолчанию - "Record". Если задан параметр lYesNo=.T., то для вывода 
логических величин используются строки Да/Нет, иначе - .T.,.F..

	<em>Пример:</em>
		Tb2Xml('MyBase',,"Employes",.T.)

<HR><a name="pp4tb2xls">
	TB2Xls([&lt;cXlsFile>] [, &lt;cTitle] [, &lt;lYesNo>])

	Экспортирует базу в формат XLS. Если название файла не задано -
запрашивается. Заголовок cTitle по умолчанию не задан. Если задан параметр
lYesNo=.T., то для вывода логических величин используются строки Да/Нет, 
иначе - .T.,.F..

	Пример:
		Tb2Xls('MyBase','Таблица продаж')

<a name="pp4b3">
<h6>3. Команды установки SET.</h6><pre>

	А. Команды-переключатели. Формат SetKKKK(&lt;ExprL>)
	При задании параметра &lt;ExprL> со значением .T. устанавливаются в ON.

	SetBell=Set Bell		SetDele=Set Deleted
	SetConf=Set Confirm		SetExac=Set Exact

		SetDate(.t.) = Set Date BRITISH
		SetDate(.f.) = Set Date AMERICAN


	Б.Команды-модификаторы.

<HR>
	SetInde([&lt;ExprC>]) --> .F.

	=Set Index

	Без параметра(или неверным параметром) = Set Index To

	<em>Пример:</em>
		SetIndex('D:\TMP.NTX')

<HR>
	SetPrint([&lt;ExprC>]) --> .F.

	=Set Printer

	Без параметра(или неверным параметром) = Set Printer To

	<em>Пример:</em>
		SetPrint('LPT2')	Переназначает вывод на LPT2

<HR>
	SetFilt([&lt;ExprC>]) --> выражение фильтра

	=Set Filter

	Без параметра(или неверным параметром) = Set Filter To

	<em>Пример:</em>
		SetFilt([ 'My' $ Name ])

<HR>
	SetFunc(&lt;ExprC>,&lt;KeyCode>) --> .F.

	=Set Function

	<em>Пример:</em>
		SetFunc('Example',-6)

	 В режиме редактирования при нажатии <tt>F7</tt> будет выводиться
'Example'


<a name="pp4b4">
<h6>4. Прочие системные функции.</h6><pre>

<HR>
	ModiFile(&lt;FileName>)	--> .T. при успешной записи

	Простейший текстовый редактор. Поскольку использует MemoEdit,
то редактирует файлы до 64K. В условиях малого количества памяти, этот 
размер может уменьшаться.

	<em>Пример:</em>
		ModiFile('c:\config.Sys')

<HR>
	Scatter()

	Записывает содержимое текущей записи в массив с именем _Scatter.
Признак удаления записывается в последнем элементе массива. Массив может
не существовать до вызова.

<HR>
	Gather()

	Записывает в текущую запись массив с именем _Scatter, обычно
созданный функцией Scatter(). Признак удаления записывается в последнем
элементе массива.

<HR>
	SWAP(&lt;recno1>,&lt;recno2>)

	Обменивает через буфер содержимое 2-х записей с физическими
номерами recno1, recno2.

	<em>Пример:</em>
		Swap(1,3)

<HR>
	SwapAll(&lt;nSrc>,&lt;nDst>,&lt;nMuch>[,&lt;lRev>])

	Обменивает через буфер содержимое nMuch записей, начина
с физической записи nSrc. Если задано lRev=.T., то замена будет
проводиться, начиная с последней записи в диапазоне, что имеет
значение при пересекающихся диапазонах.

	<em>Примеры:</em>
		SwapAll(1, 100, 3)	//1<->100, 2<->101,3<->102

		SwapAll(1, 10, 10, .T.)	//10<->19 .. 1<->10

<HR>
	InsertAll(&lt;nMuch>)

	Вставляет nMuch записей перед текущей. При включенных индексах
не работает.

<HR>
	WORK(&lt;HEAD>) --> ExprC

	Определяет истинное название поля по заголовку. Это бывает нужно
в случае задания полей по <tt>Ctrl+F2</tt>, когда Вы не помните, как же реально
называлось поле, а его имя надо указать, например, в поиске.

	<em>Пример:</em>
		Work('Мое имя для 2-го поля') --> 'S02'

<HR>
	FindMax(&lt;NeedMax>,[&lt;FieldName>],[&lt;EvalBlock>]) --> MaxVal

	Универсальная функция поиска максимума/минимума.

	Параметры:
		NeedMax - .T., если нужен максимум,
			  .F. - минимум
		FieldName - поле или выражение, по умолчанию -
			    текущее поле.
		EvalBlock - блок кода, вычисляемый для сравнения,
			    по умолчанию - значение FieldName ( {|i| i } )

	<em>Примеры:</em>
		FindMax(.T.,'S02') --> 32

		FindMax(.F.,'S02') --> 10

	// длина самого длинного имени

		FindMax(.T.,'Name',{|i| Len(Trim(i))}) --> 5
			(найдено 'Your1')

<HR>
	PrintEdit([&lt;FileName>])

	Выводит текущую запись на устройство печати в развернутом виде.
Без параметра - на принтер. По нажатию <tt>Ctrl+P</tt> в BDBFS -
в файл с именем &lt;currentbase>.Rec . Допись/перепись файла
зависит от соответствующей настройки принтера.


	<em>Пример:</em>

	NEW.DBF Запись 1
	------------------------------------
	NAME				Your
	S02				12
	S03				1
	S04				13

<HR>
<a name="pp4for">
	 For(&lt;nFrom>,&lt;nTo>,&lt;bEval>)

	Цикл For. Может пригодиться, например, <a href="#p16">в INI-файлах</a>.
Блоку bEval в качестве параметра передается переменная цикла.

	<em>Пример:</em>
		cSet:=''
		For(1,254,{|_1|cSet:=cSet+CHR(_1)})

<HR>
	 While(&lt;cCondition>,&lt;bEval>[,&lt;cFor>][,&lt;lBase>])

	Цикл While. Если передан lBase==.T. то после выполнения bEval
делается SKIP.

	<em>Пример:</em>
		cName:=''
		While( '!EOF()', {|| cName+= Name},,.T.)

	Результат:	 'YourYour1MyMy1'

		cName:=''
		While( '!EOF()', {|| cName+= Name},'s02 &lt; 30',.T.)

	Результат:	 'YourMy'


<a name="pp4b5">
<h6>5. Функции организации интерфейса.</h6><pre>

	Эти функции применимы, главным образом, в плагинах. См. также
включаемый файл bdbfs.ch, облегчающий применение этих функций.

<HR>
	NFIND((&lt;_mess>,[&lt;_var>],[&lt;_color>],[&lt;_Footer>],;
		[&lt;lNeedTone>],[&lt;nTimeWait>],;
		[&lt;nlShine>],[&lt;nMuch)] )

	Универсальная функция показа результата.

	Параметры:
		_mess - сообщение любого типа
		_var - переменная результата. Если определена, то:
			- результат записывается в глобальную историю
			- с ним можно производить дополнительные действия.
		_color - цвет вывода, по умолчанию _im
		_Footer - сообщение появляющееся на нижней рамке
		lNeedTone - необходимость звукового сообщения
		nTimeWait - время показа в секундах (по умолчанию - до
			    нажатия клавиши)
		nlShine - позиция в строке вывода, с которой надо
			  подсветить другим цветом (_HdColor)
		nMuch - сколько символов подсветить.

	<em>Примеры:</em>
		Nfind('Готово')

		Nfind("Готово",,,,.T.)	//со звуком

		Nfind(Date(),,,'Сегодня:')

		nSum:=Sum('s01+s02+s03')
		Nfind(nSum, nSum, ,"Результат суммирования",.T., 30)

		Nfind(nls,,,"Подсвечен контрольный разряд",,,,5,1)

<HR>
	Meter(&lt;nStep>,[&lt;cMsg>],[&lt;nCurr>],[&lt;nTotal>])

	Универсальная функция показа прогресс-индикатора.

	Параметры:
		nStep - этап. Допустимые значения:
			1 - Старт (начальная разрисовка экрана)
			2 - Показать (собственно, прогресс)
			3 - Финиш (восстановить экран)

		cMsg - предупреждающее сообщение, по умолчанию -
			"Подождите..."
		nCurr - порядковый номер обрабатываемой записи, по
			умолчанию - номер ключа в индексе или номер
			записи без индекса
		nTotal - всего записей, которые нуждаются в обработке,
			по умолчанию - общее количество записей с учетом
			фильтра, индекса и признака Все/Оставшиеся.

	<em>Пример:</em>
		Meter(1, 'ВЫЧИСЛЕНИЕ КОНТРОЛЬНЫХ СУММ')
		GO TOP
		_tally:=0
		WHILE !EOF()
			_Field->Crc:=Crc32( Name+XTOC(s02)+XTOC(s03))
			IF RECNO()-_tally > 10
				_tally:=RECNO()
				Meter(2)
			ENDIF
		ENDDO
		Meter(3)

<HR>
	CheckEsc([&lt;lStart>],[&lt;nTotal>]) -->lContinue

	Функция организует вызов прогресс индикатора с интервалом,
заданным в системной переменной _SX_STEP, с проверкой
возможного прерывания процесса пользователем по ESC.

	<em>Пример:</em>
		Meter(1)
		CheckEsc(.T.)	//Обнулить счетчик
		DO WHILE CheckEsc()
			...
		ENDDO
		Meter(3)

<HR>
	CheckFound([&lt;lFnd>])

	Функция:
		- закрывает Meter(),
		- при переданном lFnd, и !FOUND() говорит, что поиск
		  неуспешен, в противном случае, сообщает, что, мол,
		  готово.

<HR>
	GetName(&lt;chead>,&lt;_varName>,[&lt;cMask>],[&lt;cGetMask>],;
		[&lt;lCanSelect>],[&lt;lReturn>],[&lt;lPsw>]) -->lRes

	Универсальная функция ввода/подбора системных переменных.
Может предлагать выбор из истории, подбор файла в файлере,
выбор списка полей.

	Параметры:
		 cHead - заголовок окна.
		 _VarName - имя редактируемой переменной. Должно
			   начинаться с символа _.
		 cMask - маска выбора файлов в файлере (по F9)
		 cGetMask - маска ввода
		 lCanSelect - если .T. - добавляется диалог выбора полей
			      по Alt+F2
		 lReturn -  надо вернуться в текущий каталог в
			    случае "прогулок" в файлере.
		 lPsw - Режим ввода пароля (символы не отображаются).

	<em>Примеры:</em>
		m->_OutFile:='CopyFile'
		IF GetName("Задайте имя файла копии",'_Outfile')
			__CopyFile('MyFile.DBF',_OutFile)
		ENDIF

		_snds:=0
		IF !GetName("Задайте сумму вместе с НДС","_snds")
			RETURN 0
		ENDIF

		IF GetName("Задайте поля для обработки",'_ckField',,,.T.)
			...
		ENDIF

		IF GetName("Файл для уничтожения",'_DelFile',;
			   '*.BAK',,,.T.)
			FERASE(_DelFile)
		ENDIF

<HR>
	Panel(&lt;nTop>,&lt;nLeft>,&lt;nBottom>,&lt;nRight>,;
	      &lt;aMess>,&lt;aColor>,&lt;nBottomBord>)

	Рисует "3-х мерную" панель.

  nTop,nLeft
   +-------------------------------------------+
   │               aMess[1]                    │
   │                 ...                       │
   │               aMess[n]                    │
   │ +---------------------------------------+ │
   │ │                                       │ │
   │ │                                       │ │
   │ │                                       │ │
   │ +---------------------------------------+ │ nBottomBord
   +-------------------------------------------+ nBottom,nRight

	Внешний прямоугольник рисуется выпуклым, внутренний - вогнутым.
При передаче массива сообщений (или строки; допускается также
передача в виде строки, разделенной запятыми, - для отделения частей
сообщения), каждая строчка сообщения записывается с первой строки
после внешней рамки.
Внутренний прямоугольник рисуется со следующей после сообщения строки
и до строки nBottom-nBottomBord [по умолчанию - 1].

	Может быть передан массив цветов aColor из 3-х элементов или
соответствующая строка стандартных цветовых определений.
Если массив цветов или его компоненты не заданы - используется SetColor().
Применение элементов массива цветов:
	1 - цвет внешнего окна
	2 - цвет сообщения
	3 - цвет внутреннего окна.

	Примеры:

	Panel(10,10,16,69,'Ошибка записи !, Нажмите что-нибудь',AlarmColor)

	Panel(10,10,17,69,{'Табло',''},{m->_cm,m->_im,m->_cm},2)

<HR>
	ReadCycle(&lt;aGets>,&lt;aSets>,&lt;sc_Row>,&lt;sc_col>) -->lRes

	Универсальная функция ввода любых величин. Редакция выполняется
в цикле до принудительного нажатия ESC или F10. Обычно применяется для
конфигурации.

	Параметры:
		aGets - массив массивов параметров GET для каждой
			переменной. Структура:
				{row,col,msg,[picture],[validblock]}
		aSets - массив переменных для редактирования
		sc_row, sc_col - координаты на экране, в которых
			выводится индикатор Вставка/Замена

	<em>Пример:</em>
		См. PLUGINS\pvi.ini в поставке.


<a name="pp4b6">
<h6>6. Банковские функции.</h6><pre>

<HR>
	Vkrz1(mfo)

	Возвращает правильный номер МФО по 5 или 6 - разрядному номеру.

	Параметр может быть числовым или символьным, возвращаемое
значение - числовое.

	<em>Примеры:</em>
		Vkrz1(30403) --> 304030
		Vkrz1('304039') --> 304030

<HR>
	Vkrz14(account,mfo)

	Возвращает правильный счет по плану счетов НБ Украины,
соответствующий заданному номеру МФО.

	Параметры могут быть числовыми или символьными,	возвращаемое
значение - числовое.

	<em>Примеры:</em>
		Vkrz14(1210072810,300001) --> 1210772810
		{<tt>F7</tt>} Vkrz14(Nls,Mfo)&lt;>Nls	// найти неверные счета

<HR>
	Vkrz20(account,Rkc)

	Возвращает правильный счет по плану счетов Госбанка России,
соответствующий заданному номеру РКЦ или кредитной организации.

	Параметры могут быть числовыми или символьными,	возвращаемое
значение - символьное.

	<em>Пример:</em>
		Vkrz20('30114В84К00000000501',312) --> 30114В84600000000501

<center><form>
<input type="button" value="К оглавлению" onClick="window.location.href='#contents'">
</form></center>
</HTML>
